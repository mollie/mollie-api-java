/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.mollie.mollie;

import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.models.errors.APIException;
import com.mollie.mollie.models.errors.CancelOrderLinesOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.CancelOrderLinesResponseBody;
import com.mollie.mollie.models.errors.CancelOrderOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.CancelOrderResponseBody;
import com.mollie.mollie.models.errors.CreateOrderPaymentResponseBody;
import com.mollie.mollie.models.errors.CreateOrderResponseBody;
import com.mollie.mollie.models.errors.ManageOrderLinesResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderLineOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderLineResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderResponseBody;
import com.mollie.mollie.models.operations.CancelOrderLinesRequest;
import com.mollie.mollie.models.operations.CancelOrderLinesRequestBody;
import com.mollie.mollie.models.operations.CancelOrderLinesRequestBuilder;
import com.mollie.mollie.models.operations.CancelOrderLinesResponse;
import com.mollie.mollie.models.operations.CancelOrderRequest;
import com.mollie.mollie.models.operations.CancelOrderRequestBuilder;
import com.mollie.mollie.models.operations.CancelOrderResponse;
import com.mollie.mollie.models.operations.CreateOrderPaymentRequest;
import com.mollie.mollie.models.operations.CreateOrderPaymentRequestBuilder;
import com.mollie.mollie.models.operations.CreateOrderPaymentResponse;
import com.mollie.mollie.models.operations.CreateOrderRequest;
import com.mollie.mollie.models.operations.CreateOrderRequestBody;
import com.mollie.mollie.models.operations.CreateOrderRequestBuilder;
import com.mollie.mollie.models.operations.CreateOrderResponse;
import com.mollie.mollie.models.operations.GetOrderRequest;
import com.mollie.mollie.models.operations.GetOrderRequestBuilder;
import com.mollie.mollie.models.operations.GetOrderResponse;
import com.mollie.mollie.models.operations.GetOrderResponseBody;
import com.mollie.mollie.models.operations.ListOrdersRequest;
import com.mollie.mollie.models.operations.ListOrdersRequestBuilder;
import com.mollie.mollie.models.operations.ListOrdersResponse;
import com.mollie.mollie.models.operations.ListOrdersResponseBody;
import com.mollie.mollie.models.operations.ManageOrderLinesRequest;
import com.mollie.mollie.models.operations.ManageOrderLinesRequestBody;
import com.mollie.mollie.models.operations.ManageOrderLinesRequestBuilder;
import com.mollie.mollie.models.operations.ManageOrderLinesResponse;
import com.mollie.mollie.models.operations.SDKMethodInterfaces.*;
import com.mollie.mollie.models.operations.UpdateOrderLineRequest;
import com.mollie.mollie.models.operations.UpdateOrderLineRequestBody;
import com.mollie.mollie.models.operations.UpdateOrderLineRequestBuilder;
import com.mollie.mollie.models.operations.UpdateOrderLineResponse;
import com.mollie.mollie.models.operations.UpdateOrderRequest;
import com.mollie.mollie.models.operations.UpdateOrderRequestBody;
import com.mollie.mollie.models.operations.UpdateOrderRequestBuilder;
import com.mollie.mollie.models.operations.UpdateOrderResponse;
import com.mollie.mollie.utils.HTTPClient;
import com.mollie.mollie.utils.HTTPRequest;
import com.mollie.mollie.utils.Hook.AfterErrorContextImpl;
import com.mollie.mollie.utils.Hook.AfterSuccessContextImpl;
import com.mollie.mollie.utils.Hook.BeforeRequestContextImpl;
import com.mollie.mollie.utils.SerializedBody;
import com.mollie.mollie.utils.Utils.JsonShape;
import com.mollie.mollie.utils.Utils;
import java.io.InputStream;
import java.lang.Boolean;
import java.lang.Exception;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable; 

public class OrdersAPI implements
            MethodCallCreateOrder,
            MethodCallListOrders,
            MethodCallGetOrder,
            MethodCallUpdateOrder,
            MethodCallCancelOrder,
            MethodCallManageOrderLines,
            MethodCallCancelOrderLines,
            MethodCallUpdateOrderLine,
            MethodCallCreateOrderPayment {

    private final SDKConfiguration sdkConfiguration;

    OrdersAPI(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }


    /**
     * Create order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still have the `created` status.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public CreateOrderRequestBuilder createOrder() {
        return new CreateOrderRequestBuilder(this);
    }

    /**
     * Create order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still have the `created` status.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderResponse createOrderDirect() throws Exception {
        return createOrder(JsonNullable.undefined(), Optional.empty());
    }
    
    /**
     * Create order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still have the `created` status.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param embed This endpoint allows embedding related API items by appending the following values via the `embed` query string parameter.

    * `payments`: Include all payments created for this order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderResponse createOrder(
            JsonNullable<String> embed,
            Optional<? extends CreateOrderRequestBody> requestBody) throws Exception {
        CreateOrderRequest request =
            CreateOrderRequest
                .builder()
                .embed(embed)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/orders");
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CreateOrderRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreateOrderResponse.Builder _resBuilder = 
            CreateOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreateOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreateOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreateOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List orders
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve all orders.
     * 
     * The results are paginated.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.read**](/reference/authentication)
     * @return The call builder
     */
    public ListOrdersRequestBuilder listOrders() {
        return new ListOrdersRequestBuilder(this);
    }

    /**
     * List orders
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve all orders.
     * 
     * The results are paginated.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.read**](/reference/authentication)
     * @param request The request object containing all of the parameters for the API call.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListOrdersResponse listOrders(
            ListOrdersRequest request) throws Exception {
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/orders");
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListOrdersRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-orders", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-orders",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-orders",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-orders",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListOrdersResponse.Builder _resBuilder = 
            ListOrdersResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListOrdersResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListOrdersResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListOrdersResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListOrdersResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListOrdersResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Get order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.read**](/reference/authentication)
     * @return The call builder
     */
    public GetOrderRequestBuilder getOrder() {
        return new GetOrderRequestBuilder(this);
    }

    /**
     * Get order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.read**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetOrderResponse getOrder(
            String id) throws Exception {
        return getOrder(id, JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * Get order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.read**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param embed This endpoint allows embedding related API items by appending the following values via the `embed` query string parameter.

    * `payments`: Include all payments created for this order.
    * `refunds`: Include all refunds created for this order.
    * `shipments`: Include all shipments created for this order.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetOrderResponse getOrder(
            String id,
            JsonNullable<String> embed,
            JsonNullable<Boolean> testmode) throws Exception {
        GetOrderRequest request =
            GetOrderRequest
                .builder()
                .id(id)
                .embed(embed)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                GetOrderRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "get-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "get-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetOrderResponse.Builder _resBuilder = 
            GetOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                GetOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GetOrderResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.GetOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.GetOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public UpdateOrderRequestBuilder updateOrder() {
        return new UpdateOrderRequestBuilder(this);
    }

    /**
     * Update order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderResponse updateOrder(
            String id) throws Exception {
        return updateOrder(id, Optional.empty());
    }
    
    /**
     * Update order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderResponse updateOrder(
            String id,
            Optional<? extends UpdateOrderRequestBody> requestBody) throws Exception {
        UpdateOrderRequest request =
            UpdateOrderRequest
                .builder()
                .id(id)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdateOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdateOrderResponse.Builder _resBuilder = 
            UpdateOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdateOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`, `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a payment method was used that does not support authorizations, cancelation is no longer possible. You will have to issue a refund instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public CancelOrderRequestBuilder cancelOrder() {
        return new CancelOrderRequestBuilder(this);
    }

    /**
     * Cancel order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`, `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a payment method was used that does not support authorizations, cancelation is no longer possible. You will have to issue a refund instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderResponse cancelOrder(
            String id) throws Exception {
        return cancelOrder(id, JsonNullable.undefined());
    }
    
    /**
     * Cancel order
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`, `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a payment method was used that does not support authorizations, cancelation is no longer possible. You will have to issue a refund instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderResponse cancelOrder(
            String id,
            JsonNullable<Boolean> testmode) throws Exception {
        CancelOrderRequest request =
            CancelOrderRequest
                .builder()
                .id(id)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CancelOrderRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelOrderResponse.Builder _resBuilder = 
            CancelOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Manage order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized` order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to ‚Ç¨100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -‚Ç¨10.00.
     * 
     * The order total is ‚Ç¨90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer opts to replace one of order line A's items with item C. Item C costs ‚Ç¨40.00, however, discount B does not apply to item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -‚Ç¨5.00.
     * * Order line C is added with amount ‚Ç¨40.00.
     * 
     * The updated order totals ‚Ç¨85.00.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public ManageOrderLinesRequestBuilder manageOrderLines() {
        return new ManageOrderLinesRequestBuilder(this);
    }

    /**
     * Manage order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized` order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to ‚Ç¨100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -‚Ç¨10.00.
     * 
     * The order total is ‚Ç¨90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer opts to replace one of order line A's items with item C. Item C costs ‚Ç¨40.00, however, discount B does not apply to item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -‚Ç¨5.00.
     * * Order line C is added with amount ‚Ç¨40.00.
     * 
     * The updated order totals ‚Ç¨85.00.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ManageOrderLinesResponse manageOrderLines(
            String orderId) throws Exception {
        return manageOrderLines(orderId, Optional.empty());
    }
    
    /**
     * Manage order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized` order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to ‚Ç¨100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -‚Ç¨10.00.
     * 
     * The order total is ‚Ç¨90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer opts to replace one of order line A's items with item C. Item C costs ‚Ç¨40.00, however, discount B does not apply to item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -‚Ç¨5.00.
     * * Order line C is added with amount ‚Ç¨40.00.
     * 
     * The updated order totals ‚Ç¨85.00.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ManageOrderLinesResponse manageOrderLines(
            String orderId,
            Optional<? extends ManageOrderLinesRequestBody> requestBody) throws Exception {
        ManageOrderLinesRequest request =
            ManageOrderLinesRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ManageOrderLinesRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "manage-order-lines", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ManageOrderLinesResponse.Builder _resBuilder = 
            ManageOrderLinesResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ManageOrderLinesResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ManageOrderLinesResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ManageOrderLinesResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the [Create order refund](create-order-refund) endpoint instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public CancelOrderLinesRequestBuilder cancelOrderLines() {
        return new CancelOrderLinesRequestBuilder(this);
    }

    /**
     * Cancel order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the [Create order refund](create-order-refund) endpoint instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderLinesResponse cancelOrderLines(
            String orderId) throws Exception {
        return cancelOrderLines(orderId, Optional.empty());
    }
    
    /**
     * Cancel order lines
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the [Create order refund](create-order-refund) endpoint instead.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderLinesResponse cancelOrderLines(
            String orderId,
            Optional<? extends CancelOrderLinesRequestBody> requestBody) throws Exception {
        CancelOrderLinesRequest request =
            CancelOrderLinesRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelOrderLinesRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-order-lines", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelOrderLinesResponse.Builder _resBuilder = 
            CancelOrderLinesResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelOrderLinesResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "204")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderLinesResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderLinesResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderLinesOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderLinesOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update order line
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order) endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @return The call builder
     */
    public UpdateOrderLineRequestBuilder updateOrderLine() {
        return new UpdateOrderLineRequestBuilder(this);
    }

    /**
     * Update order line
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order) endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderLineResponse updateOrderLine(
            String orderId,
            String id) throws Exception {
        return updateOrderLine(orderId, id, Optional.empty());
    }
    
    /**
     * Update order line
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order) endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **orders.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderLineResponse updateOrderLine(
            String orderId,
            String id,
            Optional<? extends UpdateOrderLineRequestBody> requestBody) throws Exception {
        UpdateOrderLineRequest request =
            UpdateOrderLineRequest
                .builder()
                .orderId(orderId)
                .id(id)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdateOrderLineRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-order-line", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order-line",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-order-line",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order-line",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdateOrderLineResponse.Builder _resBuilder = 
            UpdateOrderLineResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdateOrderLineResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderLineResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderLineResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderLineOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderLineOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Create order payment
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint. Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These cannot be changed via this endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The call builder
     */
    public CreateOrderPaymentRequestBuilder createOrderPayment() {
        return new CreateOrderPaymentRequestBuilder(this);
    }

    /**
     * Create order payment
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint. Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These cannot be changed via this endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderPaymentResponse createOrderPayment(
            String orderId) throws Exception {
        return createOrderPayment(orderId, Optional.empty());
    }
    
    /**
     * Create order payment
     * **‚ö†Ô∏è We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint. Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These cannot be changed via this endpoint.
     * 
     * &gt; üîë Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderPaymentResponse createOrderPayment(
            String orderId,
            Optional<? extends Object> requestBody) throws Exception {
        CreateOrderPaymentRequest request =
            CreateOrderPaymentRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CreateOrderPaymentRequest.class,
                _baseUrl,
                "/orders/{orderId}/payments",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-order-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreateOrderPaymentResponse.Builder _resBuilder = 
            CreateOrderPaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreateOrderPaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreateOrderPaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreateOrderPaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
