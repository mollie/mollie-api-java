/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.mollie.mollie;

import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.models.errors.APIException;
import com.mollie.mollie.models.errors.CancelOrderLinesOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.CancelOrderLinesResponseBody;
import com.mollie.mollie.models.errors.CancelOrderOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.CancelOrderResponseBody;
import com.mollie.mollie.models.errors.CreateOrderPaymentResponseBody;
import com.mollie.mollie.models.errors.CreateOrderResponseBody;
import com.mollie.mollie.models.errors.ManageOrderLinesResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderLineOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderLineResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderOrdersAPIResponseBody;
import com.mollie.mollie.models.errors.UpdateOrderResponseBody;
import com.mollie.mollie.models.operations.CancelOrderLinesRequest;
import com.mollie.mollie.models.operations.CancelOrderLinesRequestBody;
import com.mollie.mollie.models.operations.CancelOrderLinesRequestBuilder;
import com.mollie.mollie.models.operations.CancelOrderLinesResponse;
import com.mollie.mollie.models.operations.CancelOrderLinesSecurity;
import com.mollie.mollie.models.operations.CancelOrderRequest;
import com.mollie.mollie.models.operations.CancelOrderRequestBuilder;
import com.mollie.mollie.models.operations.CancelOrderResponse;
import com.mollie.mollie.models.operations.CancelOrderSecurity;
import com.mollie.mollie.models.operations.CreateOrderPaymentRequest;
import com.mollie.mollie.models.operations.CreateOrderPaymentRequestBuilder;
import com.mollie.mollie.models.operations.CreateOrderPaymentResponse;
import com.mollie.mollie.models.operations.CreateOrderPaymentSecurity;
import com.mollie.mollie.models.operations.CreateOrderRequest;
import com.mollie.mollie.models.operations.CreateOrderRequestBody;
import com.mollie.mollie.models.operations.CreateOrderRequestBuilder;
import com.mollie.mollie.models.operations.CreateOrderResponse;
import com.mollie.mollie.models.operations.CreateOrderSecurity;
import com.mollie.mollie.models.operations.GetOrderRequest;
import com.mollie.mollie.models.operations.GetOrderRequestBuilder;
import com.mollie.mollie.models.operations.GetOrderResponse;
import com.mollie.mollie.models.operations.GetOrderResponseBody;
import com.mollie.mollie.models.operations.GetOrderSecurity;
import com.mollie.mollie.models.operations.ListOrdersRequest;
import com.mollie.mollie.models.operations.ListOrdersRequestBuilder;
import com.mollie.mollie.models.operations.ListOrdersResponse;
import com.mollie.mollie.models.operations.ListOrdersResponseBody;
import com.mollie.mollie.models.operations.ListOrdersSecurity;
import com.mollie.mollie.models.operations.ManageOrderLinesRequest;
import com.mollie.mollie.models.operations.ManageOrderLinesRequestBody;
import com.mollie.mollie.models.operations.ManageOrderLinesRequestBuilder;
import com.mollie.mollie.models.operations.ManageOrderLinesResponse;
import com.mollie.mollie.models.operations.ManageOrderLinesSecurity;
import com.mollie.mollie.models.operations.SDKMethodInterfaces.*;
import com.mollie.mollie.models.operations.UpdateOrderLineRequest;
import com.mollie.mollie.models.operations.UpdateOrderLineRequestBody;
import com.mollie.mollie.models.operations.UpdateOrderLineRequestBuilder;
import com.mollie.mollie.models.operations.UpdateOrderLineResponse;
import com.mollie.mollie.models.operations.UpdateOrderLineSecurity;
import com.mollie.mollie.models.operations.UpdateOrderRequest;
import com.mollie.mollie.models.operations.UpdateOrderRequestBody;
import com.mollie.mollie.models.operations.UpdateOrderRequestBuilder;
import com.mollie.mollie.models.operations.UpdateOrderResponse;
import com.mollie.mollie.models.operations.UpdateOrderSecurity;
import com.mollie.mollie.utils.HTTPClient;
import com.mollie.mollie.utils.HTTPRequest;
import com.mollie.mollie.utils.Hook.AfterErrorContextImpl;
import com.mollie.mollie.utils.Hook.AfterSuccessContextImpl;
import com.mollie.mollie.utils.Hook.BeforeRequestContextImpl;
import com.mollie.mollie.utils.SerializedBody;
import com.mollie.mollie.utils.Utils.JsonShape;
import com.mollie.mollie.utils.Utils;
import java.io.InputStream;
import java.lang.Boolean;
import java.lang.Exception;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable; 

public class OrdersAPI implements
            MethodCallCreateOrder,
            MethodCallListOrders,
            MethodCallGetOrder,
            MethodCallUpdateOrder,
            MethodCallCancelOrder,
            MethodCallManageOrderLines,
            MethodCallCancelOrderLines,
            MethodCallUpdateOrderLine,
            MethodCallCreateOrderPayment {

    private final SDKConfiguration sdkConfiguration;

    OrdersAPI(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }


    /**
     * Create order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can
     * then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments
     * API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same
     * order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still
     * have the `created` status.
     * @return The call builder
     */
    public CreateOrderRequestBuilder create() {
        return new CreateOrderRequestBuilder(this);
    }

    /**
     * Create order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can
     * then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments
     * API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same
     * order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still
     * have the `created` status.
     * @param security The security details to use for authentication.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderResponse create(
            CreateOrderSecurity security) throws Exception {
        return create(security, JsonNullable.undefined(), Optional.empty());
    }
    
    /**
     * Create order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * When creating an order, a payment will automatically be created to allow your customer to pay for the order. You can
     * then redirect your customer to the URL in the `_links.checkout` property from the response, similar to the Payments
     * API.
     * 
     * Unlike the Payments API, if a payment fails, expires, or is canceled, you can create a new payment under the same
     * order using the [Create order payment endpoint](create-order-payment). This is only possible for orders that still
     * have the `created` status.
     * @param security The security details to use for authentication.
     * @param embed This endpoint allows embedding related API items by appending the following values via the `embed` query string
    parameter.

    * `payments`: Include all payments created for this order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderResponse create(
            CreateOrderSecurity security,
            JsonNullable<String> embed,
            Optional<? extends CreateOrderRequestBody> requestBody) throws Exception {
        CreateOrderRequest request =
            CreateOrderRequest
                .builder()
                .embed(embed)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/orders");
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CreateOrderRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreateOrderResponse.Builder _resBuilder = 
            CreateOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreateOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreateOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreateOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List orders
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve all orders.
     * 
     * The results are paginated.
     * @return The call builder
     */
    public ListOrdersRequestBuilder list() {
        return new ListOrdersRequestBuilder(this);
    }

    /**
     * List orders
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve all orders.
     * 
     * The results are paginated.
     * @param request The request object containing all of the parameters for the API call.
     * @param security The security details to use for authentication.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListOrdersResponse list(
            ListOrdersRequest request,
            ListOrdersSecurity security) throws Exception {
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/orders");
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListOrdersRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-orders", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-orders",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-orders",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-orders",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListOrdersResponse.Builder _resBuilder = 
            ListOrdersResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListOrdersResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListOrdersResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListOrdersResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListOrdersResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListOrdersResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Get order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the
     * Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * @return The call builder
     */
    public GetOrderRequestBuilder get() {
        return new GetOrderRequestBuilder(this);
    }

    /**
     * Get order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the
     * Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetOrderResponse get(
            GetOrderSecurity security,
            String id) throws Exception {
        return get(security, id, JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * Get order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the
     * Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Retrieve a single order object by its ID.
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param embed This endpoint allows embedding related API items by appending the following values via the `embed` query string
    parameter.

    * `payments`: Include all payments created for this order.
    * `refunds`: Include all refunds created for this order.
    * `shipments`: Include all shipments created for this order.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetOrderResponse get(
            GetOrderSecurity security,
            String id,
            JsonNullable<String> embed,
            JsonNullable<Boolean> testmode) throws Exception {
        GetOrderRequest request =
            GetOrderRequest
                .builder()
                .id(id)
                .embed(embed)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                GetOrderRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "get-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "get-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetOrderResponse.Builder _resBuilder = 
            GetOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                GetOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GetOrderResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.GetOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.GetOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * @return The call builder
     */
    public UpdateOrderRequestBuilder update() {
        return new UpdateOrderRequestBuilder(this);
    }

    /**
     * Update order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderResponse update(
            UpdateOrderSecurity security,
            String id) throws Exception {
        return update(security, id, Optional.empty());
    }
    
    /**
     * Update order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Certain details of an existing order can be updated.
     * 
     * For an in-depth explanation of each parameter, see [Create order](create-order).
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderResponse update(
            UpdateOrderSecurity security,
            String id,
            Optional<? extends UpdateOrderRequestBody> requestBody) throws Exception {
        UpdateOrderRequest request =
            UpdateOrderRequest
                .builder()
                .id(id)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdateOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdateOrderResponse.Builder _resBuilder = 
            UpdateOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdateOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`,
     * `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a
     * payment method was used that does not support authorizations, cancelation is no longer possible. You will have to
     * issue a refund instead.
     * @return The call builder
     */
    public CancelOrderRequestBuilder cancel() {
        return new CancelOrderRequestBuilder(this);
    }

    /**
     * Cancel order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`,
     * `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a
     * payment method was used that does not support authorizations, cancelation is no longer possible. You will have to
     * issue a refund instead.
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderResponse cancel(
            CancelOrderSecurity security,
            String id) throws Exception {
        return cancel(security, id, JsonNullable.undefined());
    }
    
    /**
     * Cancel order
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An open order may be canceled if it does not have any open payments yet, and while its status is either `created`,
     * `authorized`, or `shipping`.
     * 
     * If the order was already authorized, the authorization will be released.
     * 
     * For an order with status `shipping`, only the order lines that were still pending will be canceled if possible. If a
     * payment method was used that does not support authorizations, cancelation is no longer possible. You will have to
     * issue a refund instead.
     * @param security The security details to use for authentication.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderResponse cancel(
            CancelOrderSecurity security,
            String id,
            JsonNullable<Boolean> testmode) throws Exception {
        CancelOrderRequest request =
            CancelOrderRequest
                .builder()
                .id(id)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelOrderRequest.class,
                _baseUrl,
                "/orders/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CancelOrderRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-order", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-order",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelOrderResponse.Builder _resBuilder = 
            CancelOrderResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelOrderResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Manage order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized`
     * order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the
     * payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to €100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -€10.00.
     * 
     * The order total is €90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer
     * opts to replace one of order line A's items with item C. Item C costs €40.00, however, discount B does not apply to
     * item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -€5.00.
     * * Order line C is added with amount €40.00.
     * 
     * The updated order totals €85.00.
     * @return The call builder
     */
    public ManageOrderLinesRequestBuilder manageLines() {
        return new ManageOrderLinesRequestBuilder(this);
    }

    /**
     * Manage order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized`
     * order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the
     * payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to €100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -€10.00.
     * 
     * The order total is €90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer
     * opts to replace one of order line A's items with item C. Item C costs €40.00, however, discount B does not apply to
     * item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -€5.00.
     * * Order line C is added with amount €40.00.
     * 
     * The updated order totals €85.00.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ManageOrderLinesResponse manageLines(
            ManageOrderLinesSecurity security,
            String orderId) throws Exception {
        return manageLines(security, orderId, Optional.empty());
    }
    
    /**
     * Manage order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Use this endpoint to update, cancel, or add one or more order lines of a `created`, `pending`, or `authorized`
     * order.
     * 
     * For an already authorized order, updating the order lines will trigger an additional authorization request to the
     * payment method provider.
     * 
     * For example, your customer placed an order that contains two order lines:
     * 
     * * Order line A contains two items and amounts to €100.00.
     * * Order line B contains a discount of 10% applicable to the items in order line A, which amounts to -€10.00.
     * 
     * The order total is €90.00.
     * 
     * You only have one item of type A left, and therefore contact your customer to find another solution. The customer
     * opts to replace one of order line A's items with item C. Item C costs €40.00, however, discount B does not apply to
     * item C.
     * 
     * Using this endpoint, you can create a request to update the order lines, where:
     * 
     * * Order line A is updated to quantity 1.
     * * Order line B is updated to discount amount -€5.00.
     * * Order line C is added with amount €40.00.
     * 
     * The updated order totals €85.00.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ManageOrderLinesResponse manageLines(
            ManageOrderLinesSecurity security,
            String orderId,
            Optional<? extends ManageOrderLinesRequestBody> requestBody) throws Exception {
        ManageOrderLinesRequest request =
            ManageOrderLinesRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ManageOrderLinesRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "manage-order-lines", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "manage-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ManageOrderLinesResponse.Builder _resBuilder = 
            ManageOrderLinesResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ManageOrderLinesResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ManageOrderLinesResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ManageOrderLinesResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the
     * [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You
     * should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the
     * [Create order refund](create-order-refund) endpoint instead.
     * @return The call builder
     */
    public CancelOrderLinesRequestBuilder cancelLines() {
        return new CancelOrderLinesRequestBuilder(this);
    }

    /**
     * Cancel order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the
     * [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You
     * should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the
     * [Create order refund](create-order-refund) endpoint instead.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderLinesResponse cancelLines(
            CancelOrderLinesSecurity security,
            String orderId) throws Exception {
        return cancelLines(security, orderId, Optional.empty());
    }
    
    /**
     * Cancel order lines
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Cancel one or more order lines that were previously authorized. To cancel the entire order, please refer to the
     * [Cancel order](cancel-order) endpoint instead.
     * 
     * Canceling or partially canceling an order line will immediately release the authorization held for that amount. You
     * should cancel an order line if you do not intend to (fully) ship it.
     * 
     * If the order line was already authorized, the authorization will be released.
     * 
     * For an order line with status `shipping`, the authorization for the quantity that is still pending will be released.
     * 
     * Afterwards, the order line will be marked `completed`.
     * 
     * If the order line is `paid` or already `completed`, you can create a refund using the
     * [Create order refund](create-order-refund) endpoint instead.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelOrderLinesResponse cancelLines(
            CancelOrderLinesSecurity security,
            String orderId,
            Optional<? extends CancelOrderLinesRequestBody> requestBody) throws Exception {
        CancelOrderLinesRequest request =
            CancelOrderLinesRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelOrderLinesRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-order-lines", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-order-lines",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelOrderLinesResponse.Builder _resBuilder = 
            CancelOrderLinesResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelOrderLinesResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "204")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderLinesResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderLinesResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelOrderLinesOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelOrderLinesOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update order line
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be
     * updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer
     * changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need
     * to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint
     * instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order)
     * endpoint.
     * @return The call builder
     */
    public UpdateOrderLineRequestBuilder updateLine() {
        return new UpdateOrderLineRequestBuilder(this);
    }

    /**
     * Update order line
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be
     * updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer
     * changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need
     * to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint
     * instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order)
     * endpoint.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderLineResponse updateLine(
            UpdateOrderLineSecurity security,
            String orderId,
            String id) throws Exception {
        return updateLine(security, orderId, id, Optional.empty());
    }
    
    /**
     * Update order line
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * Update an order line belonging to an order. Only lines with status `created`, `pending`, or `authorized` can be
     * updated.
     * 
     * This endpoint is useful for cases where specific details of an order line are changed. For example, if a customer
     * changes a red shirt for a blue one of the same model. In this case only specific properties of the order line need
     * to be updated, such as the `name`, the `imageUrl`, and perhaps the `amount`.
     * 
     * To swap out an order line for an entirely new order line, use the [Manage order lines](manage-order-lines) endpoint
     * instead.
     * 
     * For an in-depth explanation of each parameter, refer to the `lines` parameter of the [Create order](create-order)
     * endpoint.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateOrderLineResponse updateLine(
            UpdateOrderLineSecurity security,
            String orderId,
            String id,
            Optional<? extends UpdateOrderLineRequestBody> requestBody) throws Exception {
        UpdateOrderLineRequest request =
            UpdateOrderLineRequest
                .builder()
                .orderId(orderId)
                .id(id)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdateOrderLineRequest.class,
                _baseUrl,
                "/orders/{orderId}/lines/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-order-line", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order-line",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-order-line",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-order-line",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdateOrderLineResponse.Builder _resBuilder = 
            UpdateOrderLineResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdateOrderLineResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderLineResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderLineResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateOrderLineOrdersAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateOrderLineOrdersAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Create order payment
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment
     * expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for
     * an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing
     * payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint.
     * Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These
     * cannot be changed via this endpoint.
     * @return The call builder
     */
    public CreateOrderPaymentRequestBuilder createPayment() {
        return new CreateOrderPaymentRequestBuilder(this);
    }

    /**
     * Create order payment
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment
     * expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for
     * an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing
     * payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint.
     * Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These
     * cannot be changed via this endpoint.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderPaymentResponse createPayment(
            CreateOrderPaymentSecurity security,
            String orderId) throws Exception {
        return createPayment(security, orderId, Optional.empty());
    }
    
    /**
     * Create order payment
     * **⚠️ We no longer recommend implementing the Orders API. Please refer to the Payments API instead. We are actively
     * working on adding support for Klarna, Billie, in3 and Vouchers to the Payments API later this year.**
     * 
     * An order has an automatically created payment that your customer can use to pay for the order. When the payment
     * expires you can create a new payment for the order using this endpoint. A maximum of 25 payments can be created for
     * an order.
     * 
     * A new payment can only be created while the status of the order is `created`, and when the status of the existing
     * payment is either `expired`, `canceled` or `failed`.
     * 
     * The endpoint accepts virtually all parameters accepted by the regular [Create payment](create-payment) endpoint.
     * Please refer to that endpoint for the full documentation of all parameters.
     * 
     * The payment inherits certain properties, such as the `amount` and `webhookUrl`, directly from the order. These
     * cannot be changed via this endpoint.
     * @param security The security details to use for authentication.
     * @param orderId Provide the ID of the related order.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateOrderPaymentResponse createPayment(
            CreateOrderPaymentSecurity security,
            String orderId,
            Optional<? extends Object> requestBody) throws Exception {
        CreateOrderPaymentRequest request =
            CreateOrderPaymentRequest
                .builder()
                .orderId(orderId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CreateOrderPaymentRequest.class,
                _baseUrl,
                "/orders/{orderId}/payments",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-order-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-order-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreateOrderPaymentResponse.Builder _resBuilder = 
            CreateOrderPaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreateOrderPaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreateOrderPaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreateOrderPaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
