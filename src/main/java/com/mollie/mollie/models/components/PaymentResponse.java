/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class PaymentResponse {
    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this
     * endpoint.
     */
    @JsonProperty("resource")
    private String resource;


    @JsonProperty("id")
    private String id;

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonProperty("mode")
    private Mode mode;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement
     * when possible.
     * We truncate the description automatically according to the limits of the used payment method. The
     * description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in
     * your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum
     * being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them
     * to fit.
     */
    @JsonProperty("description")
    private String description;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonProperty("amount")
    private Amount amount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private Optional<? extends Amount> amountRefunded;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private Optional<? extends Amount> amountRemaining;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private Optional<? extends Amount> amountCaptured;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private Optional<? extends Amount> amountChargedBack;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private Optional<? extends Amount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
     * can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
     * recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
     * this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
     * parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
     * handle
     * payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
     * your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
     * want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
     * delivered to your
     * local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description
     * of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<Lines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud
     * protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
     * `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends PaymentResponseBillingAddress> billingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends PaymentAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<? extends LocaleResponse> locale;

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
     * checkout. This
     * field is omitted if the country code was not detected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    private JsonNullable<String> countryCode;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
     * specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment
     * method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method
     * selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality
     * to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends MethodResponse> method;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
     * Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
     * country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country
     * are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Metadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a
     * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<? extends CaptureModeResponse> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
     * can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the
     * payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount
     * of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
     * onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
     * authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureBefore")
    private JsonNullable<String> captureBefore;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
     * this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
     * balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected
     * merchant, refer to the
     * `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends ApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish
     * to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more
     * connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the
     * destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
     * the total
     * payment amount have been routed, the amount left will be routed to the current organization
     * automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
     * `applicationFee`
     * parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<EntityPaymentRouteResponse>> routing;


    @JsonProperty("sequenceType")
    private SequenceTypeResponse sequenceType;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private Optional<String> subscriptionId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private Optional<String> mandateId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted
     * in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId`
     * parameter is
     * required.
     */
    @JsonProperty("profileId")
    private String profileId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private Optional<String> settlementId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private Optional<String> orderId;

    /**
     * The payment's status. Refer to the [documentation regarding
     * statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    @JsonProperty("status")
    private PaymentStatus status;

    /**
     * This object offers details about the status of a payment. Currently it is only available for
     * point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusReason")
    private JsonNullable<? extends StatusReason> statusReason;

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * An object containing payment details collected during the payment process. For example, details may
     * include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer
     * to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    private JsonNullable<? extends Details> details;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    @JsonProperty("createdAt")
    private String createdAt;

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
     * the payment is
     * not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
     * payment can no
     * longer expire.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
     * payment did not
     * expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
     * did not fail
     * (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("failedAt")
    private JsonNullable<String> failedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonProperty("_links")
    private PaymentResponseLinks links;

    @JsonCreator
    public PaymentResponse(
            @JsonProperty("resource") String resource,
            @JsonProperty("id") String id,
            @JsonProperty("mode") Mode mode,
            @JsonProperty("description") String description,
            @JsonProperty("amount") Amount amount,
            @JsonProperty("amountRefunded") Optional<? extends Amount> amountRefunded,
            @JsonProperty("amountRemaining") Optional<? extends Amount> amountRemaining,
            @JsonProperty("amountCaptured") Optional<? extends Amount> amountCaptured,
            @JsonProperty("amountChargedBack") Optional<? extends Amount> amountChargedBack,
            @JsonProperty("settlementAmount") Optional<? extends Amount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<Lines>> lines,
            @JsonProperty("billingAddress") Optional<? extends PaymentResponseBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends PaymentAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<? extends LocaleResponse> locale,
            @JsonProperty("countryCode") JsonNullable<String> countryCode,
            @JsonProperty("method") JsonNullable<? extends MethodResponse> method,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends Metadata> metadata,
            @JsonProperty("captureMode") JsonNullable<? extends CaptureModeResponse> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("captureBefore") JsonNullable<String> captureBefore,
            @JsonProperty("applicationFee") JsonNullable<? extends ApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<EntityPaymentRouteResponse>> routing,
            @JsonProperty("sequenceType") SequenceTypeResponse sequenceType,
            @JsonProperty("subscriptionId") Optional<String> subscriptionId,
            @JsonProperty("mandateId") Optional<String> mandateId,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("profileId") String profileId,
            @JsonProperty("settlementId") Optional<String> settlementId,
            @JsonProperty("orderId") Optional<String> orderId,
            @JsonProperty("status") PaymentStatus status,
            @JsonProperty("statusReason") JsonNullable<? extends StatusReason> statusReason,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("details") JsonNullable<? extends Details> details,
            @JsonProperty("createdAt") String createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("failedAt") JsonNullable<String> failedAt,
            @JsonProperty("_links") PaymentResponseLinks links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(countryCode, "countryCode");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(captureBefore, "captureBefore");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusReason, "statusReason");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(details, "details");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(failedAt, "failedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.countryCode = countryCode;
        this.method = method;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.captureBefore = captureBefore;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.status = status;
        this.statusReason = statusReason;
        this.isCancelable = isCancelable;
        this.details = details;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.failedAt = failedAt;
        this.links = links;
    }
    
    public PaymentResponse(
            String resource,
            String id,
            Mode mode,
            String description,
            Amount amount,
            SequenceTypeResponse sequenceType,
            String profileId,
            PaymentStatus status,
            String createdAt,
            PaymentResponseLinks links) {
        this(resource, id, mode,
            description, amount, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), sequenceType,
            Optional.empty(), Optional.empty(), Optional.empty(),
            profileId, Optional.empty(), Optional.empty(),
            status, JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), createdAt, JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), links);
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this
     * endpoint.
     */
    @JsonIgnore
    public String resource() {
        return resource;
    }

    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonIgnore
    public Mode mode() {
        return mode;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement
     * when possible.
     * We truncate the description automatically according to the limits of the used payment method. The
     * description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in
     * your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum
     * being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them
     * to fit.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonIgnore
    public Amount amount() {
        return amount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountRefunded() {
        return (Optional<Amount>) amountRefunded;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountRemaining() {
        return (Optional<Amount>) amountRemaining;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountCaptured() {
        return (Optional<Amount>) amountCaptured;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountChargedBack() {
        return (Optional<Amount>) amountChargedBack;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> settlementAmount() {
        return (Optional<Amount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
     * can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
     * recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
     * this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
     * parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
     * handle
     * payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
     * your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
     * want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
     * delivered to your
     * local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description
     * of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<Lines>> lines() {
        return (JsonNullable<List<Lines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud
     * protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
     * `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentResponseBillingAddress> billingAddress() {
        return (Optional<PaymentResponseBillingAddress>) billingAddress;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentAddress> shippingAddress() {
        return (Optional<PaymentAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LocaleResponse> locale() {
        return (JsonNullable<LocaleResponse>) locale;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
     * checkout. This
     * field is omitted if the country code was not detected.
     */
    @JsonIgnore
    public JsonNullable<String> countryCode() {
        return countryCode;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
     * specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment
     * method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method
     * selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality
     * to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<MethodResponse> method() {
        return (JsonNullable<MethodResponse>) method;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
     * Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
     * country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country
     * are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Metadata> metadata() {
        return (JsonNullable<Metadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a
     * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CaptureModeResponse> captureMode() {
        return (JsonNullable<CaptureModeResponse>) captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
     * can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the
     * payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount
     * of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
     * onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
     * authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> captureBefore() {
        return captureBefore;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
     * this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
     * balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected
     * merchant, refer to the
     * `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ApplicationFee> applicationFee() {
        return (JsonNullable<ApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish
     * to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more
     * connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the
     * destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
     * the total
     * payment amount have been routed, the amount left will be routed to the current organization
     * automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
     * `applicationFee`
     * parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<EntityPaymentRouteResponse>> routing() {
        return (JsonNullable<List<EntityPaymentRouteResponse>>) routing;
    }

    @JsonIgnore
    public SequenceTypeResponse sequenceType() {
        return sequenceType;
    }

    @JsonIgnore
    public Optional<String> subscriptionId() {
        return subscriptionId;
    }

    @JsonIgnore
    public Optional<String> mandateId() {
        return mandateId;
    }

    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted
     * in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId`
     * parameter is
     * required.
     */
    @JsonIgnore
    public String profileId() {
        return profileId;
    }

    @JsonIgnore
    public Optional<String> settlementId() {
        return settlementId;
    }

    @JsonIgnore
    public Optional<String> orderId() {
        return orderId;
    }

    /**
     * The payment's status. Refer to the [documentation regarding
     * statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    @JsonIgnore
    public PaymentStatus status() {
        return status;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for
     * point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<StatusReason> statusReason() {
        return (JsonNullable<StatusReason>) statusReason;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may
     * include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer
     * to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Details> details() {
        return (JsonNullable<Details>) details;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    @JsonIgnore
    public String createdAt() {
        return createdAt;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
     * the payment is
     * not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
     * payment can no
     * longer expire.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
     * payment did not
     * expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
     * did not fail
     * (yet).
     */
    @JsonIgnore
    public JsonNullable<String> failedAt() {
        return failedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonIgnore
    public PaymentResponseLinks links() {
        return links;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this
     * endpoint.
     */
    public PaymentResponse withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    public PaymentResponse withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    public PaymentResponse withMode(Mode mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement
     * when possible.
     * We truncate the description automatically according to the limits of the used payment method. The
     * description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in
     * your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum
     * being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them
     * to fit.
     */
    public PaymentResponse withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmount(Amount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountRefunded(Amount amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = Optional.ofNullable(amountRefunded);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountRefunded(Optional<? extends Amount> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountRemaining(Amount amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = Optional.ofNullable(amountRemaining);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountRemaining(Optional<? extends Amount> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountCaptured(Amount amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = Optional.ofNullable(amountCaptured);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountCaptured(Optional<? extends Amount> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountChargedBack(Amount amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = Optional.ofNullable(amountChargedBack);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withAmountChargedBack(Optional<? extends Amount> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withSettlementAmount(Amount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = Optional.ofNullable(settlementAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentResponse withSettlementAmount(Optional<? extends Amount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
     * can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
     * recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public PaymentResponse withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
     * can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
     * recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public PaymentResponse withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
     * this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
     * parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
     * handle
     * payment cancellations.
     */
    public PaymentResponse withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
     * this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
     * parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
     * handle
     * payment cancellations.
     */
    public PaymentResponse withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
     * your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
     * want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
     * delivered to your
     * local machine.
     */
    public PaymentResponse withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
     * your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
     * want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
     * delivered to your
     * local machine.
     */
    public PaymentResponse withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description
     * of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public PaymentResponse withLines(List<Lines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description
     * of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public PaymentResponse withLines(JsonNullable<? extends List<Lines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud
     * protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
     * `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public PaymentResponse withBillingAddress(PaymentResponseBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    /**
     * The customer's billing address details. We advise to provide these details to improve fraud
     * protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
     * `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public PaymentResponse withBillingAddress(Optional<? extends PaymentResponseBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    public PaymentResponse withShippingAddress(PaymentAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    public PaymentResponse withShippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used.
     */
    public PaymentResponse withLocale(LocaleResponse locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used.
     */
    public PaymentResponse withLocale(JsonNullable<? extends LocaleResponse> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
     * checkout. This
     * field is omitted if the country code was not detected.
     */
    public PaymentResponse withCountryCode(String countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = JsonNullable.of(countryCode);
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
     * checkout. This
     * field is omitted if the country code was not detected.
     */
    public PaymentResponse withCountryCode(JsonNullable<String> countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = countryCode;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
     * specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment
     * method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method
     * selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality
     * to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public PaymentResponse withMethod(MethodResponse method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
     * specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment
     * method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method
     * selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality
     * to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public PaymentResponse withMethod(JsonNullable<? extends MethodResponse> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
     * Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
     * country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country
     * are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public PaymentResponse withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
     * Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
     * country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country
     * are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public PaymentResponse withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    public PaymentResponse withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    public PaymentResponse withMetadata(JsonNullable<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a
     * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public PaymentResponse withCaptureMode(CaptureModeResponse captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a
     * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public PaymentResponse withCaptureMode(JsonNullable<? extends CaptureModeResponse> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
     * can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the
     * payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount
     * of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public PaymentResponse withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
     * can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the
     * payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount
     * of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public PaymentResponse withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
     * onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
     * authorized (yet).
     */
    public PaymentResponse withCaptureBefore(String captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = JsonNullable.of(captureBefore);
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
     * onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
     * authorized (yet).
     */
    public PaymentResponse withCaptureBefore(JsonNullable<String> captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = captureBefore;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
     * this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
     * balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected
     * merchant, refer to the
     * `routing` parameter.
     */
    public PaymentResponse withApplicationFee(ApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
     * this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
     * balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected
     * merchant, refer to the
     * `routing` parameter.
     */
    public PaymentResponse withApplicationFee(JsonNullable<? extends ApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish
     * to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more
     * connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the
     * destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
     * the total
     * payment amount have been routed, the amount left will be routed to the current organization
     * automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
     * `applicationFee`
     * parameter.
     */
    public PaymentResponse withRouting(List<EntityPaymentRouteResponse> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish
     * to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more
     * connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the
     * destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
     * the total
     * payment amount have been routed, the amount left will be routed to the current organization
     * automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
     * `applicationFee`
     * parameter.
     */
    public PaymentResponse withRouting(JsonNullable<? extends List<EntityPaymentRouteResponse>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    public PaymentResponse withSequenceType(SequenceTypeResponse sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    public PaymentResponse withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = Optional.ofNullable(subscriptionId);
        return this;
    }


    public PaymentResponse withSubscriptionId(Optional<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    public PaymentResponse withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = Optional.ofNullable(mandateId);
        return this;
    }


    public PaymentResponse withMandateId(Optional<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    public PaymentResponse withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }


    public PaymentResponse withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted
     * in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId`
     * parameter is
     * required.
     */
    public PaymentResponse withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    public PaymentResponse withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = Optional.ofNullable(settlementId);
        return this;
    }


    public PaymentResponse withSettlementId(Optional<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    public PaymentResponse withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = Optional.ofNullable(orderId);
        return this;
    }


    public PaymentResponse withOrderId(Optional<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding
     * statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    public PaymentResponse withStatus(PaymentStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for
     * point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    public PaymentResponse withStatusReason(StatusReason statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = JsonNullable.of(statusReason);
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for
     * point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    public PaymentResponse withStatusReason(JsonNullable<? extends StatusReason> statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = statusReason;
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public PaymentResponse withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public PaymentResponse withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may
     * include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer
     * to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    public PaymentResponse withDetails(Details details) {
        Utils.checkNotNull(details, "details");
        this.details = JsonNullable.of(details);
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may
     * include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer
     * to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    public PaymentResponse withDetails(JsonNullable<? extends Details> details) {
        Utils.checkNotNull(details, "details");
        this.details = details;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    public PaymentResponse withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
     * the payment is
     * not authorized (yet).
     */
    public PaymentResponse withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
     * the payment is
     * not authorized (yet).
     */
    public PaymentResponse withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * completed (yet).
     */
    public PaymentResponse withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * completed (yet).
     */
    public PaymentResponse withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * canceled (yet).
     */
    public PaymentResponse withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
     * payment is not
     * canceled (yet).
     */
    public PaymentResponse withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
     * payment can no
     * longer expire.
     */
    public PaymentResponse withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
     * payment can no
     * longer expire.
     */
    public PaymentResponse withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
     * payment did not
     * expire (yet).
     */
    public PaymentResponse withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
     * payment did not
     * expire (yet).
     */
    public PaymentResponse withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
     * did not fail
     * (yet).
     */
    public PaymentResponse withFailedAt(String failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = JsonNullable.of(failedAt);
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
     * did not fail
     * (yet).
     */
    public PaymentResponse withFailedAt(JsonNullable<String> failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = failedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public PaymentResponse withLinks(PaymentResponseLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PaymentResponse other = (PaymentResponse) o;
        return 
            Utils.enhancedDeepEquals(this.resource, other.resource) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.mode, other.mode) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.amountRefunded, other.amountRefunded) &&
            Utils.enhancedDeepEquals(this.amountRemaining, other.amountRemaining) &&
            Utils.enhancedDeepEquals(this.amountCaptured, other.amountCaptured) &&
            Utils.enhancedDeepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Utils.enhancedDeepEquals(this.settlementAmount, other.settlementAmount) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.countryCode, other.countryCode) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.captureMode, other.captureMode) &&
            Utils.enhancedDeepEquals(this.captureDelay, other.captureDelay) &&
            Utils.enhancedDeepEquals(this.captureBefore, other.captureBefore) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.routing, other.routing) &&
            Utils.enhancedDeepEquals(this.sequenceType, other.sequenceType) &&
            Utils.enhancedDeepEquals(this.subscriptionId, other.subscriptionId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.settlementId, other.settlementId) &&
            Utils.enhancedDeepEquals(this.orderId, other.orderId) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.statusReason, other.statusReason) &&
            Utils.enhancedDeepEquals(this.isCancelable, other.isCancelable) &&
            Utils.enhancedDeepEquals(this.details, other.details) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.authorizedAt, other.authorizedAt) &&
            Utils.enhancedDeepEquals(this.paidAt, other.paidAt) &&
            Utils.enhancedDeepEquals(this.canceledAt, other.canceledAt) &&
            Utils.enhancedDeepEquals(this.expiresAt, other.expiresAt) &&
            Utils.enhancedDeepEquals(this.expiredAt, other.expiredAt) &&
            Utils.enhancedDeepEquals(this.failedAt, other.failedAt) &&
            Utils.enhancedDeepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            resource, id, mode,
            description, amount, amountRefunded,
            amountRemaining, amountCaptured, amountChargedBack,
            settlementAmount, redirectUrl, cancelUrl,
            webhookUrl, lines, billingAddress,
            shippingAddress, locale, countryCode,
            method, restrictPaymentMethodsToCountry, metadata,
            captureMode, captureDelay, captureBefore,
            applicationFee, routing, sequenceType,
            subscriptionId, mandateId, customerId,
            profileId, settlementId, orderId,
            status, statusReason, isCancelable,
            details, createdAt, authorizedAt,
            paidAt, canceledAt, expiresAt,
            expiredAt, failedAt, links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PaymentResponse.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "countryCode", countryCode,
                "method", method,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "captureBefore", captureBefore,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "status", status,
                "statusReason", statusReason,
                "isCancelable", isCancelable,
                "details", details,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "failedAt", failedAt,
                "links", links);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String resource;

        private String id;

        private Mode mode;

        private String description;

        private Amount amount;

        private Optional<? extends Amount> amountRefunded = Optional.empty();

        private Optional<? extends Amount> amountRemaining = Optional.empty();

        private Optional<? extends Amount> amountCaptured = Optional.empty();

        private Optional<? extends Amount> amountChargedBack = Optional.empty();

        private Optional<? extends Amount> settlementAmount = Optional.empty();

        private JsonNullable<String> redirectUrl = JsonNullable.undefined();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends List<Lines>> lines = JsonNullable.undefined();

        private Optional<? extends PaymentResponseBillingAddress> billingAddress = Optional.empty();

        private Optional<? extends PaymentAddress> shippingAddress = Optional.empty();

        private JsonNullable<? extends LocaleResponse> locale = JsonNullable.undefined();

        private JsonNullable<String> countryCode = JsonNullable.undefined();

        private JsonNullable<? extends MethodResponse> method = JsonNullable.undefined();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<? extends Metadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends CaptureModeResponse> captureMode = JsonNullable.undefined();

        private JsonNullable<String> captureDelay = JsonNullable.undefined();

        private JsonNullable<String> captureBefore = JsonNullable.undefined();

        private JsonNullable<? extends ApplicationFee> applicationFee = JsonNullable.undefined();

        private JsonNullable<? extends List<EntityPaymentRouteResponse>> routing = JsonNullable.undefined();

        private SequenceTypeResponse sequenceType;

        private Optional<String> subscriptionId = Optional.empty();

        private Optional<String> mandateId = Optional.empty();

        private Optional<String> customerId = Optional.empty();

        private String profileId;

        private Optional<String> settlementId = Optional.empty();

        private Optional<String> orderId = Optional.empty();

        private PaymentStatus status;

        private JsonNullable<? extends StatusReason> statusReason = JsonNullable.undefined();

        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();

        private JsonNullable<? extends Details> details = JsonNullable.undefined();

        private String createdAt;

        private JsonNullable<String> authorizedAt = JsonNullable.undefined();

        private JsonNullable<String> paidAt = JsonNullable.undefined();

        private JsonNullable<String> canceledAt = JsonNullable.undefined();

        private JsonNullable<String> expiresAt = JsonNullable.undefined();

        private JsonNullable<String> expiredAt = JsonNullable.undefined();

        private JsonNullable<String> failedAt = JsonNullable.undefined();

        private PaymentResponseLinks links;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this
         * endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }


        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether this entity was created in live mode or in test mode.
         */
        public Builder mode(Mode mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement
         * when possible.
         * We truncate the description automatically according to the limits of the used payment method. The
         * description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in
         * your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum
         * being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them
         * to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amount(Amount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRefunded(Amount amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = Optional.ofNullable(amountRefunded);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRefunded(Optional<? extends Amount> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRemaining(Amount amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = Optional.ofNullable(amountRemaining);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRemaining(Optional<? extends Amount> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountCaptured(Amount amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = Optional.ofNullable(amountCaptured);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountCaptured(Optional<? extends Amount> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountChargedBack(Amount amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = Optional.ofNullable(amountChargedBack);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountChargedBack(Optional<? extends Amount> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder settlementAmount(Amount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = Optional.ofNullable(settlementAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder settlementAmount(Optional<? extends Amount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
         * can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
         * recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you
         * can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType:
         * recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
         * this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
         * parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
         * handle
         * payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If
         * this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This
         * parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to
         * handle
         * payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
         * your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
         * want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
         * delivered to your
         * local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to
         * your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you
         * want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks
         * delivered to your
         * local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description
         * of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<Lines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description
         * of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<Lines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        /**
         * The customer's billing address details. We advise to provide these details to improve fraud
         * protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
         * `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(PaymentResponseBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud
         * protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`,
         * `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends PaymentResponseBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        public Builder shippingAddress(PaymentAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        public Builder shippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(LocaleResponse locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(JsonNullable<? extends LocaleResponse> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
         * checkout. This
         * field is omitted if the country code was not detected.
         */
        public Builder countryCode(String countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = JsonNullable.of(countryCode);
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during
         * checkout. This
         * field is omitted if the country code was not detected.
         */
        public Builder countryCode(JsonNullable<String> countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = countryCode;
            return this;
        }


        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
         * specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment
         * method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method
         * selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality
         * to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(MethodResponse method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a
         * specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment
         * method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method
         * selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality
         * to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(JsonNullable<? extends MethodResponse> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
         * Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
         * country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country
         * are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country.
         * Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single
         * country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country
         * are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside
         * the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to
         * approximately 1kB.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside
         * the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to
         * approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Indicate if the funds should be captured immediately or if you want to [place a
         * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(CaptureModeResponse captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a
         * hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/)
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(JsonNullable<? extends CaptureModeResponse> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }


        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
         * can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the
         * payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount
         * of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization'
         * can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the
         * payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount
         * of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }


        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
         * onwards we
         * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
         * authorized (yet).
         */
        public Builder captureBefore(String captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = JsonNullable.of(captureBefore);
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date
         * onwards we
         * can no longer guarantee a successful capture. The parameter is omitted if the payment is not
         * authorized (yet).
         */
        public Builder captureBefore(JsonNullable<String> captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = captureBefore;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
         * this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
         * balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected
         * merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(ApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using
         * this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's
         * balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected
         * merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends ApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish
         * to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more
         * connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the
         * destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
         * the total
         * payment amount have been routed, the amount left will be routed to the current organization
         * automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
         * `applicationFee`
         * parameter.
         */
        public Builder routing(List<EntityPaymentRouteResponse> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish
         * to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more
         * connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the
         * destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of
         * the total
         * payment amount have been routed, the amount left will be routed to the current organization
         * automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the
         * `applicationFee`
         * parameter.
         */
        public Builder routing(JsonNullable<? extends List<EntityPaymentRouteResponse>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }


        public Builder sequenceType(SequenceTypeResponse sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }


        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = Optional.ofNullable(subscriptionId);
            return this;
        }

        public Builder subscriptionId(Optional<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }


        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = Optional.ofNullable(mandateId);
            return this;
        }

        public Builder mandateId(Optional<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted
         * in the creation
         * request. For organization-level credentials such as OAuth access tokens however, the `profileId`
         * parameter is
         * required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = Optional.ofNullable(settlementId);
            return this;
        }

        public Builder settlementId(Optional<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }


        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = Optional.ofNullable(orderId);
            return this;
        }

        public Builder orderId(Optional<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }


        /**
         * The payment's status. Refer to the [documentation regarding
         * statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
         * statuses occur at what point.
         */
        public Builder status(PaymentStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * This object offers details about the status of a payment. Currently it is only available for
         * point-of-sale
         * payments.
         * 
         * <p>You can find more information about the possible values of this object on
         * [this page](status-reasons).**
         */
        public Builder statusReason(StatusReason statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = JsonNullable.of(statusReason);
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for
         * point-of-sale
         * payments.
         * 
         * <p>You can find more information about the possible values of this object on
         * [this page](status-reasons).**
         */
        public Builder statusReason(JsonNullable<? extends StatusReason> statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = statusReason;
            return this;
        }


        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }


        /**
         * An object containing payment details collected during the payment process. For example, details may
         * include the
         * customer's card or bank details and a payment reference. For the full list of details, please refer
         * to the
         * [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(Details details) {
            Utils.checkNotNull(details, "details");
            this.details = JsonNullable.of(details);
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may
         * include the
         * customer's card or bank details and a payment reference. For the full list of details, please refer
         * to the
         * [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(JsonNullable<? extends Details> details) {
            Utils.checkNotNull(details, "details");
            this.details = details;
            return this;
        }


        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
         * format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
         * the payment is
         * not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if
         * the payment is
         * not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }


        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
         * payment is not
         * completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the
         * payment is not
         * completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }


        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
         * payment is not
         * canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the
         * payment is not
         * canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }


        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
         * payment can no
         * longer expire.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the
         * payment can no
         * longer expire.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }


        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
         * payment did not
         * expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the
         * payment did not
         * expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }


        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
         * did not fail
         * (yet).
         */
        public Builder failedAt(String failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = JsonNullable.of(failedAt);
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment
         * did not fail
         * (yet).
         */
        public Builder failedAt(JsonNullable<String> failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = failedAt;
            return this;
        }


        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(PaymentResponseLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }

        public PaymentResponse build() {

            return new PaymentResponse(
                resource, id, mode,
                description, amount, amountRefunded,
                amountRemaining, amountCaptured, amountChargedBack,
                settlementAmount, redirectUrl, cancelUrl,
                webhookUrl, lines, billingAddress,
                shippingAddress, locale, countryCode,
                method, restrictPaymentMethodsToCountry, metadata,
                captureMode, captureDelay, captureBefore,
                applicationFee, routing, sequenceType,
                subscriptionId, mandateId, customerId,
                profileId, settlementId, orderId,
                status, statusReason, isCancelable,
                details, createdAt, authorizedAt,
                paidAt, canceledAt, expiresAt,
                expiredAt, failedAt, links);
        }

    }
}
