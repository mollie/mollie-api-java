/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class PaymentRequest {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends Amount> amount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private Optional<? extends Amount> amountRefunded;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private Optional<? extends Amount> amountRemaining;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private Optional<? extends Amount> amountCaptured;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private Optional<? extends Amount> amountChargedBack;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private Optional<? extends Amount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<PaymentRequestLines>> lines;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends PaymentAddress> billingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends PaymentAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<? extends Locale> locale;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends Method> method;

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issuer")
    private JsonNullable<String> issuer;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Metadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<? extends CaptureMode> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends PaymentRequestApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<EntityPaymentRoute>> routing;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sequenceType")
    private Optional<? extends SequenceType> sequenceType;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private Optional<String> subscriptionId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private Optional<String> mandateId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private Optional<String> profileId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private Optional<String> settlementId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private Optional<String> orderId;

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dueDate")
    private Optional<String> dueDate;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applePayPaymentToken")
    private Optional<String> applePayPaymentToken;

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company")
    private Optional<? extends Company> company;

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cardToken")
    private Optional<String> cardToken;

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("voucherNumber")
    private Optional<String> voucherNumber;

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("voucherPin")
    private Optional<String> voucherPin;

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("consumerDateOfBirth")
    private Optional<LocalDate> consumerDateOfBirth;

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("extraMerchantData")
    private Optional<? extends Map<String, Object>> extraMerchantData;

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sessionId")
    private Optional<String> sessionId;

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("digitalGoods")
    private Optional<Boolean> digitalGoods;

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerReference")
    private Optional<String> customerReference;

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("terminalId")
    private Optional<String> terminalId;

    @JsonCreator
    public PaymentRequest(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("amount") Optional<? extends Amount> amount,
            @JsonProperty("amountRefunded") Optional<? extends Amount> amountRefunded,
            @JsonProperty("amountRemaining") Optional<? extends Amount> amountRemaining,
            @JsonProperty("amountCaptured") Optional<? extends Amount> amountCaptured,
            @JsonProperty("amountChargedBack") Optional<? extends Amount> amountChargedBack,
            @JsonProperty("settlementAmount") Optional<? extends Amount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<PaymentRequestLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends PaymentAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends PaymentAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<? extends Locale> locale,
            @JsonProperty("method") JsonNullable<? extends Method> method,
            @JsonProperty("issuer") JsonNullable<String> issuer,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends Metadata> metadata,
            @JsonProperty("captureMode") JsonNullable<? extends CaptureMode> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("applicationFee") JsonNullable<? extends PaymentRequestApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<EntityPaymentRoute>> routing,
            @JsonProperty("sequenceType") Optional<? extends SequenceType> sequenceType,
            @JsonProperty("subscriptionId") Optional<String> subscriptionId,
            @JsonProperty("mandateId") Optional<String> mandateId,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("profileId") Optional<String> profileId,
            @JsonProperty("settlementId") Optional<String> settlementId,
            @JsonProperty("orderId") Optional<String> orderId,
            @JsonProperty("dueDate") Optional<String> dueDate,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode,
            @JsonProperty("applePayPaymentToken") Optional<String> applePayPaymentToken,
            @JsonProperty("company") Optional<? extends Company> company,
            @JsonProperty("cardToken") Optional<String> cardToken,
            @JsonProperty("voucherNumber") Optional<String> voucherNumber,
            @JsonProperty("voucherPin") Optional<String> voucherPin,
            @JsonProperty("consumerDateOfBirth") Optional<LocalDate> consumerDateOfBirth,
            @JsonProperty("extraMerchantData") Optional<? extends Map<String, Object>> extraMerchantData,
            @JsonProperty("sessionId") Optional<String> sessionId,
            @JsonProperty("digitalGoods") Optional<Boolean> digitalGoods,
            @JsonProperty("customerReference") Optional<String> customerReference,
            @JsonProperty("terminalId") Optional<String> terminalId) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(issuer, "issuer");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(testmode, "testmode");
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        Utils.checkNotNull(company, "company");
        Utils.checkNotNull(cardToken, "cardToken");
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        Utils.checkNotNull(voucherPin, "voucherPin");
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        Utils.checkNotNull(sessionId, "sessionId");
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        Utils.checkNotNull(customerReference, "customerReference");
        Utils.checkNotNull(terminalId, "terminalId");
        this.id = id;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.method = method;
        this.issuer = issuer;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.dueDate = dueDate;
        this.testmode = testmode;
        this.applePayPaymentToken = applePayPaymentToken;
        this.company = company;
        this.cardToken = cardToken;
        this.voucherNumber = voucherNumber;
        this.voucherPin = voucherPin;
        this.consumerDateOfBirth = consumerDateOfBirth;
        this.extraMerchantData = extraMerchantData;
        this.sessionId = sessionId;
        this.digitalGoods = digitalGoods;
        this.customerReference = customerReference;
        this.terminalId = terminalId;
    }
    
    public PaymentRequest() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amount() {
        return (Optional<Amount>) amount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountRefunded() {
        return (Optional<Amount>) amountRefunded;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountRemaining() {
        return (Optional<Amount>) amountRemaining;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountCaptured() {
        return (Optional<Amount>) amountCaptured;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountChargedBack() {
        return (Optional<Amount>) amountChargedBack;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> settlementAmount() {
        return (Optional<Amount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<PaymentRequestLines>> lines() {
        return (JsonNullable<List<PaymentRequestLines>>) lines;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentAddress> billingAddress() {
        return (Optional<PaymentAddress>) billingAddress;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentAddress> shippingAddress() {
        return (Optional<PaymentAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Locale> locale() {
        return (JsonNullable<Locale>) locale;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Method> method() {
        return (JsonNullable<Method>) method;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonIgnore
    public JsonNullable<String> issuer() {
        return issuer;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Metadata> metadata() {
        return (JsonNullable<Metadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CaptureMode> captureMode() {
        return (JsonNullable<CaptureMode>) captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PaymentRequestApplicationFee> applicationFee() {
        return (JsonNullable<PaymentRequestApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<EntityPaymentRoute>> routing() {
        return (JsonNullable<List<EntityPaymentRoute>>) routing;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SequenceType> sequenceType() {
        return (Optional<SequenceType>) sequenceType;
    }

    @JsonIgnore
    public Optional<String> subscriptionId() {
        return subscriptionId;
    }

    @JsonIgnore
    public Optional<String> mandateId() {
        return mandateId;
    }

    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    @JsonIgnore
    public Optional<String> profileId() {
        return profileId;
    }

    @JsonIgnore
    public Optional<String> settlementId() {
        return settlementId;
    }

    @JsonIgnore
    public Optional<String> orderId() {
        return orderId;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonIgnore
    public Optional<String> dueDate() {
        return dueDate;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    @JsonIgnore
    public Optional<String> applePayPaymentToken() {
        return applePayPaymentToken;
    }

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Company> company() {
        return (Optional<Company>) company;
    }

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    @JsonIgnore
    public Optional<String> cardToken() {
        return cardToken;
    }

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    @JsonIgnore
    public Optional<String> voucherNumber() {
        return voucherNumber;
    }

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    @JsonIgnore
    public Optional<String> voucherPin() {
        return voucherPin;
    }

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    @JsonIgnore
    public Optional<LocalDate> consumerDateOfBirth() {
        return consumerDateOfBirth;
    }

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, Object>> extraMerchantData() {
        return (Optional<Map<String, Object>>) extraMerchantData;
    }

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    @JsonIgnore
    public Optional<String> sessionId() {
        return sessionId;
    }

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    @JsonIgnore
    public Optional<Boolean> digitalGoods() {
        return digitalGoods;
    }

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    @JsonIgnore
    public Optional<String> customerReference() {
        return customerReference;
    }

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    @JsonIgnore
    public Optional<String> terminalId() {
        return terminalId;
    }

    public static Builder builder() {
        return new Builder();
    }


    public PaymentRequest withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    public PaymentRequest withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public PaymentRequest withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }


    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public PaymentRequest withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmount(Amount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmount(Optional<? extends Amount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountRefunded(Amount amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = Optional.ofNullable(amountRefunded);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountRefunded(Optional<? extends Amount> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountRemaining(Amount amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = Optional.ofNullable(amountRemaining);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountRemaining(Optional<? extends Amount> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountCaptured(Amount amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = Optional.ofNullable(amountCaptured);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountCaptured(Optional<? extends Amount> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountChargedBack(Amount amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = Optional.ofNullable(amountChargedBack);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withAmountChargedBack(Optional<? extends Amount> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withSettlementAmount(Amount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = Optional.ofNullable(settlementAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public PaymentRequest withSettlementAmount(Optional<? extends Amount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public PaymentRequest withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public PaymentRequest withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public PaymentRequest withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public PaymentRequest withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public PaymentRequest withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public PaymentRequest withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public PaymentRequest withLines(List<PaymentRequestLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public PaymentRequest withLines(JsonNullable<? extends List<PaymentRequestLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    public PaymentRequest withBillingAddress(PaymentAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    public PaymentRequest withBillingAddress(Optional<? extends PaymentAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    public PaymentRequest withShippingAddress(PaymentAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    public PaymentRequest withShippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used.
     */
    public PaymentRequest withLocale(Locale locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used.
     */
    public PaymentRequest withLocale(JsonNullable<? extends Locale> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public PaymentRequest withMethod(Method method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public PaymentRequest withMethod(JsonNullable<? extends Method> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public PaymentRequest withIssuer(String issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = JsonNullable.of(issuer);
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public PaymentRequest withIssuer(JsonNullable<String> issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = issuer;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public PaymentRequest withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public PaymentRequest withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public PaymentRequest withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public PaymentRequest withMetadata(JsonNullable<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public PaymentRequest withCaptureMode(CaptureMode captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public PaymentRequest withCaptureMode(JsonNullable<? extends CaptureMode> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public PaymentRequest withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public PaymentRequest withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public PaymentRequest withApplicationFee(PaymentRequestApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public PaymentRequest withApplicationFee(JsonNullable<? extends PaymentRequestApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public PaymentRequest withRouting(List<EntityPaymentRoute> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public PaymentRequest withRouting(JsonNullable<? extends List<EntityPaymentRoute>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    public PaymentRequest withSequenceType(SequenceType sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = Optional.ofNullable(sequenceType);
        return this;
    }


    public PaymentRequest withSequenceType(Optional<? extends SequenceType> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    public PaymentRequest withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = Optional.ofNullable(subscriptionId);
        return this;
    }


    public PaymentRequest withSubscriptionId(Optional<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    public PaymentRequest withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = Optional.ofNullable(mandateId);
        return this;
    }


    public PaymentRequest withMandateId(Optional<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    public PaymentRequest withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }


    public PaymentRequest withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    public PaymentRequest withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = Optional.ofNullable(profileId);
        return this;
    }


    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    public PaymentRequest withProfileId(Optional<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    public PaymentRequest withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = Optional.ofNullable(settlementId);
        return this;
    }


    public PaymentRequest withSettlementId(Optional<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    public PaymentRequest withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = Optional.ofNullable(orderId);
        return this;
    }


    public PaymentRequest withOrderId(Optional<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public PaymentRequest withDueDate(String dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = Optional.ofNullable(dueDate);
        return this;
    }


    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public PaymentRequest withDueDate(Optional<String> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public PaymentRequest withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public PaymentRequest withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    public PaymentRequest withApplePayPaymentToken(String applePayPaymentToken) {
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        this.applePayPaymentToken = Optional.ofNullable(applePayPaymentToken);
        return this;
    }


    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    public PaymentRequest withApplePayPaymentToken(Optional<String> applePayPaymentToken) {
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        this.applePayPaymentToken = applePayPaymentToken;
        return this;
    }

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    public PaymentRequest withCompany(Company company) {
        Utils.checkNotNull(company, "company");
        this.company = Optional.ofNullable(company);
        return this;
    }


    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    public PaymentRequest withCompany(Optional<? extends Company> company) {
        Utils.checkNotNull(company, "company");
        this.company = company;
        return this;
    }

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    public PaymentRequest withCardToken(String cardToken) {
        Utils.checkNotNull(cardToken, "cardToken");
        this.cardToken = Optional.ofNullable(cardToken);
        return this;
    }


    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    public PaymentRequest withCardToken(Optional<String> cardToken) {
        Utils.checkNotNull(cardToken, "cardToken");
        this.cardToken = cardToken;
        return this;
    }

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    public PaymentRequest withVoucherNumber(String voucherNumber) {
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        this.voucherNumber = Optional.ofNullable(voucherNumber);
        return this;
    }


    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    public PaymentRequest withVoucherNumber(Optional<String> voucherNumber) {
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        this.voucherNumber = voucherNumber;
        return this;
    }

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    public PaymentRequest withVoucherPin(String voucherPin) {
        Utils.checkNotNull(voucherPin, "voucherPin");
        this.voucherPin = Optional.ofNullable(voucherPin);
        return this;
    }


    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    public PaymentRequest withVoucherPin(Optional<String> voucherPin) {
        Utils.checkNotNull(voucherPin, "voucherPin");
        this.voucherPin = voucherPin;
        return this;
    }

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    public PaymentRequest withConsumerDateOfBirth(LocalDate consumerDateOfBirth) {
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        this.consumerDateOfBirth = Optional.ofNullable(consumerDateOfBirth);
        return this;
    }


    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    public PaymentRequest withConsumerDateOfBirth(Optional<LocalDate> consumerDateOfBirth) {
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        this.consumerDateOfBirth = consumerDateOfBirth;
        return this;
    }

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    public PaymentRequest withExtraMerchantData(Map<String, Object> extraMerchantData) {
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        this.extraMerchantData = Optional.ofNullable(extraMerchantData);
        return this;
    }


    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    public PaymentRequest withExtraMerchantData(Optional<? extends Map<String, Object>> extraMerchantData) {
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        this.extraMerchantData = extraMerchantData;
        return this;
    }

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    public PaymentRequest withSessionId(String sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = Optional.ofNullable(sessionId);
        return this;
    }


    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    public PaymentRequest withSessionId(Optional<String> sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = sessionId;
        return this;
    }

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    public PaymentRequest withDigitalGoods(boolean digitalGoods) {
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        this.digitalGoods = Optional.ofNullable(digitalGoods);
        return this;
    }


    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    public PaymentRequest withDigitalGoods(Optional<Boolean> digitalGoods) {
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        this.digitalGoods = digitalGoods;
        return this;
    }

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    public PaymentRequest withCustomerReference(String customerReference) {
        Utils.checkNotNull(customerReference, "customerReference");
        this.customerReference = Optional.ofNullable(customerReference);
        return this;
    }


    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    public PaymentRequest withCustomerReference(Optional<String> customerReference) {
        Utils.checkNotNull(customerReference, "customerReference");
        this.customerReference = customerReference;
        return this;
    }

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    public PaymentRequest withTerminalId(String terminalId) {
        Utils.checkNotNull(terminalId, "terminalId");
        this.terminalId = Optional.ofNullable(terminalId);
        return this;
    }


    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    public PaymentRequest withTerminalId(Optional<String> terminalId) {
        Utils.checkNotNull(terminalId, "terminalId");
        this.terminalId = terminalId;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PaymentRequest other = (PaymentRequest) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.amountRefunded, other.amountRefunded) &&
            Utils.enhancedDeepEquals(this.amountRemaining, other.amountRemaining) &&
            Utils.enhancedDeepEquals(this.amountCaptured, other.amountCaptured) &&
            Utils.enhancedDeepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Utils.enhancedDeepEquals(this.settlementAmount, other.settlementAmount) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.issuer, other.issuer) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.captureMode, other.captureMode) &&
            Utils.enhancedDeepEquals(this.captureDelay, other.captureDelay) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.routing, other.routing) &&
            Utils.enhancedDeepEquals(this.sequenceType, other.sequenceType) &&
            Utils.enhancedDeepEquals(this.subscriptionId, other.subscriptionId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.settlementId, other.settlementId) &&
            Utils.enhancedDeepEquals(this.orderId, other.orderId) &&
            Utils.enhancedDeepEquals(this.dueDate, other.dueDate) &&
            Utils.enhancedDeepEquals(this.testmode, other.testmode) &&
            Utils.enhancedDeepEquals(this.applePayPaymentToken, other.applePayPaymentToken) &&
            Utils.enhancedDeepEquals(this.company, other.company) &&
            Utils.enhancedDeepEquals(this.cardToken, other.cardToken) &&
            Utils.enhancedDeepEquals(this.voucherNumber, other.voucherNumber) &&
            Utils.enhancedDeepEquals(this.voucherPin, other.voucherPin) &&
            Utils.enhancedDeepEquals(this.consumerDateOfBirth, other.consumerDateOfBirth) &&
            Utils.enhancedDeepEquals(this.extraMerchantData, other.extraMerchantData) &&
            Utils.enhancedDeepEquals(this.sessionId, other.sessionId) &&
            Utils.enhancedDeepEquals(this.digitalGoods, other.digitalGoods) &&
            Utils.enhancedDeepEquals(this.customerReference, other.customerReference) &&
            Utils.enhancedDeepEquals(this.terminalId, other.terminalId);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, description, amount,
            amountRefunded, amountRemaining, amountCaptured,
            amountChargedBack, settlementAmount, redirectUrl,
            cancelUrl, webhookUrl, lines,
            billingAddress, shippingAddress, locale,
            method, issuer, restrictPaymentMethodsToCountry,
            metadata, captureMode, captureDelay,
            applicationFee, routing, sequenceType,
            subscriptionId, mandateId, customerId,
            profileId, settlementId, orderId,
            dueDate, testmode, applePayPaymentToken,
            company, cardToken, voucherNumber,
            voucherPin, consumerDateOfBirth, extraMerchantData,
            sessionId, digitalGoods, customerReference,
            terminalId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PaymentRequest.class,
                "id", id,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "method", method,
                "issuer", issuer,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "dueDate", dueDate,
                "testmode", testmode,
                "applePayPaymentToken", applePayPaymentToken,
                "company", company,
                "cardToken", cardToken,
                "voucherNumber", voucherNumber,
                "voucherPin", voucherPin,
                "consumerDateOfBirth", consumerDateOfBirth,
                "extraMerchantData", extraMerchantData,
                "sessionId", sessionId,
                "digitalGoods", digitalGoods,
                "customerReference", customerReference,
                "terminalId", terminalId);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private Optional<String> description = Optional.empty();

        private Optional<? extends Amount> amount = Optional.empty();

        private Optional<? extends Amount> amountRefunded = Optional.empty();

        private Optional<? extends Amount> amountRemaining = Optional.empty();

        private Optional<? extends Amount> amountCaptured = Optional.empty();

        private Optional<? extends Amount> amountChargedBack = Optional.empty();

        private Optional<? extends Amount> settlementAmount = Optional.empty();

        private JsonNullable<String> redirectUrl = JsonNullable.undefined();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends List<PaymentRequestLines>> lines = JsonNullable.undefined();

        private Optional<? extends PaymentAddress> billingAddress = Optional.empty();

        private Optional<? extends PaymentAddress> shippingAddress = Optional.empty();

        private JsonNullable<? extends Locale> locale = JsonNullable.undefined();

        private JsonNullable<? extends Method> method = JsonNullable.undefined();

        private JsonNullable<String> issuer = JsonNullable.undefined();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<? extends Metadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends CaptureMode> captureMode = JsonNullable.undefined();

        private JsonNullable<String> captureDelay = JsonNullable.undefined();

        private JsonNullable<? extends PaymentRequestApplicationFee> applicationFee = JsonNullable.undefined();

        private JsonNullable<? extends List<EntityPaymentRoute>> routing = JsonNullable.undefined();

        private Optional<? extends SequenceType> sequenceType = Optional.empty();

        private Optional<String> subscriptionId = Optional.empty();

        private Optional<String> mandateId = Optional.empty();

        private Optional<String> customerId = Optional.empty();

        private Optional<String> profileId = Optional.empty();

        private Optional<String> settlementId = Optional.empty();

        private Optional<String> orderId = Optional.empty();

        private Optional<String> dueDate = Optional.empty();

        private JsonNullable<Boolean> testmode = JsonNullable.undefined();

        private Optional<String> applePayPaymentToken = Optional.empty();

        private Optional<? extends Company> company = Optional.empty();

        private Optional<String> cardToken = Optional.empty();

        private Optional<String> voucherNumber = Optional.empty();

        private Optional<String> voucherPin = Optional.empty();

        private Optional<LocalDate> consumerDateOfBirth = Optional.empty();

        private Optional<? extends Map<String, Object>> extraMerchantData = Optional.empty();

        private Optional<String> sessionId = Optional.empty();

        private Optional<Boolean> digitalGoods = Optional.empty();

        private Optional<String> customerReference = Optional.empty();

        private Optional<String> terminalId = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amount(Amount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amount(Optional<? extends Amount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRefunded(Amount amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = Optional.ofNullable(amountRefunded);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRefunded(Optional<? extends Amount> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRemaining(Amount amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = Optional.ofNullable(amountRemaining);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountRemaining(Optional<? extends Amount> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountCaptured(Amount amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = Optional.ofNullable(amountCaptured);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountCaptured(Optional<? extends Amount> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountChargedBack(Amount amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = Optional.ofNullable(amountChargedBack);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountChargedBack(Optional<? extends Amount> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder settlementAmount(Amount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = Optional.ofNullable(settlementAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder settlementAmount(Optional<? extends Amount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<PaymentRequestLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<PaymentRequestLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        public Builder billingAddress(PaymentAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        public Builder billingAddress(Optional<? extends PaymentAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        public Builder shippingAddress(PaymentAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        public Builder shippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(Locale locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(JsonNullable<? extends Locale> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(Method method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(JsonNullable<? extends Method> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(String issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = JsonNullable.of(issuer);
            return this;
        }

        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(JsonNullable<String> issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = issuer;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(CaptureMode captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(JsonNullable<? extends CaptureMode> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }


        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(PaymentRequestApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends PaymentRequestApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(List<EntityPaymentRoute> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(JsonNullable<? extends List<EntityPaymentRoute>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }


        public Builder sequenceType(SequenceType sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = Optional.ofNullable(sequenceType);
            return this;
        }

        public Builder sequenceType(Optional<? extends SequenceType> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }


        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = Optional.ofNullable(subscriptionId);
            return this;
        }

        public Builder subscriptionId(Optional<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }


        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = Optional.ofNullable(mandateId);
            return this;
        }

        public Builder mandateId(Optional<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
         * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
         * required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = Optional.ofNullable(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
         * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
         * required.
         */
        public Builder profileId(Optional<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = Optional.ofNullable(settlementId);
            return this;
        }

        public Builder settlementId(Optional<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }


        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = Optional.ofNullable(orderId);
            return this;
        }

        public Builder orderId(Optional<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }


        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(String dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = Optional.ofNullable(dueDate);
            return this;
        }

        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(Optional<String> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }


        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }


        /**
         * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
         * The token contains the payment information needed to authorize the payment.
         * 
         * <p>The object should be passed encoded in a JSON string.
         */
        public Builder applePayPaymentToken(String applePayPaymentToken) {
            Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
            this.applePayPaymentToken = Optional.ofNullable(applePayPaymentToken);
            return this;
        }

        /**
         * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
         * The token contains the payment information needed to authorize the payment.
         * 
         * <p>The object should be passed encoded in a JSON string.
         */
        public Builder applePayPaymentToken(Optional<String> applePayPaymentToken) {
            Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
            this.applePayPaymentToken = applePayPaymentToken;
            return this;
        }


        /**
         * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
         * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
         * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
         */
        public Builder company(Company company) {
            Utils.checkNotNull(company, "company");
            this.company = Optional.ofNullable(company);
            return this;
        }

        /**
         * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
         * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
         * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
         */
        public Builder company(Optional<? extends Company> company) {
            Utils.checkNotNull(company, "company");
            this.company = company;
            return this;
        }


        /**
         * When creating credit card payments using Mollie Components, you need to provide the card token you received from
         * the card component in this field. The token represents the customer's card information needed to complete the
         * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
         * enough.
         */
        public Builder cardToken(String cardToken) {
            Utils.checkNotNull(cardToken, "cardToken");
            this.cardToken = Optional.ofNullable(cardToken);
            return this;
        }

        /**
         * When creating credit card payments using Mollie Components, you need to provide the card token you received from
         * the card component in this field. The token represents the customer's card information needed to complete the
         * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
         * enough.
         */
        public Builder cardToken(Optional<String> cardToken) {
            Utils.checkNotNull(cardToken, "cardToken");
            this.cardToken = cardToken;
            return this;
        }


        /**
         * The card token you received from the card component of Mollie Components. The token represents the customer's card
         * information needed to complete the payment.
         */
        public Builder voucherNumber(String voucherNumber) {
            Utils.checkNotNull(voucherNumber, "voucherNumber");
            this.voucherNumber = Optional.ofNullable(voucherNumber);
            return this;
        }

        /**
         * The card token you received from the card component of Mollie Components. The token represents the customer's card
         * information needed to complete the payment.
         */
        public Builder voucherNumber(Optional<String> voucherNumber) {
            Utils.checkNotNull(voucherNumber, "voucherNumber");
            this.voucherNumber = voucherNumber;
            return this;
        }


        /**
         * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
         */
        public Builder voucherPin(String voucherPin) {
            Utils.checkNotNull(voucherPin, "voucherPin");
            this.voucherPin = Optional.ofNullable(voucherPin);
            return this;
        }

        /**
         * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
         */
        public Builder voucherPin(Optional<String> voucherPin) {
            Utils.checkNotNull(voucherPin, "voucherPin");
            this.voucherPin = voucherPin;
            return this;
        }


        /**
         * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
         * the payment process.
         */
        public Builder consumerDateOfBirth(LocalDate consumerDateOfBirth) {
            Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
            this.consumerDateOfBirth = Optional.ofNullable(consumerDateOfBirth);
            return this;
        }

        /**
         * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
         * the payment process.
         */
        public Builder consumerDateOfBirth(Optional<LocalDate> consumerDateOfBirth) {
            Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
            this.consumerDateOfBirth = consumerDateOfBirth;
            return this;
        }


        /**
         * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
         * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
         * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
         */
        public Builder extraMerchantData(Map<String, Object> extraMerchantData) {
            Utils.checkNotNull(extraMerchantData, "extraMerchantData");
            this.extraMerchantData = Optional.ofNullable(extraMerchantData);
            return this;
        }

        /**
         * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
         * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
         * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
         */
        public Builder extraMerchantData(Optional<? extends Map<String, Object>> extraMerchantData) {
            Utils.checkNotNull(extraMerchantData, "extraMerchantData");
            this.extraMerchantData = extraMerchantData;
            return this;
        }


        /**
         * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
         * on-demand payment.
         */
        public Builder sessionId(String sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = Optional.ofNullable(sessionId);
            return this;
        }

        /**
         * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
         * on-demand payment.
         */
        public Builder sessionId(Optional<String> sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = sessionId;
            return this;
        }


        /**
         * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
         * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
         */
        public Builder digitalGoods(boolean digitalGoods) {
            Utils.checkNotNull(digitalGoods, "digitalGoods");
            this.digitalGoods = Optional.ofNullable(digitalGoods);
            return this;
        }

        /**
         * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
         * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
         */
        public Builder digitalGoods(Optional<Boolean> digitalGoods) {
            Utils.checkNotNull(digitalGoods, "digitalGoods");
            this.digitalGoods = digitalGoods;
            return this;
        }


        /**
         * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
         * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
         */
        public Builder customerReference(String customerReference) {
            Utils.checkNotNull(customerReference, "customerReference");
            this.customerReference = Optional.ofNullable(customerReference);
            return this;
        }

        /**
         * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
         * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
         */
        public Builder customerReference(Optional<String> customerReference) {
            Utils.checkNotNull(customerReference, "customerReference");
            this.customerReference = customerReference;
            return this;
        }


        /**
         * The ID of the terminal device where you want to initiate the payment on.
         */
        public Builder terminalId(String terminalId) {
            Utils.checkNotNull(terminalId, "terminalId");
            this.terminalId = Optional.ofNullable(terminalId);
            return this;
        }

        /**
         * The ID of the terminal device where you want to initiate the payment on.
         */
        public Builder terminalId(Optional<String> terminalId) {
            Utils.checkNotNull(terminalId, "terminalId");
            this.terminalId = terminalId;
            return this;
        }

        public PaymentRequest build() {

            return new PaymentRequest(
                id, description, amount,
                amountRefunded, amountRemaining, amountCaptured,
                amountChargedBack, settlementAmount, redirectUrl,
                cancelUrl, webhookUrl, lines,
                billingAddress, shippingAddress, locale,
                method, issuer, restrictPaymentMethodsToCountry,
                metadata, captureMode, captureDelay,
                applicationFee, routing, sequenceType,
                subscriptionId, mandateId, customerId,
                profileId, settlementId, orderId,
                dueDate, testmode, applePayPaymentToken,
                company, cardToken, voucherNumber,
                voucherPin, consumerDateOfBirth, extraMerchantData,
                sessionId, digitalGoods, customerReference,
                terminalId);
        }

    }
}
