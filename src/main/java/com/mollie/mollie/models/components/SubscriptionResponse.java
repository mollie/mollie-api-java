/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class SubscriptionResponse {
    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription`
     * for this
     * endpoint.
     */
    @JsonProperty("resource")
    private String resource;

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonProperty("id")
    private String id;

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonProperty("mode")
    private Mode mode;


    @JsonProperty("status")
    private SubscriptionResponseStatus status;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonProperty("amount")
    private Amount amount;

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the
     * subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("times")
    private Optional<Long> times;

    /**
     * Number of payments left for the subscription.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("timesRemaining")
    private Optional<Long> timesRemaining;

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days`, `... weeks`, `...
     * 
     * <p>months`.
     */
    @JsonProperty("interval")
    private String interval;

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonProperty("startDate")
    private String startDate;

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
     * completed or canceled,
     * this parameter will not be returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nextPaymentDate")
    private JsonNullable<String> nextPaymentDate;

    /**
     * The subscription's description will be used as the description of the resulting individual payments
     * and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active
     * subscriptions.
     */
    @JsonProperty("description")
    private String description;

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
     * be used.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("method")
    private Optional<? extends SubscriptionMethodResponse> method;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
     * payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
     * more
     * information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private Optional<? extends SubscriptionResponseApplicationFee> applicationFee;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("metadata")
    private Optional<? extends Metadata> metadata;

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment
     * failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonProperty("webhookUrl")
    private String webhookUrl;

    /**
     * The customer this subscription belongs to.
     */
    @JsonProperty("customerId")
    private String customerId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private Optional<String> mandateId;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    @JsonProperty("createdAt")
    private String createdAt;

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
     * the
     * subscription is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonProperty("_links")
    private SubscriptionResponseLinks links;

    @JsonCreator
    public SubscriptionResponse(
            @JsonProperty("resource") String resource,
            @JsonProperty("id") String id,
            @JsonProperty("mode") Mode mode,
            @JsonProperty("status") SubscriptionResponseStatus status,
            @JsonProperty("amount") Amount amount,
            @JsonProperty("times") Optional<Long> times,
            @JsonProperty("timesRemaining") Optional<Long> timesRemaining,
            @JsonProperty("interval") String interval,
            @JsonProperty("startDate") String startDate,
            @JsonProperty("nextPaymentDate") JsonNullable<String> nextPaymentDate,
            @JsonProperty("description") String description,
            @JsonProperty("method") Optional<? extends SubscriptionMethodResponse> method,
            @JsonProperty("applicationFee") Optional<? extends SubscriptionResponseApplicationFee> applicationFee,
            @JsonProperty("metadata") Optional<? extends Metadata> metadata,
            @JsonProperty("webhookUrl") String webhookUrl,
            @JsonProperty("customerId") String customerId,
            @JsonProperty("mandateId") Optional<String> mandateId,
            @JsonProperty("createdAt") String createdAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("_links") SubscriptionResponseLinks links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(times, "times");
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.status = status;
        this.amount = amount;
        this.times = times;
        this.timesRemaining = timesRemaining;
        this.interval = interval;
        this.startDate = startDate;
        this.nextPaymentDate = nextPaymentDate;
        this.description = description;
        this.method = method;
        this.applicationFee = applicationFee;
        this.metadata = metadata;
        this.webhookUrl = webhookUrl;
        this.customerId = customerId;
        this.mandateId = mandateId;
        this.createdAt = createdAt;
        this.canceledAt = canceledAt;
        this.links = links;
    }
    
    public SubscriptionResponse(
            String resource,
            String id,
            Mode mode,
            SubscriptionResponseStatus status,
            Amount amount,
            String interval,
            String startDate,
            String description,
            String webhookUrl,
            String customerId,
            String createdAt,
            SubscriptionResponseLinks links) {
        this(resource, id, mode,
            status, amount, Optional.empty(),
            Optional.empty(), interval, startDate,
            JsonNullable.undefined(), description, Optional.empty(),
            Optional.empty(), Optional.empty(), webhookUrl,
            customerId, Optional.empty(), createdAt,
            JsonNullable.undefined(), links);
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription`
     * for this
     * endpoint.
     */
    @JsonIgnore
    public String resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonIgnore
    public Mode mode() {
        return mode;
    }

    @JsonIgnore
    public SubscriptionResponseStatus status() {
        return status;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonIgnore
    public Amount amount() {
        return amount;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the
     * subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonIgnore
    public Optional<Long> times() {
        return times;
    }

    /**
     * Number of payments left for the subscription.
     */
    @JsonIgnore
    public Optional<Long> timesRemaining() {
        return timesRemaining;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days`, `... weeks`, `...
     * 
     * <p>months`.
     */
    @JsonIgnore
    public String interval() {
        return interval;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonIgnore
    public String startDate() {
        return startDate;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
     * completed or canceled,
     * this parameter will not be returned.
     */
    @JsonIgnore
    public JsonNullable<String> nextPaymentDate() {
        return nextPaymentDate;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments
     * and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active
     * subscriptions.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
     * be used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubscriptionMethodResponse> method() {
        return (Optional<SubscriptionMethodResponse>) method;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
     * payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
     * more
     * information.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubscriptionResponseApplicationFee> applicationFee() {
        return (Optional<SubscriptionResponseApplicationFee>) applicationFee;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Metadata> metadata() {
        return (Optional<Metadata>) metadata;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment
     * failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonIgnore
    public String webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer this subscription belongs to.
     */
    @JsonIgnore
    public String customerId() {
        return customerId;
    }

    @JsonIgnore
    public Optional<String> mandateId() {
        return mandateId;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    @JsonIgnore
    public String createdAt() {
        return createdAt;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
     * the
     * subscription is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonIgnore
    public SubscriptionResponseLinks links() {
        return links;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription`
     * for this
     * endpoint.
     */
    public SubscriptionResponse withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public SubscriptionResponse withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    public SubscriptionResponse withMode(Mode mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    public SubscriptionResponse withStatus(SubscriptionResponseStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public SubscriptionResponse withAmount(Amount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the
     * subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public SubscriptionResponse withTimes(long times) {
        Utils.checkNotNull(times, "times");
        this.times = Optional.ofNullable(times);
        return this;
    }


    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the
     * subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public SubscriptionResponse withTimes(Optional<Long> times) {
        Utils.checkNotNull(times, "times");
        this.times = times;
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public SubscriptionResponse withTimesRemaining(long timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = Optional.ofNullable(timesRemaining);
        return this;
    }


    /**
     * Number of payments left for the subscription.
     */
    public SubscriptionResponse withTimesRemaining(Optional<Long> timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = timesRemaining;
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days`, `... weeks`, `...
     * 
     * <p>months`.
     */
    public SubscriptionResponse withInterval(String interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public SubscriptionResponse withStartDate(String startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
     * completed or canceled,
     * this parameter will not be returned.
     */
    public SubscriptionResponse withNextPaymentDate(String nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
     * completed or canceled,
     * this parameter will not be returned.
     */
    public SubscriptionResponse withNextPaymentDate(JsonNullable<String> nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = nextPaymentDate;
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments
     * and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active
     * subscriptions.
     */
    public SubscriptionResponse withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
     * be used.
     */
    public SubscriptionResponse withMethod(SubscriptionMethodResponse method) {
        Utils.checkNotNull(method, "method");
        this.method = Optional.ofNullable(method);
        return this;
    }


    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
     * be used.
     */
    public SubscriptionResponse withMethod(Optional<? extends SubscriptionMethodResponse> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
     * payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
     * more
     * information.
     */
    public SubscriptionResponse withApplicationFee(SubscriptionResponseApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = Optional.ofNullable(applicationFee);
        return this;
    }


    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
     * Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
     * payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
     * more
     * information.
     */
    public SubscriptionResponse withApplicationFee(Optional<? extends SubscriptionResponseApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    public SubscriptionResponse withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }


    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside
     * the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to
     * approximately 1kB.
     */
    public SubscriptionResponse withMetadata(Optional<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment
     * failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    public SubscriptionResponse withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public SubscriptionResponse withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    public SubscriptionResponse withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = Optional.ofNullable(mandateId);
        return this;
    }


    public SubscriptionResponse withMandateId(Optional<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
     * format.
     */
    public SubscriptionResponse withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
     * the
     * subscription is not canceled (yet).
     */
    public SubscriptionResponse withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
     * the
     * subscription is not canceled (yet).
     */
    public SubscriptionResponse withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public SubscriptionResponse withLinks(SubscriptionResponseLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SubscriptionResponse other = (SubscriptionResponse) o;
        return 
            Utils.enhancedDeepEquals(this.resource, other.resource) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.mode, other.mode) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.times, other.times) &&
            Utils.enhancedDeepEquals(this.timesRemaining, other.timesRemaining) &&
            Utils.enhancedDeepEquals(this.interval, other.interval) &&
            Utils.enhancedDeepEquals(this.startDate, other.startDate) &&
            Utils.enhancedDeepEquals(this.nextPaymentDate, other.nextPaymentDate) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.canceledAt, other.canceledAt) &&
            Utils.enhancedDeepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            resource, id, mode,
            status, amount, times,
            timesRemaining, interval, startDate,
            nextPaymentDate, description, method,
            applicationFee, metadata, webhookUrl,
            customerId, mandateId, createdAt,
            canceledAt, links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SubscriptionResponse.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "status", status,
                "amount", amount,
                "times", times,
                "timesRemaining", timesRemaining,
                "interval", interval,
                "startDate", startDate,
                "nextPaymentDate", nextPaymentDate,
                "description", description,
                "method", method,
                "applicationFee", applicationFee,
                "metadata", metadata,
                "webhookUrl", webhookUrl,
                "customerId", customerId,
                "mandateId", mandateId,
                "createdAt", createdAt,
                "canceledAt", canceledAt,
                "links", links);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String resource;

        private String id;

        private Mode mode;

        private SubscriptionResponseStatus status;

        private Amount amount;

        private Optional<Long> times = Optional.empty();

        private Optional<Long> timesRemaining = Optional.empty();

        private String interval;

        private String startDate;

        private JsonNullable<String> nextPaymentDate = JsonNullable.undefined();

        private String description;

        private Optional<? extends SubscriptionMethodResponse> method = Optional.empty();

        private Optional<? extends SubscriptionResponseApplicationFee> applicationFee = Optional.empty();

        private Optional<? extends Metadata> metadata = Optional.empty();

        private String webhookUrl;

        private String customerId;

        private Optional<String> mandateId = Optional.empty();

        private String createdAt;

        private JsonNullable<String> canceledAt = JsonNullable.undefined();

        private SubscriptionResponseLinks links;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription`
         * for this
         * endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }


        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether this entity was created in live mode or in test mode.
         */
        public Builder mode(Mode mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }


        public Builder status(SubscriptionResponseStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amount(Amount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the
         * subscription is
         * considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(long times) {
            Utils.checkNotNull(times, "times");
            this.times = Optional.ofNullable(times);
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the
         * subscription is
         * considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(Optional<Long> times) {
            Utils.checkNotNull(times, "times");
            this.times = times;
            return this;
        }


        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(long timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = Optional.ofNullable(timesRemaining);
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(Optional<Long> timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = timesRemaining;
            return this;
        }


        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         * 
         * <p>Possible values: `... days`, `... weeks`, `...
         * 
         * <p>months`.
         */
        public Builder interval(String interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }


        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(String startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }


        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
         * completed or canceled,
         * this parameter will not be returned.
         */
        public Builder nextPaymentDate(String nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been
         * completed or canceled,
         * this parameter will not be returned.
         */
        public Builder nextPaymentDate(JsonNullable<String> nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = nextPaymentDate;
            return this;
        }


        /**
         * The subscription's description will be used as the description of the resulting individual payments
         * and so showing
         * up on the bank statement of the consumer.
         * 
         * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active
         * subscriptions.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
         * be used.
         */
        public Builder method(SubscriptionMethodResponse method) {
            Utils.checkNotNull(method, "method");
            this.method = Optional.ofNullable(method);
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may
         * be used.
         */
        public Builder method(Optional<? extends SubscriptionMethodResponse> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
         * payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
         * more
         * information.
         */
        public Builder applicationFee(SubscriptionResponseApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = Optional.ofNullable(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other
         * Mollie
         * merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual
         * payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for
         * more
         * information.
         */
        public Builder applicationFee(Optional<? extends SubscriptionResponseApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside
         * the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to
         * approximately 1kB.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside
         * the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to
         * approximately 1kB.
         */
        public Builder metadata(Optional<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * <p>This webhook will receive **all** events for the subscription's payments. This may include payment
         * failures as
         * well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = Optional.ofNullable(mandateId);
            return this;
        }

        public Builder mandateId(Optional<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
         * format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
         * the
         * subscription is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if
         * the
         * subscription is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }


        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(SubscriptionResponseLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }

        public SubscriptionResponse build() {

            return new SubscriptionResponse(
                resource, id, mode,
                status, amount, times,
                timesRemaining, interval, startDate,
                nextPaymentDate, description, method,
                applicationFee, metadata, webhookUrl,
                customerId, mandateId, createdAt,
                canceledAt, links);
        }

    }
}
