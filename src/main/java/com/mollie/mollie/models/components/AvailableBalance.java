/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;

/**
 * AvailableBalance
 * 
 * <p>The available balance. Only available if grouping is `status-balances`.
 */
public class AvailableBalance {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("open")
    private Optional<? extends SubGroup> open;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("movedFromPending")
    private Optional<? extends SubGroup> movedFromPending;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("immediatelyAvailable")
    private Optional<? extends SubGroup> immediatelyAvailable;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("close")
    private Optional<? extends SubGroup> close;

    @JsonCreator
    public AvailableBalance(
            @JsonProperty("open") Optional<? extends SubGroup> open,
            @JsonProperty("movedFromPending") Optional<? extends SubGroup> movedFromPending,
            @JsonProperty("immediatelyAvailable") Optional<? extends SubGroup> immediatelyAvailable,
            @JsonProperty("close") Optional<? extends SubGroup> close) {
        Utils.checkNotNull(open, "open");
        Utils.checkNotNull(movedFromPending, "movedFromPending");
        Utils.checkNotNull(immediatelyAvailable, "immediatelyAvailable");
        Utils.checkNotNull(close, "close");
        this.open = open;
        this.movedFromPending = movedFromPending;
        this.immediatelyAvailable = immediatelyAvailable;
        this.close = close;
    }
    
    public AvailableBalance() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubGroup> open() {
        return (Optional<SubGroup>) open;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubGroup> movedFromPending() {
        return (Optional<SubGroup>) movedFromPending;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubGroup> immediatelyAvailable() {
        return (Optional<SubGroup>) immediatelyAvailable;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SubGroup> close() {
        return (Optional<SubGroup>) close;
    }

    public static Builder builder() {
        return new Builder();
    }


    public AvailableBalance withOpen(SubGroup open) {
        Utils.checkNotNull(open, "open");
        this.open = Optional.ofNullable(open);
        return this;
    }


    public AvailableBalance withOpen(Optional<? extends SubGroup> open) {
        Utils.checkNotNull(open, "open");
        this.open = open;
        return this;
    }

    public AvailableBalance withMovedFromPending(SubGroup movedFromPending) {
        Utils.checkNotNull(movedFromPending, "movedFromPending");
        this.movedFromPending = Optional.ofNullable(movedFromPending);
        return this;
    }


    public AvailableBalance withMovedFromPending(Optional<? extends SubGroup> movedFromPending) {
        Utils.checkNotNull(movedFromPending, "movedFromPending");
        this.movedFromPending = movedFromPending;
        return this;
    }

    public AvailableBalance withImmediatelyAvailable(SubGroup immediatelyAvailable) {
        Utils.checkNotNull(immediatelyAvailable, "immediatelyAvailable");
        this.immediatelyAvailable = Optional.ofNullable(immediatelyAvailable);
        return this;
    }


    public AvailableBalance withImmediatelyAvailable(Optional<? extends SubGroup> immediatelyAvailable) {
        Utils.checkNotNull(immediatelyAvailable, "immediatelyAvailable");
        this.immediatelyAvailable = immediatelyAvailable;
        return this;
    }

    public AvailableBalance withClose(SubGroup close) {
        Utils.checkNotNull(close, "close");
        this.close = Optional.ofNullable(close);
        return this;
    }


    public AvailableBalance withClose(Optional<? extends SubGroup> close) {
        Utils.checkNotNull(close, "close");
        this.close = close;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AvailableBalance other = (AvailableBalance) o;
        return 
            Utils.enhancedDeepEquals(this.open, other.open) &&
            Utils.enhancedDeepEquals(this.movedFromPending, other.movedFromPending) &&
            Utils.enhancedDeepEquals(this.immediatelyAvailable, other.immediatelyAvailable) &&
            Utils.enhancedDeepEquals(this.close, other.close);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            open, movedFromPending, immediatelyAvailable,
            close);
    }
    
    @Override
    public String toString() {
        return Utils.toString(AvailableBalance.class,
                "open", open,
                "movedFromPending", movedFromPending,
                "immediatelyAvailable", immediatelyAvailable,
                "close", close);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends SubGroup> open = Optional.empty();

        private Optional<? extends SubGroup> movedFromPending = Optional.empty();

        private Optional<? extends SubGroup> immediatelyAvailable = Optional.empty();

        private Optional<? extends SubGroup> close = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder open(SubGroup open) {
            Utils.checkNotNull(open, "open");
            this.open = Optional.ofNullable(open);
            return this;
        }

        public Builder open(Optional<? extends SubGroup> open) {
            Utils.checkNotNull(open, "open");
            this.open = open;
            return this;
        }


        public Builder movedFromPending(SubGroup movedFromPending) {
            Utils.checkNotNull(movedFromPending, "movedFromPending");
            this.movedFromPending = Optional.ofNullable(movedFromPending);
            return this;
        }

        public Builder movedFromPending(Optional<? extends SubGroup> movedFromPending) {
            Utils.checkNotNull(movedFromPending, "movedFromPending");
            this.movedFromPending = movedFromPending;
            return this;
        }


        public Builder immediatelyAvailable(SubGroup immediatelyAvailable) {
            Utils.checkNotNull(immediatelyAvailable, "immediatelyAvailable");
            this.immediatelyAvailable = Optional.ofNullable(immediatelyAvailable);
            return this;
        }

        public Builder immediatelyAvailable(Optional<? extends SubGroup> immediatelyAvailable) {
            Utils.checkNotNull(immediatelyAvailable, "immediatelyAvailable");
            this.immediatelyAvailable = immediatelyAvailable;
            return this;
        }


        public Builder close(SubGroup close) {
            Utils.checkNotNull(close, "close");
            this.close = Optional.ofNullable(close);
            return this;
        }

        public Builder close(Optional<? extends SubGroup> close) {
            Utils.checkNotNull(close, "close");
            this.close = close;
            return this;
        }

        public AvailableBalance build() {

            return new AvailableBalance(
                open, movedFromPending, immediatelyAvailable,
                close);
        }

    }
}
