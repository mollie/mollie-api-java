/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class EntitySalesInvoice {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private JsonNullable<String> profileId;

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     *   - `paymentDetails` is required if invoice should be set directly to `paid`
     *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
     *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends SalesInvoiceStatus> status;

    /**
     * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("vatScheme")
    private Optional<? extends SalesInvoiceVatScheme> vatScheme;

    /**
     * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
     * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("vatMode")
    private Optional<? extends SalesInvoiceVatMode> vatMode;

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;

    /**
     * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends EntitySalesInvoiceMetadata> metadata;

    /**
     * The payment term to be set on the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paymentTerm")
    private JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paymentDetails")
    private JsonNullable<? extends SalesInvoicePaymentDetails> paymentDetails;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("emailDetails")
    private JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails;

    /**
     * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
     * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
     * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private Optional<String> mandateId;

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
     * is not required to send a first invoice to a recipient.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipientIdentifier")
    private Optional<String> recipientIdentifier;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipient")
    private JsonNullable<? extends SalesInvoiceRecipient> recipient;

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<SalesInvoiceLineItem>> lines;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discount")
    private JsonNullable<? extends SalesInvoiceDiscount> discount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountDue")
    private Optional<? extends Amount> amountDue;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subtotalAmount")
    private Optional<? extends Amount> subtotalAmount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalAmount")
    private Optional<? extends Amount> totalAmount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalVatAmount")
    private Optional<? extends Amount> totalVatAmount;

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discountedSubtotalAmount")
    private Optional<? extends Amount> discountedSubtotalAmount;

    @JsonCreator
    public EntitySalesInvoice(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode,
            @JsonProperty("profileId") JsonNullable<String> profileId,
            @JsonProperty("status") Optional<? extends SalesInvoiceStatus> status,
            @JsonProperty("vatScheme") Optional<? extends SalesInvoiceVatScheme> vatScheme,
            @JsonProperty("vatMode") Optional<? extends SalesInvoiceVatMode> vatMode,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("metadata") JsonNullable<? extends EntitySalesInvoiceMetadata> metadata,
            @JsonProperty("paymentTerm") JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm,
            @JsonProperty("paymentDetails") JsonNullable<? extends SalesInvoicePaymentDetails> paymentDetails,
            @JsonProperty("emailDetails") JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("mandateId") Optional<String> mandateId,
            @JsonProperty("recipientIdentifier") Optional<String> recipientIdentifier,
            @JsonProperty("recipient") JsonNullable<? extends SalesInvoiceRecipient> recipient,
            @JsonProperty("lines") JsonNullable<? extends List<SalesInvoiceLineItem>> lines,
            @JsonProperty("discount") JsonNullable<? extends SalesInvoiceDiscount> discount,
            @JsonProperty("amountDue") Optional<? extends Amount> amountDue,
            @JsonProperty("subtotalAmount") Optional<? extends Amount> subtotalAmount,
            @JsonProperty("totalAmount") Optional<? extends Amount> totalAmount,
            @JsonProperty("totalVatAmount") Optional<? extends Amount> totalVatAmount,
            @JsonProperty("discountedSubtotalAmount") Optional<? extends Amount> discountedSubtotalAmount) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(testmode, "testmode");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(vatScheme, "vatScheme");
        Utils.checkNotNull(vatMode, "vatMode");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        Utils.checkNotNull(emailDetails, "emailDetails");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        Utils.checkNotNull(recipient, "recipient");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(discount, "discount");
        Utils.checkNotNull(amountDue, "amountDue");
        Utils.checkNotNull(subtotalAmount, "subtotalAmount");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(totalVatAmount, "totalVatAmount");
        Utils.checkNotNull(discountedSubtotalAmount, "discountedSubtotalAmount");
        this.id = id;
        this.testmode = testmode;
        this.profileId = profileId;
        this.status = status;
        this.vatScheme = vatScheme;
        this.vatMode = vatMode;
        this.memo = memo;
        this.metadata = metadata;
        this.paymentTerm = paymentTerm;
        this.paymentDetails = paymentDetails;
        this.emailDetails = emailDetails;
        this.customerId = customerId;
        this.mandateId = mandateId;
        this.recipientIdentifier = recipientIdentifier;
        this.recipient = recipient;
        this.lines = lines;
        this.discount = discount;
        this.amountDue = amountDue;
        this.subtotalAmount = subtotalAmount;
        this.totalAmount = totalAmount;
        this.totalVatAmount = totalVatAmount;
        this.discountedSubtotalAmount = discountedSubtotalAmount;
    }
    
    public EntitySalesInvoice() {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    @JsonIgnore
    public JsonNullable<String> profileId() {
        return profileId;
    }

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     *   - `paymentDetails` is required if invoice should be set directly to `paid`
     *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
     *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SalesInvoiceStatus> status() {
        return (Optional<SalesInvoiceStatus>) status;
    }

    /**
     * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SalesInvoiceVatScheme> vatScheme() {
        return (Optional<SalesInvoiceVatScheme>) vatScheme;
    }

    /**
     * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
     * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SalesInvoiceVatMode> vatMode() {
        return (Optional<SalesInvoiceVatMode>) vatMode;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    /**
     * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<EntitySalesInvoiceMetadata> metadata() {
        return (JsonNullable<EntitySalesInvoiceMetadata>) metadata;
    }

    /**
     * The payment term to be set on the invoice.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoicePaymentTerm> paymentTerm() {
        return (JsonNullable<SalesInvoicePaymentTerm>) paymentTerm;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoicePaymentDetails> paymentDetails() {
        return (JsonNullable<SalesInvoicePaymentDetails>) paymentDetails;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceEmailDetails> emailDetails() {
        return (JsonNullable<SalesInvoiceEmailDetails>) emailDetails;
    }

    /**
     * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
     * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
     * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    @JsonIgnore
    public Optional<String> mandateId() {
        return mandateId;
    }

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
     * is not required to send a first invoice to a recipient.
     */
    @JsonIgnore
    public Optional<String> recipientIdentifier() {
        return recipientIdentifier;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceRecipient> recipient() {
        return (JsonNullable<SalesInvoiceRecipient>) recipient;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<SalesInvoiceLineItem>> lines() {
        return (JsonNullable<List<SalesInvoiceLineItem>>) lines;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceDiscount> discount() {
        return (JsonNullable<SalesInvoiceDiscount>) discount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> amountDue() {
        return (Optional<Amount>) amountDue;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> subtotalAmount() {
        return (Optional<Amount>) subtotalAmount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> totalAmount() {
        return (Optional<Amount>) totalAmount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> totalVatAmount() {
        return (Optional<Amount>) totalVatAmount;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Amount> discountedSubtotalAmount() {
        return (Optional<Amount>) discountedSubtotalAmount;
    }

    public static Builder builder() {
        return new Builder();
    }


    public EntitySalesInvoice withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    public EntitySalesInvoice withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public EntitySalesInvoice withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public EntitySalesInvoice withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    public EntitySalesInvoice withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = JsonNullable.of(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
     * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
     * required.
     */
    public EntitySalesInvoice withProfileId(JsonNullable<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     *   - `paymentDetails` is required if invoice should be set directly to `paid`
     *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
     *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    public EntitySalesInvoice withStatus(SalesInvoiceStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }


    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     *   - `paymentDetails` is required if invoice should be set directly to `paid`
     *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
     *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    public EntitySalesInvoice withStatus(Optional<? extends SalesInvoiceStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
     */
    public EntitySalesInvoice withVatScheme(SalesInvoiceVatScheme vatScheme) {
        Utils.checkNotNull(vatScheme, "vatScheme");
        this.vatScheme = Optional.ofNullable(vatScheme);
        return this;
    }


    /**
     * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
     */
    public EntitySalesInvoice withVatScheme(Optional<? extends SalesInvoiceVatScheme> vatScheme) {
        Utils.checkNotNull(vatScheme, "vatScheme");
        this.vatScheme = vatScheme;
        return this;
    }

    /**
     * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
     * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
     */
    public EntitySalesInvoice withVatMode(SalesInvoiceVatMode vatMode) {
        Utils.checkNotNull(vatMode, "vatMode");
        this.vatMode = Optional.ofNullable(vatMode);
        return this;
    }


    /**
     * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
     * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
     */
    public EntitySalesInvoice withVatMode(Optional<? extends SalesInvoiceVatMode> vatMode) {
        Utils.checkNotNull(vatMode, "vatMode");
        this.vatMode = vatMode;
        return this;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    public EntitySalesInvoice withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    public EntitySalesInvoice withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    /**
     * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public EntitySalesInvoice withMetadata(EntitySalesInvoiceMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public EntitySalesInvoice withMetadata(JsonNullable<? extends EntitySalesInvoiceMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * The payment term to be set on the invoice.
     */
    public EntitySalesInvoice withPaymentTerm(SalesInvoicePaymentTerm paymentTerm) {
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        this.paymentTerm = JsonNullable.of(paymentTerm);
        return this;
    }

    /**
     * The payment term to be set on the invoice.
     */
    public EntitySalesInvoice withPaymentTerm(JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm) {
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        this.paymentTerm = paymentTerm;
        return this;
    }

    public EntitySalesInvoice withPaymentDetails(SalesInvoicePaymentDetails paymentDetails) {
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        this.paymentDetails = JsonNullable.of(paymentDetails);
        return this;
    }

    public EntitySalesInvoice withPaymentDetails(JsonNullable<? extends SalesInvoicePaymentDetails> paymentDetails) {
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        this.paymentDetails = paymentDetails;
        return this;
    }

    public EntitySalesInvoice withEmailDetails(SalesInvoiceEmailDetails emailDetails) {
        Utils.checkNotNull(emailDetails, "emailDetails");
        this.emailDetails = JsonNullable.of(emailDetails);
        return this;
    }

    public EntitySalesInvoice withEmailDetails(JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails) {
        Utils.checkNotNull(emailDetails, "emailDetails");
        this.emailDetails = emailDetails;
        return this;
    }

    /**
     * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
     * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    public EntitySalesInvoice withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }


    /**
     * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
     * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    public EntitySalesInvoice withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
     * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    public EntitySalesInvoice withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = Optional.ofNullable(mandateId);
        return this;
    }


    /**
     * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
     * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
     */
    public EntitySalesInvoice withMandateId(Optional<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
     * is not required to send a first invoice to a recipient.
     */
    public EntitySalesInvoice withRecipientIdentifier(String recipientIdentifier) {
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        this.recipientIdentifier = Optional.ofNullable(recipientIdentifier);
        return this;
    }


    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
     * is not required to send a first invoice to a recipient.
     */
    public EntitySalesInvoice withRecipientIdentifier(Optional<String> recipientIdentifier) {
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        this.recipientIdentifier = recipientIdentifier;
        return this;
    }

    public EntitySalesInvoice withRecipient(SalesInvoiceRecipient recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = JsonNullable.of(recipient);
        return this;
    }

    public EntitySalesInvoice withRecipient(JsonNullable<? extends SalesInvoiceRecipient> recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = recipient;
        return this;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    public EntitySalesInvoice withLines(List<SalesInvoiceLineItem> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    public EntitySalesInvoice withLines(JsonNullable<? extends List<SalesInvoiceLineItem>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    public EntitySalesInvoice withDiscount(SalesInvoiceDiscount discount) {
        Utils.checkNotNull(discount, "discount");
        this.discount = JsonNullable.of(discount);
        return this;
    }

    public EntitySalesInvoice withDiscount(JsonNullable<? extends SalesInvoiceDiscount> discount) {
        Utils.checkNotNull(discount, "discount");
        this.discount = discount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withAmountDue(Amount amountDue) {
        Utils.checkNotNull(amountDue, "amountDue");
        this.amountDue = Optional.ofNullable(amountDue);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withAmountDue(Optional<? extends Amount> amountDue) {
        Utils.checkNotNull(amountDue, "amountDue");
        this.amountDue = amountDue;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withSubtotalAmount(Amount subtotalAmount) {
        Utils.checkNotNull(subtotalAmount, "subtotalAmount");
        this.subtotalAmount = Optional.ofNullable(subtotalAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withSubtotalAmount(Optional<? extends Amount> subtotalAmount) {
        Utils.checkNotNull(subtotalAmount, "subtotalAmount");
        this.subtotalAmount = subtotalAmount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withTotalAmount(Amount totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = Optional.ofNullable(totalAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withTotalAmount(Optional<? extends Amount> totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withTotalVatAmount(Amount totalVatAmount) {
        Utils.checkNotNull(totalVatAmount, "totalVatAmount");
        this.totalVatAmount = Optional.ofNullable(totalVatAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withTotalVatAmount(Optional<? extends Amount> totalVatAmount) {
        Utils.checkNotNull(totalVatAmount, "totalVatAmount");
        this.totalVatAmount = totalVatAmount;
        return this;
    }

    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withDiscountedSubtotalAmount(Amount discountedSubtotalAmount) {
        Utils.checkNotNull(discountedSubtotalAmount, "discountedSubtotalAmount");
        this.discountedSubtotalAmount = Optional.ofNullable(discountedSubtotalAmount);
        return this;
    }


    /**
     * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
     */
    public EntitySalesInvoice withDiscountedSubtotalAmount(Optional<? extends Amount> discountedSubtotalAmount) {
        Utils.checkNotNull(discountedSubtotalAmount, "discountedSubtotalAmount");
        this.discountedSubtotalAmount = discountedSubtotalAmount;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        EntitySalesInvoice other = (EntitySalesInvoice) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.testmode, other.testmode) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.vatScheme, other.vatScheme) &&
            Utils.enhancedDeepEquals(this.vatMode, other.vatMode) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.paymentTerm, other.paymentTerm) &&
            Utils.enhancedDeepEquals(this.paymentDetails, other.paymentDetails) &&
            Utils.enhancedDeepEquals(this.emailDetails, other.emailDetails) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.recipientIdentifier, other.recipientIdentifier) &&
            Utils.enhancedDeepEquals(this.recipient, other.recipient) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.discount, other.discount) &&
            Utils.enhancedDeepEquals(this.amountDue, other.amountDue) &&
            Utils.enhancedDeepEquals(this.subtotalAmount, other.subtotalAmount) &&
            Utils.enhancedDeepEquals(this.totalAmount, other.totalAmount) &&
            Utils.enhancedDeepEquals(this.totalVatAmount, other.totalVatAmount) &&
            Utils.enhancedDeepEquals(this.discountedSubtotalAmount, other.discountedSubtotalAmount);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, testmode, profileId,
            status, vatScheme, vatMode,
            memo, metadata, paymentTerm,
            paymentDetails, emailDetails, customerId,
            mandateId, recipientIdentifier, recipient,
            lines, discount, amountDue,
            subtotalAmount, totalAmount, totalVatAmount,
            discountedSubtotalAmount);
    }
    
    @Override
    public String toString() {
        return Utils.toString(EntitySalesInvoice.class,
                "id", id,
                "testmode", testmode,
                "profileId", profileId,
                "status", status,
                "vatScheme", vatScheme,
                "vatMode", vatMode,
                "memo", memo,
                "metadata", metadata,
                "paymentTerm", paymentTerm,
                "paymentDetails", paymentDetails,
                "emailDetails", emailDetails,
                "customerId", customerId,
                "mandateId", mandateId,
                "recipientIdentifier", recipientIdentifier,
                "recipient", recipient,
                "lines", lines,
                "discount", discount,
                "amountDue", amountDue,
                "subtotalAmount", subtotalAmount,
                "totalAmount", totalAmount,
                "totalVatAmount", totalVatAmount,
                "discountedSubtotalAmount", discountedSubtotalAmount);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private JsonNullable<Boolean> testmode = JsonNullable.undefined();

        private JsonNullable<String> profileId = JsonNullable.undefined();

        private Optional<? extends SalesInvoiceStatus> status = Optional.empty();

        private Optional<? extends SalesInvoiceVatScheme> vatScheme = Optional.empty();

        private Optional<? extends SalesInvoiceVatMode> vatMode = Optional.empty();

        private JsonNullable<String> memo = JsonNullable.undefined();

        private JsonNullable<? extends EntitySalesInvoiceMetadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoicePaymentDetails> paymentDetails = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails = JsonNullable.undefined();

        private Optional<String> customerId = Optional.empty();

        private Optional<String> mandateId = Optional.empty();

        private Optional<String> recipientIdentifier = Optional.empty();

        private JsonNullable<? extends SalesInvoiceRecipient> recipient = JsonNullable.undefined();

        private JsonNullable<? extends List<SalesInvoiceLineItem>> lines = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoiceDiscount> discount = JsonNullable.undefined();

        private Optional<? extends Amount> amountDue = Optional.empty();

        private Optional<? extends Amount> subtotalAmount = Optional.empty();

        private Optional<? extends Amount> totalAmount = Optional.empty();

        private Optional<? extends Amount> totalVatAmount = Optional.empty();

        private Optional<? extends Amount> discountedSubtotalAmount = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
         * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
         * required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = JsonNullable.of(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation
         * request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is
         * required.
         */
        public Builder profileId(JsonNullable<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        /**
         * The status for the invoice to end up in.
         * 
         * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
         * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
         * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
         * 
         * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
         * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
         * 
         * <p>Dependent parameters:
         *   - `paymentDetails` is required if invoice should be set directly to `paid`
         *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
         *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
         */
        public Builder status(SalesInvoiceStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The status for the invoice to end up in.
         * 
         * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued` sends it to
         * the recipient so they may then pay through our payment system. To skip our payment process, set this to `paid` to
         * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
         * 
         * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
         * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
         * 
         * <p>Dependent parameters:
         *   - `paymentDetails` is required if invoice should be set directly to `paid`
         *   - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice to `paid`
         *   - `emailDetails` optional for `issued` and `paid` to send the invoice by email
         */
        public Builder status(Optional<? extends SalesInvoiceStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
         */
        public Builder vatScheme(SalesInvoiceVatScheme vatScheme) {
            Utils.checkNotNull(vatScheme, "vatScheme");
            this.vatScheme = Optional.ofNullable(vatScheme);
            return this;
        }

        /**
         * The VAT scheme to create the invoice for. You must be enrolled with One Stop Shop enabled to use it.
         */
        public Builder vatScheme(Optional<? extends SalesInvoiceVatScheme> vatScheme) {
            Utils.checkNotNull(vatScheme, "vatScheme");
            this.vatScheme = vatScheme;
            return this;
        }


        /**
         * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
         * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
         */
        public Builder vatMode(SalesInvoiceVatMode vatMode) {
            Utils.checkNotNull(vatMode, "vatMode");
            this.vatMode = Optional.ofNullable(vatMode);
            return this;
        }

        /**
         * The VAT mode to use for VAT calculation. `exclusive` mode means we will apply the relevant VAT on top of the
         * price. `inclusive` means the prices you are providing to us already contain the VAT you want to apply.
         */
        public Builder vatMode(Optional<? extends SalesInvoiceVatMode> vatMode) {
            Utils.checkNotNull(vatMode, "vatMode");
            this.vatMode = vatMode;
            return this;
        }


        /**
         * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }


        /**
         * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(EntitySalesInvoiceMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like as a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends EntitySalesInvoiceMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * The payment term to be set on the invoice.
         */
        public Builder paymentTerm(SalesInvoicePaymentTerm paymentTerm) {
            Utils.checkNotNull(paymentTerm, "paymentTerm");
            this.paymentTerm = JsonNullable.of(paymentTerm);
            return this;
        }

        /**
         * The payment term to be set on the invoice.
         */
        public Builder paymentTerm(JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm) {
            Utils.checkNotNull(paymentTerm, "paymentTerm");
            this.paymentTerm = paymentTerm;
            return this;
        }


        public Builder paymentDetails(SalesInvoicePaymentDetails paymentDetails) {
            Utils.checkNotNull(paymentDetails, "paymentDetails");
            this.paymentDetails = JsonNullable.of(paymentDetails);
            return this;
        }

        public Builder paymentDetails(JsonNullable<? extends SalesInvoicePaymentDetails> paymentDetails) {
            Utils.checkNotNull(paymentDetails, "paymentDetails");
            this.paymentDetails = paymentDetails;
            return this;
        }


        public Builder emailDetails(SalesInvoiceEmailDetails emailDetails) {
            Utils.checkNotNull(emailDetails, "emailDetails");
            this.emailDetails = JsonNullable.of(emailDetails);
            return this;
        }

        public Builder emailDetails(JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails) {
            Utils.checkNotNull(emailDetails, "emailDetails");
            this.emailDetails = emailDetails;
            return this;
        }


        /**
         * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
         * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        /**
         * The identifier referring to the [customer](get-customer) you want to attempt an automated payment for. If
         * provided, `mandateId` becomes required as well. Only allowed for invoices with status `paid`.
         */
        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
         * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = Optional.ofNullable(mandateId);
            return this;
        }

        /**
         * The identifier referring to the [mandate](get-mandate) you want to use for the automated payment. If provided,
         * `customerId` becomes required as well. Only allowed for invoices with status `paid`.
         */
        public Builder mandateId(Optional<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
         * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
         * is not required to send a first invoice to a recipient.
         */
        public Builder recipientIdentifier(String recipientIdentifier) {
            Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
            this.recipientIdentifier = Optional.ofNullable(recipientIdentifier);
            return this;
        }

        /**
         * An identifier tied to the recipient data. This should be a unique value based on data your system contains,
         * so that both you and us know who we're referring to. It is a value you provide to us so that recipient management
         * is not required to send a first invoice to a recipient.
         */
        public Builder recipientIdentifier(Optional<String> recipientIdentifier) {
            Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
            this.recipientIdentifier = recipientIdentifier;
            return this;
        }


        public Builder recipient(SalesInvoiceRecipient recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = JsonNullable.of(recipient);
            return this;
        }

        public Builder recipient(JsonNullable<? extends SalesInvoiceRecipient> recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = recipient;
            return this;
        }


        /**
         * Provide the line items for the invoice. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the invoice.
         */
        public Builder lines(List<SalesInvoiceLineItem> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Provide the line items for the invoice. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the invoice.
         */
        public Builder lines(JsonNullable<? extends List<SalesInvoiceLineItem>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        public Builder discount(SalesInvoiceDiscount discount) {
            Utils.checkNotNull(discount, "discount");
            this.discount = JsonNullable.of(discount);
            return this;
        }

        public Builder discount(JsonNullable<? extends SalesInvoiceDiscount> discount) {
            Utils.checkNotNull(discount, "discount");
            this.discount = discount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountDue(Amount amountDue) {
            Utils.checkNotNull(amountDue, "amountDue");
            this.amountDue = Optional.ofNullable(amountDue);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder amountDue(Optional<? extends Amount> amountDue) {
            Utils.checkNotNull(amountDue, "amountDue");
            this.amountDue = amountDue;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder subtotalAmount(Amount subtotalAmount) {
            Utils.checkNotNull(subtotalAmount, "subtotalAmount");
            this.subtotalAmount = Optional.ofNullable(subtotalAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder subtotalAmount(Optional<? extends Amount> subtotalAmount) {
            Utils.checkNotNull(subtotalAmount, "subtotalAmount");
            this.subtotalAmount = subtotalAmount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder totalAmount(Amount totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = Optional.ofNullable(totalAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder totalAmount(Optional<? extends Amount> totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder totalVatAmount(Amount totalVatAmount) {
            Utils.checkNotNull(totalVatAmount, "totalVatAmount");
            this.totalVatAmount = Optional.ofNullable(totalVatAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder totalVatAmount(Optional<? extends Amount> totalVatAmount) {
            Utils.checkNotNull(totalVatAmount, "totalVatAmount");
            this.totalVatAmount = totalVatAmount;
            return this;
        }


        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder discountedSubtotalAmount(Amount discountedSubtotalAmount) {
            Utils.checkNotNull(discountedSubtotalAmount, "discountedSubtotalAmount");
            this.discountedSubtotalAmount = Optional.ofNullable(discountedSubtotalAmount);
            return this;
        }

        /**
         * In v2 endpoints, monetary amounts are represented as objects with a `currency` and `value` field.
         */
        public Builder discountedSubtotalAmount(Optional<? extends Amount> discountedSubtotalAmount) {
            Utils.checkNotNull(discountedSubtotalAmount, "discountedSubtotalAmount");
            this.discountedSubtotalAmount = discountedSubtotalAmount;
            return this;
        }

        public EntitySalesInvoice build() {

            return new EntitySalesInvoice(
                id, testmode, profileId,
                status, vatScheme, vatMode,
                memo, metadata, paymentTerm,
                paymentDetails, emailDetails, customerId,
                mandateId, recipientIdentifier, recipient,
                lines, discount, amountDue,
                subtotalAmount, totalAmount, totalVatAmount,
                discountedSubtotalAmount);
        }

    }
}
