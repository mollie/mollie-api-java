/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.models.components.Locale;
import com.mollie.mollie.models.components.Metadata;
import com.mollie.mollie.models.components.Method;
import com.mollie.mollie.models.components.PaymentAddress;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class UpdatePaymentRequestBody {
    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Metadata> metadata;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends Method> method;

    /**
     * Allows you to preset the language to be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private Optional<? extends Locale> locale;

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dueDate")
    private Optional<String> dueDate;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issuer")
    private JsonNullable<String> issuer;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends PaymentAddress> billingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends PaymentAddress> shippingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingEmail")
    private Optional<String> billingEmail;

    @JsonCreator
    public UpdatePaymentRequestBody(
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("metadata") JsonNullable<? extends Metadata> metadata,
            @JsonProperty("method") JsonNullable<? extends Method> method,
            @JsonProperty("locale") Optional<? extends Locale> locale,
            @JsonProperty("dueDate") Optional<String> dueDate,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode,
            @JsonProperty("issuer") JsonNullable<String> issuer,
            @JsonProperty("billingAddress") Optional<? extends PaymentAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends PaymentAddress> shippingAddress,
            @JsonProperty("billingEmail") Optional<String> billingEmail) {
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(testmode, "testmode");
        Utils.checkNotNull(issuer, "issuer");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(billingEmail, "billingEmail");
        this.description = description;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.metadata = metadata;
        this.method = method;
        this.locale = locale;
        this.dueDate = dueDate;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.testmode = testmode;
        this.issuer = issuer;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.billingEmail = billingEmail;
    }
    
    public UpdatePaymentRequestBody() {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Metadata> metadata() {
        return (JsonNullable<Metadata>) metadata;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Method> method() {
        return (JsonNullable<Method>) method;
    }

    /**
     * Allows you to preset the language to be used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Locale> locale() {
        return (Optional<Locale>) locale;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonIgnore
    public Optional<String> dueDate() {
        return dueDate;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonIgnore
    public JsonNullable<String> issuer() {
        return issuer;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentAddress> billingAddress() {
        return (Optional<PaymentAddress>) billingAddress;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<PaymentAddress> shippingAddress() {
        return (Optional<PaymentAddress>) shippingAddress;
    }

    @JsonIgnore
    public Optional<String> billingEmail() {
        return billingEmail;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public UpdatePaymentRequestBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }


    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public UpdatePaymentRequestBody withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public UpdatePaymentRequestBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public UpdatePaymentRequestBody withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public UpdatePaymentRequestBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public UpdatePaymentRequestBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public UpdatePaymentRequestBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public UpdatePaymentRequestBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public UpdatePaymentRequestBody withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public UpdatePaymentRequestBody withMetadata(JsonNullable<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public UpdatePaymentRequestBody withMethod(Method method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public UpdatePaymentRequestBody withMethod(JsonNullable<? extends Method> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * Allows you to preset the language to be used.
     */
    public UpdatePaymentRequestBody withLocale(Locale locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = Optional.ofNullable(locale);
        return this;
    }


    /**
     * Allows you to preset the language to be used.
     */
    public UpdatePaymentRequestBody withLocale(Optional<? extends Locale> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public UpdatePaymentRequestBody withDueDate(String dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = Optional.ofNullable(dueDate);
        return this;
    }


    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public UpdatePaymentRequestBody withDueDate(Optional<String> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public UpdatePaymentRequestBody withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public UpdatePaymentRequestBody withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public UpdatePaymentRequestBody withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public UpdatePaymentRequestBody withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public UpdatePaymentRequestBody withIssuer(String issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = JsonNullable.of(issuer);
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public UpdatePaymentRequestBody withIssuer(JsonNullable<String> issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = issuer;
        return this;
    }

    public UpdatePaymentRequestBody withBillingAddress(PaymentAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    public UpdatePaymentRequestBody withBillingAddress(Optional<? extends PaymentAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    public UpdatePaymentRequestBody withShippingAddress(PaymentAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    public UpdatePaymentRequestBody withShippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    public UpdatePaymentRequestBody withBillingEmail(String billingEmail) {
        Utils.checkNotNull(billingEmail, "billingEmail");
        this.billingEmail = Optional.ofNullable(billingEmail);
        return this;
    }


    public UpdatePaymentRequestBody withBillingEmail(Optional<String> billingEmail) {
        Utils.checkNotNull(billingEmail, "billingEmail");
        this.billingEmail = billingEmail;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UpdatePaymentRequestBody other = (UpdatePaymentRequestBody) o;
        return 
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.dueDate, other.dueDate) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.testmode, other.testmode) &&
            Utils.enhancedDeepEquals(this.issuer, other.issuer) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.billingEmail, other.billingEmail);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            description, redirectUrl, cancelUrl,
            webhookUrl, metadata, method,
            locale, dueDate, restrictPaymentMethodsToCountry,
            testmode, issuer, billingAddress,
            shippingAddress, billingEmail);
    }
    
    @Override
    public String toString() {
        return Utils.toString(UpdatePaymentRequestBody.class,
                "description", description,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "metadata", metadata,
                "method", method,
                "locale", locale,
                "dueDate", dueDate,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "testmode", testmode,
                "issuer", issuer,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "billingEmail", billingEmail);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> description = Optional.empty();

        private JsonNullable<String> redirectUrl = JsonNullable.undefined();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends Metadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends Method> method = JsonNullable.undefined();

        private Optional<? extends Locale> locale = Optional.empty();

        private Optional<String> dueDate = Optional.empty();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<Boolean> testmode = JsonNullable.undefined();

        private JsonNullable<String> issuer = JsonNullable.undefined();

        private Optional<? extends PaymentAddress> billingAddress = Optional.empty();

        private Optional<? extends PaymentAddress> shippingAddress = Optional.empty();

        private Optional<String> billingEmail = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(Method method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(JsonNullable<? extends Method> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(Locale locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = Optional.ofNullable(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used.
         */
        public Builder locale(Optional<? extends Locale> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(String dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = Optional.ofNullable(dueDate);
            return this;
        }

        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(Optional<String> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }


        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(String issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = JsonNullable.of(issuer);
            return this;
        }

        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(JsonNullable<String> issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = issuer;
            return this;
        }


        public Builder billingAddress(PaymentAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        public Builder billingAddress(Optional<? extends PaymentAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        public Builder shippingAddress(PaymentAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        public Builder shippingAddress(Optional<? extends PaymentAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        public Builder billingEmail(String billingEmail) {
            Utils.checkNotNull(billingEmail, "billingEmail");
            this.billingEmail = Optional.ofNullable(billingEmail);
            return this;
        }

        public Builder billingEmail(Optional<String> billingEmail) {
            Utils.checkNotNull(billingEmail, "billingEmail");
            this.billingEmail = billingEmail;
            return this;
        }

        public UpdatePaymentRequestBody build() {

            return new UpdatePaymentRequestBody(
                description, redirectUrl, cancelUrl,
                webhookUrl, metadata, method,
                locale, dueDate, restrictPaymentMethodsToCountry,
                testmode, issuer, billingAddress,
                shippingAddress, billingEmail);
        }

    }
}
