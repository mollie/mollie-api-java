/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * Totals
 * 
 * <p>Totals are grouped according to the chosen grouping rule. The example response should give a good idea of what a typical grouping looks like.
 * 
 * <p>If grouping `status-balances` is chosen, the main grouping is as follows:
 * 
 * <p>* `pendingBalance` containing an `open`, `pending`, `movedToAvailable`, and `close` sub-group
 * * `availableBalance` containing an `open`, `movedFromPending`, `immediatelyAvailable`, and `close` sub-group
 * 
 * <p>If grouping `transaction-categories` is chosen, the main grouping is as follows:
 * 
 * <p>* `open` and `close` groups, each containing a `pending` and `available` sub-group
 * * Transaction type groups such as `payments`, `refunds`, `chargebacks`, `capital`, `transfers`, `fee-prepayments`, `corrections`, `topups` each containing a `pending`, `movedToAvailable`, and `immediatelyAvailable` sub-group
 * 
 * <p>Each sub-group typically has:
 * 
 * <p>* An `amount` object containing the group's total amount
 * * A `count` integer if relevant (for example, counting the number of refunds)
 * * A `subtotals` array containing more sub-group objects if applicable
 */
public class Totals {
    /**
     * The pending balance. Only available if grouping is `status-balances`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pendingBalance")
    private JsonNullable<? extends PendingBalance> pendingBalance;

    /**
     * The available balance. Only available if grouping is `status-balances`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("availableBalance")
    private JsonNullable<? extends AvailableBalance> availableBalance;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("open")
    private Optional<? extends Open> open;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("close")
    private Optional<? extends Close> close;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payments")
    private Optional<? extends GetBalanceReportPayments> payments;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("refunds")
    private Optional<? extends GetBalanceReportRefunds> refunds;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("chargebacks")
    private Optional<? extends GetBalanceReportChargebacks> chargebacks;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("capital")
    private Optional<? extends Capital> capital;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("transfers")
    private Optional<? extends Transfers> transfers;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fee-prepayments")
    private Optional<? extends FeePrepayments> feePrepayments;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("corrections")
    private Optional<? extends Corrections> corrections;

    /**
     * Only available on `transaction-categories` grouping.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("topups")
    private Optional<? extends Topups> topups;

    @JsonCreator
    public Totals(
            @JsonProperty("pendingBalance") JsonNullable<? extends PendingBalance> pendingBalance,
            @JsonProperty("availableBalance") JsonNullable<? extends AvailableBalance> availableBalance,
            @JsonProperty("open") Optional<? extends Open> open,
            @JsonProperty("close") Optional<? extends Close> close,
            @JsonProperty("payments") Optional<? extends GetBalanceReportPayments> payments,
            @JsonProperty("refunds") Optional<? extends GetBalanceReportRefunds> refunds,
            @JsonProperty("chargebacks") Optional<? extends GetBalanceReportChargebacks> chargebacks,
            @JsonProperty("capital") Optional<? extends Capital> capital,
            @JsonProperty("transfers") Optional<? extends Transfers> transfers,
            @JsonProperty("fee-prepayments") Optional<? extends FeePrepayments> feePrepayments,
            @JsonProperty("corrections") Optional<? extends Corrections> corrections,
            @JsonProperty("topups") Optional<? extends Topups> topups) {
        Utils.checkNotNull(pendingBalance, "pendingBalance");
        Utils.checkNotNull(availableBalance, "availableBalance");
        Utils.checkNotNull(open, "open");
        Utils.checkNotNull(close, "close");
        Utils.checkNotNull(payments, "payments");
        Utils.checkNotNull(refunds, "refunds");
        Utils.checkNotNull(chargebacks, "chargebacks");
        Utils.checkNotNull(capital, "capital");
        Utils.checkNotNull(transfers, "transfers");
        Utils.checkNotNull(feePrepayments, "feePrepayments");
        Utils.checkNotNull(corrections, "corrections");
        Utils.checkNotNull(topups, "topups");
        this.pendingBalance = pendingBalance;
        this.availableBalance = availableBalance;
        this.open = open;
        this.close = close;
        this.payments = payments;
        this.refunds = refunds;
        this.chargebacks = chargebacks;
        this.capital = capital;
        this.transfers = transfers;
        this.feePrepayments = feePrepayments;
        this.corrections = corrections;
        this.topups = topups;
    }
    
    public Totals() {
        this(JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * The pending balance. Only available if grouping is `status-balances`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PendingBalance> pendingBalance() {
        return (JsonNullable<PendingBalance>) pendingBalance;
    }

    /**
     * The available balance. Only available if grouping is `status-balances`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AvailableBalance> availableBalance() {
        return (JsonNullable<AvailableBalance>) availableBalance;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Open> open() {
        return (Optional<Open>) open;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Close> close() {
        return (Optional<Close>) close;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetBalanceReportPayments> payments() {
        return (Optional<GetBalanceReportPayments>) payments;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetBalanceReportRefunds> refunds() {
        return (Optional<GetBalanceReportRefunds>) refunds;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetBalanceReportChargebacks> chargebacks() {
        return (Optional<GetBalanceReportChargebacks>) chargebacks;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Capital> capital() {
        return (Optional<Capital>) capital;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Transfers> transfers() {
        return (Optional<Transfers>) transfers;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<FeePrepayments> feePrepayments() {
        return (Optional<FeePrepayments>) feePrepayments;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Corrections> corrections() {
        return (Optional<Corrections>) corrections;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Topups> topups() {
        return (Optional<Topups>) topups;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The pending balance. Only available if grouping is `status-balances`.
     */
    public Totals withPendingBalance(PendingBalance pendingBalance) {
        Utils.checkNotNull(pendingBalance, "pendingBalance");
        this.pendingBalance = JsonNullable.of(pendingBalance);
        return this;
    }

    /**
     * The pending balance. Only available if grouping is `status-balances`.
     */
    public Totals withPendingBalance(JsonNullable<? extends PendingBalance> pendingBalance) {
        Utils.checkNotNull(pendingBalance, "pendingBalance");
        this.pendingBalance = pendingBalance;
        return this;
    }

    /**
     * The available balance. Only available if grouping is `status-balances`.
     */
    public Totals withAvailableBalance(AvailableBalance availableBalance) {
        Utils.checkNotNull(availableBalance, "availableBalance");
        this.availableBalance = JsonNullable.of(availableBalance);
        return this;
    }

    /**
     * The available balance. Only available if grouping is `status-balances`.
     */
    public Totals withAvailableBalance(JsonNullable<? extends AvailableBalance> availableBalance) {
        Utils.checkNotNull(availableBalance, "availableBalance");
        this.availableBalance = availableBalance;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withOpen(Open open) {
        Utils.checkNotNull(open, "open");
        this.open = Optional.ofNullable(open);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withOpen(Optional<? extends Open> open) {
        Utils.checkNotNull(open, "open");
        this.open = open;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withClose(Close close) {
        Utils.checkNotNull(close, "close");
        this.close = Optional.ofNullable(close);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withClose(Optional<? extends Close> close) {
        Utils.checkNotNull(close, "close");
        this.close = close;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withPayments(GetBalanceReportPayments payments) {
        Utils.checkNotNull(payments, "payments");
        this.payments = Optional.ofNullable(payments);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withPayments(Optional<? extends GetBalanceReportPayments> payments) {
        Utils.checkNotNull(payments, "payments");
        this.payments = payments;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withRefunds(GetBalanceReportRefunds refunds) {
        Utils.checkNotNull(refunds, "refunds");
        this.refunds = Optional.ofNullable(refunds);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withRefunds(Optional<? extends GetBalanceReportRefunds> refunds) {
        Utils.checkNotNull(refunds, "refunds");
        this.refunds = refunds;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withChargebacks(GetBalanceReportChargebacks chargebacks) {
        Utils.checkNotNull(chargebacks, "chargebacks");
        this.chargebacks = Optional.ofNullable(chargebacks);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withChargebacks(Optional<? extends GetBalanceReportChargebacks> chargebacks) {
        Utils.checkNotNull(chargebacks, "chargebacks");
        this.chargebacks = chargebacks;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withCapital(Capital capital) {
        Utils.checkNotNull(capital, "capital");
        this.capital = Optional.ofNullable(capital);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withCapital(Optional<? extends Capital> capital) {
        Utils.checkNotNull(capital, "capital");
        this.capital = capital;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withTransfers(Transfers transfers) {
        Utils.checkNotNull(transfers, "transfers");
        this.transfers = Optional.ofNullable(transfers);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withTransfers(Optional<? extends Transfers> transfers) {
        Utils.checkNotNull(transfers, "transfers");
        this.transfers = transfers;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withFeePrepayments(FeePrepayments feePrepayments) {
        Utils.checkNotNull(feePrepayments, "feePrepayments");
        this.feePrepayments = Optional.ofNullable(feePrepayments);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withFeePrepayments(Optional<? extends FeePrepayments> feePrepayments) {
        Utils.checkNotNull(feePrepayments, "feePrepayments");
        this.feePrepayments = feePrepayments;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withCorrections(Corrections corrections) {
        Utils.checkNotNull(corrections, "corrections");
        this.corrections = Optional.ofNullable(corrections);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withCorrections(Optional<? extends Corrections> corrections) {
        Utils.checkNotNull(corrections, "corrections");
        this.corrections = corrections;
        return this;
    }

    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withTopups(Topups topups) {
        Utils.checkNotNull(topups, "topups");
        this.topups = Optional.ofNullable(topups);
        return this;
    }


    /**
     * Only available on `transaction-categories` grouping.
     */
    public Totals withTopups(Optional<? extends Topups> topups) {
        Utils.checkNotNull(topups, "topups");
        this.topups = topups;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Totals other = (Totals) o;
        return 
            Utils.enhancedDeepEquals(this.pendingBalance, other.pendingBalance) &&
            Utils.enhancedDeepEquals(this.availableBalance, other.availableBalance) &&
            Utils.enhancedDeepEquals(this.open, other.open) &&
            Utils.enhancedDeepEquals(this.close, other.close) &&
            Utils.enhancedDeepEquals(this.payments, other.payments) &&
            Utils.enhancedDeepEquals(this.refunds, other.refunds) &&
            Utils.enhancedDeepEquals(this.chargebacks, other.chargebacks) &&
            Utils.enhancedDeepEquals(this.capital, other.capital) &&
            Utils.enhancedDeepEquals(this.transfers, other.transfers) &&
            Utils.enhancedDeepEquals(this.feePrepayments, other.feePrepayments) &&
            Utils.enhancedDeepEquals(this.corrections, other.corrections) &&
            Utils.enhancedDeepEquals(this.topups, other.topups);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            pendingBalance, availableBalance, open,
            close, payments, refunds,
            chargebacks, capital, transfers,
            feePrepayments, corrections, topups);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Totals.class,
                "pendingBalance", pendingBalance,
                "availableBalance", availableBalance,
                "open", open,
                "close", close,
                "payments", payments,
                "refunds", refunds,
                "chargebacks", chargebacks,
                "capital", capital,
                "transfers", transfers,
                "feePrepayments", feePrepayments,
                "corrections", corrections,
                "topups", topups);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private JsonNullable<? extends PendingBalance> pendingBalance = JsonNullable.undefined();

        private JsonNullable<? extends AvailableBalance> availableBalance = JsonNullable.undefined();

        private Optional<? extends Open> open = Optional.empty();

        private Optional<? extends Close> close = Optional.empty();

        private Optional<? extends GetBalanceReportPayments> payments = Optional.empty();

        private Optional<? extends GetBalanceReportRefunds> refunds = Optional.empty();

        private Optional<? extends GetBalanceReportChargebacks> chargebacks = Optional.empty();

        private Optional<? extends Capital> capital = Optional.empty();

        private Optional<? extends Transfers> transfers = Optional.empty();

        private Optional<? extends FeePrepayments> feePrepayments = Optional.empty();

        private Optional<? extends Corrections> corrections = Optional.empty();

        private Optional<? extends Topups> topups = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The pending balance. Only available if grouping is `status-balances`.
         */
        public Builder pendingBalance(PendingBalance pendingBalance) {
            Utils.checkNotNull(pendingBalance, "pendingBalance");
            this.pendingBalance = JsonNullable.of(pendingBalance);
            return this;
        }

        /**
         * The pending balance. Only available if grouping is `status-balances`.
         */
        public Builder pendingBalance(JsonNullable<? extends PendingBalance> pendingBalance) {
            Utils.checkNotNull(pendingBalance, "pendingBalance");
            this.pendingBalance = pendingBalance;
            return this;
        }


        /**
         * The available balance. Only available if grouping is `status-balances`.
         */
        public Builder availableBalance(AvailableBalance availableBalance) {
            Utils.checkNotNull(availableBalance, "availableBalance");
            this.availableBalance = JsonNullable.of(availableBalance);
            return this;
        }

        /**
         * The available balance. Only available if grouping is `status-balances`.
         */
        public Builder availableBalance(JsonNullable<? extends AvailableBalance> availableBalance) {
            Utils.checkNotNull(availableBalance, "availableBalance");
            this.availableBalance = availableBalance;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder open(Open open) {
            Utils.checkNotNull(open, "open");
            this.open = Optional.ofNullable(open);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder open(Optional<? extends Open> open) {
            Utils.checkNotNull(open, "open");
            this.open = open;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder close(Close close) {
            Utils.checkNotNull(close, "close");
            this.close = Optional.ofNullable(close);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder close(Optional<? extends Close> close) {
            Utils.checkNotNull(close, "close");
            this.close = close;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder payments(GetBalanceReportPayments payments) {
            Utils.checkNotNull(payments, "payments");
            this.payments = Optional.ofNullable(payments);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder payments(Optional<? extends GetBalanceReportPayments> payments) {
            Utils.checkNotNull(payments, "payments");
            this.payments = payments;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder refunds(GetBalanceReportRefunds refunds) {
            Utils.checkNotNull(refunds, "refunds");
            this.refunds = Optional.ofNullable(refunds);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder refunds(Optional<? extends GetBalanceReportRefunds> refunds) {
            Utils.checkNotNull(refunds, "refunds");
            this.refunds = refunds;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder chargebacks(GetBalanceReportChargebacks chargebacks) {
            Utils.checkNotNull(chargebacks, "chargebacks");
            this.chargebacks = Optional.ofNullable(chargebacks);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder chargebacks(Optional<? extends GetBalanceReportChargebacks> chargebacks) {
            Utils.checkNotNull(chargebacks, "chargebacks");
            this.chargebacks = chargebacks;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder capital(Capital capital) {
            Utils.checkNotNull(capital, "capital");
            this.capital = Optional.ofNullable(capital);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder capital(Optional<? extends Capital> capital) {
            Utils.checkNotNull(capital, "capital");
            this.capital = capital;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder transfers(Transfers transfers) {
            Utils.checkNotNull(transfers, "transfers");
            this.transfers = Optional.ofNullable(transfers);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder transfers(Optional<? extends Transfers> transfers) {
            Utils.checkNotNull(transfers, "transfers");
            this.transfers = transfers;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder feePrepayments(FeePrepayments feePrepayments) {
            Utils.checkNotNull(feePrepayments, "feePrepayments");
            this.feePrepayments = Optional.ofNullable(feePrepayments);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder feePrepayments(Optional<? extends FeePrepayments> feePrepayments) {
            Utils.checkNotNull(feePrepayments, "feePrepayments");
            this.feePrepayments = feePrepayments;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder corrections(Corrections corrections) {
            Utils.checkNotNull(corrections, "corrections");
            this.corrections = Optional.ofNullable(corrections);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder corrections(Optional<? extends Corrections> corrections) {
            Utils.checkNotNull(corrections, "corrections");
            this.corrections = corrections;
            return this;
        }


        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder topups(Topups topups) {
            Utils.checkNotNull(topups, "topups");
            this.topups = Optional.ofNullable(topups);
            return this;
        }

        /**
         * Only available on `transaction-categories` grouping.
         */
        public Builder topups(Optional<? extends Topups> topups) {
            Utils.checkNotNull(topups, "topups");
            this.topups = topups;
            return this;
        }

        public Totals build() {

            return new Totals(
                pendingBalance, availableBalance, open,
                close, payments, refunds,
                chargebacks, capital, transfers,
                feePrepayments, corrections, topups);
        }

    }
}
