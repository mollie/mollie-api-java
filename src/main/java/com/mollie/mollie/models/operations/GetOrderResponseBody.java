/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.mollie.mollie.models.operations;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
/**
 * GetOrderResponseBody - The order object.
 */

public class GetOrderResponseBody {

    /**
     * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource")
    private Optional<String> resource;

    /**
     * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mode")
    private Optional<String> mode;

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderNumber")
    private Optional<String> orderNumber;

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private Optional<? extends List<GetOrderLines>> lines;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends GetOrderAmount> amount;

    /**
     * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private JsonNullable<? extends AmountRefunded> amountRefunded;

    /**
     * The total amount that is already captured for this order. Only available when this order supports captures.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private JsonNullable<? extends AmountCaptured> amountCaptured;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends GetOrderBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends GetOrderShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private Optional<String> locale;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shopperCountryMustMatchBillingCountry")
    private Optional<Boolean> shopperCountryMustMatchBillingCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends GetOrderMetadata> metadata;

    /**
     * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
     * 
     * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment")
    private JsonNullable<? extends GetOrderPayment> payment;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private JsonNullable<String> profileId;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<String> createdAt;

    /**
     * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("completedAt")
    private JsonNullable<String> completedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("_links")
    private Optional<? extends GetOrderLinks> links;

    @JsonCreator
    public GetOrderResponseBody(
            @JsonProperty("resource") Optional<String> resource,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("mode") Optional<String> mode,
            @JsonProperty("orderNumber") Optional<String> orderNumber,
            @JsonProperty("lines") Optional<? extends List<GetOrderLines>> lines,
            @JsonProperty("amount") Optional<? extends GetOrderAmount> amount,
            @JsonProperty("amountRefunded") JsonNullable<? extends AmountRefunded> amountRefunded,
            @JsonProperty("amountCaptured") JsonNullable<? extends AmountCaptured> amountCaptured,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("billingAddress") Optional<? extends GetOrderBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends GetOrderShippingAddress> shippingAddress,
            @JsonProperty("locale") Optional<String> locale,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("shopperCountryMustMatchBillingCountry") Optional<Boolean> shopperCountryMustMatchBillingCountry,
            @JsonProperty("metadata") JsonNullable<? extends GetOrderMetadata> metadata,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("payment") JsonNullable<? extends GetOrderPayment> payment,
            @JsonProperty("profileId") JsonNullable<String> profileId,
            @JsonProperty("createdAt") Optional<String> createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("completedAt") JsonNullable<String> completedAt,
            @JsonProperty("_links") Optional<? extends GetOrderLinks> links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(orderNumber, "orderNumber");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(payment, "payment");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(completedAt, "completedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.orderNumber = orderNumber;
        this.lines = lines;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountCaptured = amountCaptured;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.method = method;
        this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
        this.metadata = metadata;
        this.status = status;
        this.isCancelable = isCancelable;
        this.payment = payment;
        this.profileId = profileId;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.completedAt = completedAt;
        this.links = links;
    }
    
    public GetOrderResponseBody() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
     */
    @JsonIgnore
    public Optional<String> resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    @JsonIgnore
    public Optional<String> mode() {
        return mode;
    }

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    @JsonIgnore
    public Optional<String> orderNumber() {
        return orderNumber;
    }

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<GetOrderLines>> lines() {
        return (Optional<List<GetOrderLines>>) lines;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetOrderAmount> amount() {
        return (Optional<GetOrderAmount>) amount;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmountRefunded> amountRefunded() {
        return (JsonNullable<AmountRefunded>) amountRefunded;
    }

    /**
     * The total amount that is already captured for this order. Only available when this order supports captures.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmountCaptured> amountCaptured() {
        return (JsonNullable<AmountCaptured>) amountCaptured;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetOrderBillingAddress> billingAddress() {
        return (Optional<GetOrderBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetOrderShippingAddress> shippingAddress() {
        return (Optional<GetOrderShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    @JsonIgnore
    public Optional<String> locale() {
        return locale;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    @JsonIgnore
    public Optional<Boolean> shopperCountryMustMatchBillingCountry() {
        return shopperCountryMustMatchBillingCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GetOrderMetadata> metadata() {
        return (JsonNullable<GetOrderMetadata>) metadata;
    }

    /**
     * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
     * 
     * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GetOrderPayment> payment() {
        return (JsonNullable<GetOrderPayment>) payment;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonIgnore
    public JsonNullable<String> profileId() {
        return profileId;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public Optional<String> createdAt() {
        return createdAt;
    }

    /**
     * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> completedAt() {
        return completedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetOrderLinks> links() {
        return (Optional<GetOrderLinks>) links;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
     */
    public GetOrderResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = Optional.ofNullable(resource);
        return this;
    }

    /**
     * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
     */
    public GetOrderResponseBody withResource(Optional<String> resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
     */
    public GetOrderResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
     */
    public GetOrderResponseBody withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    public GetOrderResponseBody withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = Optional.ofNullable(mode);
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    public GetOrderResponseBody withMode(Optional<String> mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    public GetOrderResponseBody withOrderNumber(String orderNumber) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        this.orderNumber = Optional.ofNullable(orderNumber);
        return this;
    }

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    public GetOrderResponseBody withOrderNumber(Optional<String> orderNumber) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        this.orderNumber = orderNumber;
        return this;
    }

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    public GetOrderResponseBody withLines(List<GetOrderLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = Optional.ofNullable(lines);
        return this;
    }

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    public GetOrderResponseBody withLines(Optional<? extends List<GetOrderLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    public GetOrderResponseBody withAmount(GetOrderAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    public GetOrderResponseBody withAmount(Optional<? extends GetOrderAmount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public GetOrderResponseBody withAmountRefunded(AmountRefunded amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = JsonNullable.of(amountRefunded);
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public GetOrderResponseBody withAmountRefunded(JsonNullable<? extends AmountRefunded> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * The total amount that is already captured for this order. Only available when this order supports captures.
     */
    public GetOrderResponseBody withAmountCaptured(AmountCaptured amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = JsonNullable.of(amountCaptured);
        return this;
    }

    /**
     * The total amount that is already captured for this order. Only available when this order supports captures.
     */
    public GetOrderResponseBody withAmountCaptured(JsonNullable<? extends AmountCaptured> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public GetOrderResponseBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public GetOrderResponseBody withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public GetOrderResponseBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public GetOrderResponseBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public GetOrderResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public GetOrderResponseBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    public GetOrderResponseBody withBillingAddress(GetOrderBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    public GetOrderResponseBody withBillingAddress(Optional<? extends GetOrderBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    public GetOrderResponseBody withShippingAddress(GetOrderShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    public GetOrderResponseBody withShippingAddress(Optional<? extends GetOrderShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    public GetOrderResponseBody withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = Optional.ofNullable(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    public GetOrderResponseBody withLocale(Optional<String> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    public GetOrderResponseBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    public GetOrderResponseBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    public GetOrderResponseBody withShopperCountryMustMatchBillingCountry(boolean shopperCountryMustMatchBillingCountry) {
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        this.shopperCountryMustMatchBillingCountry = Optional.ofNullable(shopperCountryMustMatchBillingCountry);
        return this;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    public GetOrderResponseBody withShopperCountryMustMatchBillingCountry(Optional<Boolean> shopperCountryMustMatchBillingCountry) {
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public GetOrderResponseBody withMetadata(GetOrderMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public GetOrderResponseBody withMetadata(JsonNullable<? extends GetOrderMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
     * 
     * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
     */
    public GetOrderResponseBody withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
     * 
     * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
     */
    public GetOrderResponseBody withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
     */
    public GetOrderResponseBody withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
     */
    public GetOrderResponseBody withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    public GetOrderResponseBody withPayment(GetOrderPayment payment) {
        Utils.checkNotNull(payment, "payment");
        this.payment = JsonNullable.of(payment);
        return this;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    public GetOrderResponseBody withPayment(JsonNullable<? extends GetOrderPayment> payment) {
        Utils.checkNotNull(payment, "payment");
        this.payment = payment;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public GetOrderResponseBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = JsonNullable.of(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public GetOrderResponseBody withProfileId(JsonNullable<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetOrderResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetOrderResponseBody withCreatedAt(Optional<String> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
     */
    public GetOrderResponseBody withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
     */
    public GetOrderResponseBody withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    public GetOrderResponseBody withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    public GetOrderResponseBody withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
     */
    public GetOrderResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
     */
    public GetOrderResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    public GetOrderResponseBody withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    public GetOrderResponseBody withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
     */
    public GetOrderResponseBody withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
     */
    public GetOrderResponseBody withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    public GetOrderResponseBody withCompletedAt(String completedAt) {
        Utils.checkNotNull(completedAt, "completedAt");
        this.completedAt = JsonNullable.of(completedAt);
        return this;
    }

    /**
     * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
     */
    public GetOrderResponseBody withCompletedAt(JsonNullable<String> completedAt) {
        Utils.checkNotNull(completedAt, "completedAt");
        this.completedAt = completedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetOrderResponseBody withLinks(GetOrderLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = Optional.ofNullable(links);
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetOrderResponseBody withLinks(Optional<? extends GetOrderLinks> links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetOrderResponseBody other = (GetOrderResponseBody) o;
        return 
            Objects.deepEquals(this.resource, other.resource) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.mode, other.mode) &&
            Objects.deepEquals(this.orderNumber, other.orderNumber) &&
            Objects.deepEquals(this.lines, other.lines) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.amountRefunded, other.amountRefunded) &&
            Objects.deepEquals(this.amountCaptured, other.amountCaptured) &&
            Objects.deepEquals(this.redirectUrl, other.redirectUrl) &&
            Objects.deepEquals(this.cancelUrl, other.cancelUrl) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.locale, other.locale) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.shopperCountryMustMatchBillingCountry, other.shopperCountryMustMatchBillingCountry) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.isCancelable, other.isCancelable) &&
            Objects.deepEquals(this.payment, other.payment) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.authorizedAt, other.authorizedAt) &&
            Objects.deepEquals(this.paidAt, other.paidAt) &&
            Objects.deepEquals(this.canceledAt, other.canceledAt) &&
            Objects.deepEquals(this.expiresAt, other.expiresAt) &&
            Objects.deepEquals(this.expiredAt, other.expiredAt) &&
            Objects.deepEquals(this.completedAt, other.completedAt) &&
            Objects.deepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            resource,
            id,
            mode,
            orderNumber,
            lines,
            amount,
            amountRefunded,
            amountCaptured,
            redirectUrl,
            cancelUrl,
            webhookUrl,
            billingAddress,
            shippingAddress,
            locale,
            method,
            shopperCountryMustMatchBillingCountry,
            metadata,
            status,
            isCancelable,
            payment,
            profileId,
            createdAt,
            authorizedAt,
            paidAt,
            canceledAt,
            expiresAt,
            expiredAt,
            completedAt,
            links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetOrderResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "orderNumber", orderNumber,
                "lines", lines,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountCaptured", amountCaptured,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "method", method,
                "shopperCountryMustMatchBillingCountry", shopperCountryMustMatchBillingCountry,
                "metadata", metadata,
                "status", status,
                "isCancelable", isCancelable,
                "payment", payment,
                "profileId", profileId,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "completedAt", completedAt,
                "links", links);
    }
    
    public final static class Builder {
 
        private Optional<String> resource;
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> mode = Optional.empty();
 
        private Optional<String> orderNumber = Optional.empty();
 
        private Optional<? extends List<GetOrderLines>> lines = Optional.empty();
 
        private Optional<? extends GetOrderAmount> amount = Optional.empty();
 
        private JsonNullable<? extends AmountRefunded> amountRefunded = JsonNullable.undefined();
 
        private JsonNullable<? extends AmountCaptured> amountCaptured = JsonNullable.undefined();
 
        private JsonNullable<String> redirectUrl = JsonNullable.undefined();
 
        private JsonNullable<String> cancelUrl = JsonNullable.undefined();
 
        private JsonNullable<String> webhookUrl = JsonNullable.undefined();
 
        private Optional<? extends GetOrderBillingAddress> billingAddress = Optional.empty();
 
        private Optional<? extends GetOrderShippingAddress> shippingAddress = Optional.empty();
 
        private Optional<String> locale = Optional.empty();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private Optional<Boolean> shopperCountryMustMatchBillingCountry = Optional.empty();
 
        private JsonNullable<? extends GetOrderMetadata> metadata = JsonNullable.undefined();
 
        private Optional<String> status = Optional.empty();
 
        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();
 
        private JsonNullable<? extends GetOrderPayment> payment = JsonNullable.undefined();
 
        private JsonNullable<String> profileId = JsonNullable.undefined();
 
        private Optional<String> createdAt = Optional.empty();
 
        private JsonNullable<String> authorizedAt = JsonNullable.undefined();
 
        private JsonNullable<String> paidAt = JsonNullable.undefined();
 
        private JsonNullable<String> canceledAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiresAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiredAt = JsonNullable.undefined();
 
        private JsonNullable<String> completedAt = JsonNullable.undefined();
 
        private Optional<? extends GetOrderLinks> links = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = Optional.ofNullable(resource);
            return this;
        }

        /**
         * Indicates the response contains an order object. Will always contain the string `order` for this endpoint.
         */
        public Builder resource(Optional<String> resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }

        /**
         * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The identifier uniquely referring to this order. Mollie assigns this identifier at payment creation time. Mollie will always refer to the order by this ID. Example: `ord_vsKJpSsabw`.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * Possible values: `live` `test`
         */
        public Builder mode(Optional<String> mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * The order number for this order. We recommend each order number to be unique.
         */
        public Builder orderNumber(String orderNumber) {
            Utils.checkNotNull(orderNumber, "orderNumber");
            this.orderNumber = Optional.ofNullable(orderNumber);
            return this;
        }

        /**
         * The order number for this order. We recommend each order number to be unique.
         */
        public Builder orderNumber(Optional<String> orderNumber) {
            Utils.checkNotNull(orderNumber, "orderNumber");
            this.orderNumber = orderNumber;
            return this;
        }

        /**
         * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
         * 
         * All lines must have the same currency as the payment.
         */
        public Builder lines(List<GetOrderLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = Optional.ofNullable(lines);
            return this;
        }

        /**
         * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
         * 
         * All lines must have the same currency as the payment.
         */
        public Builder lines(Optional<? extends List<GetOrderLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         */
        public Builder amount(GetOrderAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         */
        public Builder amount(Optional<? extends GetOrderAmount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(AmountRefunded amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = JsonNullable.of(amountRefunded);
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this order. For some payment methods, this amount may be higher than the order amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(JsonNullable<? extends AmountRefunded> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }

        /**
         * The total amount that is already captured for this order. Only available when this order supports captures.
         */
        public Builder amountCaptured(AmountCaptured amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = JsonNullable.of(amountCaptured);
            return this;
        }

        /**
         * The total amount that is already captured for this order. Only available when this order supports captures.
         */
        public Builder amountCaptured(JsonNullable<? extends AmountCaptured> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }

        /**
         * The webhook URL where we will send order status updates to.
         * 
         * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
         * 
         * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send order status updates to.
         * 
         * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
         * 
         * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
         */
        public Builder billingAddress(GetOrderBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
         */
        public Builder billingAddress(Optional<? extends GetOrderBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
         */
        public Builder shippingAddress(GetOrderShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
         */
        public Builder shippingAddress(Optional<? extends GetOrderShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         * 
         * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = Optional.ofNullable(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         * 
         * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
         */
        public Builder locale(Optional<String> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
         * 
         * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
         */
        public Builder shopperCountryMustMatchBillingCountry(boolean shopperCountryMustMatchBillingCountry) {
            Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
            this.shopperCountryMustMatchBillingCountry = Optional.ofNullable(shopperCountryMustMatchBillingCountry);
            return this;
        }

        /**
         * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
         * 
         * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
         */
        public Builder shopperCountryMustMatchBillingCountry(Optional<Boolean> shopperCountryMustMatchBillingCountry) {
            Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
            this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(GetOrderMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends GetOrderMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
         * 
         * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The order's status. Refer to the [documentation regarding statuses](order-status-changes) for more info about which statuses occur at what point.
         * 
         * Possible values: `created` `pending` `authorized` `paid` `shipping` `canceled` `expired` `completed`
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the order can be canceled. This parameter is omitted if the order reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }

        /**
         * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
         */
        public Builder payment(GetOrderPayment payment) {
            Utils.checkNotNull(payment, "payment");
            this.payment = JsonNullable.of(payment);
            return this;
        }

        /**
         * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
         */
        public Builder payment(JsonNullable<? extends GetOrderPayment> payment) {
            Utils.checkNotNull(payment, "payment");
            this.payment = payment;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = JsonNullable.of(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(JsonNullable<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(Optional<String> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the order became authorized, in ISO 8601 format. This parameter is omitted if the order is not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }

        /**
         * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the order became paid, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }

        /**
         * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the order was canceled, in ISO 8601 format. This parameter is omitted if the order is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }

        /**
         * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
         * 
         * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
         * 
         * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }

        /**
         * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the order was expired, in ISO 8601 format. This parameter is omitted if the order did not expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }

        /**
         * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
         */
        public Builder completedAt(String completedAt) {
            Utils.checkNotNull(completedAt, "completedAt");
            this.completedAt = JsonNullable.of(completedAt);
            return this;
        }

        /**
         * The date and time the order was completed, in ISO 8601 format. This parameter is omitted if the order is not completed (yet).
         */
        public Builder completedAt(JsonNullable<String> completedAt) {
            Utils.checkNotNull(completedAt, "completedAt");
            this.completedAt = completedAt;
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(GetOrderLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = Optional.ofNullable(links);
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(Optional<? extends GetOrderLinks> links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }
        
        public GetOrderResponseBody build() {
            if (resource == null) {
                resource = _SINGLETON_VALUE_Resource.value();
            }            return new GetOrderResponseBody(
                resource,
                id,
                mode,
                orderNumber,
                lines,
                amount,
                amountRefunded,
                amountCaptured,
                redirectUrl,
                cancelUrl,
                webhookUrl,
                billingAddress,
                shippingAddress,
                locale,
                method,
                shopperCountryMustMatchBillingCountry,
                metadata,
                status,
                isCancelable,
                payment,
                profileId,
                createdAt,
                authorizedAt,
                paidAt,
                canceledAt,
                expiresAt,
                expiredAt,
                completedAt,
                links);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Resource =
                new LazySingletonValue<>(
                        "resource",
                        "\"order\"",
                        new TypeReference<Optional<String>>() {});
    }
}

