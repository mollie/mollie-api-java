/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * CreatePaymentResponseBody
 * 
 * <p>The newly created payment object.
 */
public class CreatePaymentResponseBody {

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource")
    private Optional<String> resource;

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mode")
    private Optional<String> mode;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<String> description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends CreatePaymentPaymentsResponseAmount> amount;

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private JsonNullable<? extends CreatePaymentAmountRefunded> amountRefunded;

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private JsonNullable<? extends AmountRemaining> amountRemaining;

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private JsonNullable<? extends AmountCaptured> amountCaptured;

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private JsonNullable<? extends AmountChargedBack> amountChargedBack;

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private JsonNullable<? extends SettlementAmount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<CreatePaymentLines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends CreatePaymentBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends CreatePaymentShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<String> locale;

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    private JsonNullable<String> countryCode;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends CreatePaymentMetadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<String> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureBefore")
    private JsonNullable<String> captureBefore;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends CreatePaymentApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<CreatePaymentRouting>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sequenceType")
    private JsonNullable<String> sequenceType;

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private JsonNullable<String> subscriptionId;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private Optional<String> profileId;

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private JsonNullable<String> settlementId;

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private JsonNullable<String> orderId;

    /**
     * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusReason")
    private JsonNullable<? extends StatusReason> statusReason;

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    private JsonNullable<? extends Map<String, Object>> details;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<String> createdAt;

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("failedAt")
    private JsonNullable<String> failedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("_links")
    private Optional<? extends CreatePaymentLinks> links;

    @JsonCreator
    public CreatePaymentResponseBody(
            @JsonProperty("resource") Optional<String> resource,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("mode") Optional<String> mode,
            @JsonProperty("description") JsonNullable<String> description,
            @JsonProperty("amount") Optional<? extends CreatePaymentPaymentsResponseAmount> amount,
            @JsonProperty("amountRefunded") JsonNullable<? extends CreatePaymentAmountRefunded> amountRefunded,
            @JsonProperty("amountRemaining") JsonNullable<? extends AmountRemaining> amountRemaining,
            @JsonProperty("amountCaptured") JsonNullable<? extends AmountCaptured> amountCaptured,
            @JsonProperty("amountChargedBack") JsonNullable<? extends AmountChargedBack> amountChargedBack,
            @JsonProperty("settlementAmount") JsonNullable<? extends SettlementAmount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<CreatePaymentLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends CreatePaymentBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends CreatePaymentShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<String> locale,
            @JsonProperty("countryCode") JsonNullable<String> countryCode,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends CreatePaymentMetadata> metadata,
            @JsonProperty("captureMode") JsonNullable<String> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("captureBefore") JsonNullable<String> captureBefore,
            @JsonProperty("applicationFee") JsonNullable<? extends CreatePaymentApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<CreatePaymentRouting>> routing,
            @JsonProperty("sequenceType") JsonNullable<String> sequenceType,
            @JsonProperty("subscriptionId") JsonNullable<String> subscriptionId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") Optional<String> profileId,
            @JsonProperty("settlementId") JsonNullable<String> settlementId,
            @JsonProperty("orderId") JsonNullable<String> orderId,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("statusReason") JsonNullable<? extends StatusReason> statusReason,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("details") JsonNullable<? extends Map<String, Object>> details,
            @JsonProperty("createdAt") Optional<String> createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("failedAt") JsonNullable<String> failedAt,
            @JsonProperty("_links") Optional<? extends CreatePaymentLinks> links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(countryCode, "countryCode");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(captureBefore, "captureBefore");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusReason, "statusReason");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(details, "details");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(failedAt, "failedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.countryCode = countryCode;
        this.method = method;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.captureBefore = captureBefore;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.status = status;
        this.statusReason = statusReason;
        this.isCancelable = isCancelable;
        this.details = details;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.failedAt = failedAt;
        this.links = links;
    }
    
    public CreatePaymentResponseBody() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonIgnore
    public Optional<String> resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonIgnore
    public Optional<String> mode() {
        return mode;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public JsonNullable<String> description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatePaymentPaymentsResponseAmount> amount() {
        return (Optional<CreatePaymentPaymentsResponseAmount>) amount;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreatePaymentAmountRefunded> amountRefunded() {
        return (JsonNullable<CreatePaymentAmountRefunded>) amountRefunded;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmountRemaining> amountRemaining() {
        return (JsonNullable<AmountRemaining>) amountRemaining;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmountCaptured> amountCaptured() {
        return (JsonNullable<AmountCaptured>) amountCaptured;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmountChargedBack> amountChargedBack() {
        return (JsonNullable<AmountChargedBack>) amountChargedBack;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SettlementAmount> settlementAmount() {
        return (JsonNullable<SettlementAmount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreatePaymentLines>> lines() {
        return (JsonNullable<List<CreatePaymentLines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatePaymentBillingAddress> billingAddress() {
        return (Optional<CreatePaymentBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatePaymentShippingAddress> shippingAddress() {
        return (Optional<CreatePaymentShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonIgnore
    public JsonNullable<String> locale() {
        return locale;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonIgnore
    public JsonNullable<String> countryCode() {
        return countryCode;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreatePaymentMetadata> metadata() {
        return (JsonNullable<CreatePaymentMetadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonIgnore
    public JsonNullable<String> captureMode() {
        return captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> captureBefore() {
        return captureBefore;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreatePaymentApplicationFee> applicationFee() {
        return (JsonNullable<CreatePaymentApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreatePaymentRouting>> routing() {
        return (JsonNullable<List<CreatePaymentRouting>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonIgnore
    public JsonNullable<String> sequenceType() {
        return sequenceType;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonIgnore
    public JsonNullable<String> subscriptionId() {
        return subscriptionId;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public Optional<String> profileId() {
        return profileId;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonIgnore
    public JsonNullable<String> settlementId() {
        return settlementId;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonIgnore
    public JsonNullable<String> orderId() {
        return orderId;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<StatusReason> statusReason() {
        return (JsonNullable<StatusReason>) statusReason;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> details() {
        return (JsonNullable<Map<String, Object>>) details;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public Optional<String> createdAt() {
        return createdAt;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonIgnore
    public JsonNullable<String> failedAt() {
        return failedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreatePaymentLinks> links() {
        return (Optional<CreatePaymentLinks>) links;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    public CreatePaymentResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = Optional.ofNullable(resource);
        return this;
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    public CreatePaymentResponseBody withResource(Optional<String> resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    public CreatePaymentResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    public CreatePaymentResponseBody withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public CreatePaymentResponseBody withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = Optional.ofNullable(mode);
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public CreatePaymentResponseBody withMode(Optional<String> mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreatePaymentResponseBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = JsonNullable.of(description);
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreatePaymentResponseBody withDescription(JsonNullable<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    public CreatePaymentResponseBody withAmount(CreatePaymentPaymentsResponseAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    public CreatePaymentResponseBody withAmount(Optional<? extends CreatePaymentPaymentsResponseAmount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public CreatePaymentResponseBody withAmountRefunded(CreatePaymentAmountRefunded amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = JsonNullable.of(amountRefunded);
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public CreatePaymentResponseBody withAmountRefunded(JsonNullable<? extends CreatePaymentAmountRefunded> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public CreatePaymentResponseBody withAmountRemaining(AmountRemaining amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = JsonNullable.of(amountRemaining);
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public CreatePaymentResponseBody withAmountRemaining(JsonNullable<? extends AmountRemaining> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public CreatePaymentResponseBody withAmountCaptured(AmountCaptured amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = JsonNullable.of(amountCaptured);
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public CreatePaymentResponseBody withAmountCaptured(JsonNullable<? extends AmountCaptured> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public CreatePaymentResponseBody withAmountChargedBack(AmountChargedBack amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = JsonNullable.of(amountChargedBack);
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public CreatePaymentResponseBody withAmountChargedBack(JsonNullable<? extends AmountChargedBack> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public CreatePaymentResponseBody withSettlementAmount(SettlementAmount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = JsonNullable.of(settlementAmount);
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public CreatePaymentResponseBody withSettlementAmount(JsonNullable<? extends SettlementAmount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreatePaymentResponseBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreatePaymentResponseBody withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreatePaymentResponseBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreatePaymentResponseBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreatePaymentResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreatePaymentResponseBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreatePaymentResponseBody withLines(List<CreatePaymentLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreatePaymentResponseBody withLines(JsonNullable<? extends List<CreatePaymentLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreatePaymentResponseBody withBillingAddress(CreatePaymentBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreatePaymentResponseBody withBillingAddress(Optional<? extends CreatePaymentBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreatePaymentResponseBody withShippingAddress(CreatePaymentShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreatePaymentResponseBody withShippingAddress(Optional<? extends CreatePaymentShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreatePaymentResponseBody withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreatePaymentResponseBody withLocale(JsonNullable<String> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public CreatePaymentResponseBody withCountryCode(String countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = JsonNullable.of(countryCode);
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public CreatePaymentResponseBody withCountryCode(JsonNullable<String> countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = countryCode;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    public CreatePaymentResponseBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    public CreatePaymentResponseBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreatePaymentResponseBody withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreatePaymentResponseBody withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreatePaymentResponseBody withMetadata(CreatePaymentMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreatePaymentResponseBody withMetadata(JsonNullable<? extends CreatePaymentMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreatePaymentResponseBody withCaptureMode(String captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreatePaymentResponseBody withCaptureMode(JsonNullable<String> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreatePaymentResponseBody withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreatePaymentResponseBody withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public CreatePaymentResponseBody withCaptureBefore(String captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = JsonNullable.of(captureBefore);
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public CreatePaymentResponseBody withCaptureBefore(JsonNullable<String> captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = captureBefore;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreatePaymentResponseBody withApplicationFee(CreatePaymentApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreatePaymentResponseBody withApplicationFee(JsonNullable<? extends CreatePaymentApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreatePaymentResponseBody withRouting(List<CreatePaymentRouting> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreatePaymentResponseBody withRouting(JsonNullable<? extends List<CreatePaymentRouting>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreatePaymentResponseBody withSequenceType(String sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = JsonNullable.of(sequenceType);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreatePaymentResponseBody withSequenceType(JsonNullable<String> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public CreatePaymentResponseBody withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = JsonNullable.of(subscriptionId);
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public CreatePaymentResponseBody withSubscriptionId(JsonNullable<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreatePaymentResponseBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreatePaymentResponseBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreatePaymentResponseBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreatePaymentResponseBody withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreatePaymentResponseBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = Optional.ofNullable(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreatePaymentResponseBody withProfileId(Optional<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public CreatePaymentResponseBody withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = JsonNullable.of(settlementId);
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public CreatePaymentResponseBody withSettlementId(JsonNullable<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public CreatePaymentResponseBody withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = JsonNullable.of(orderId);
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public CreatePaymentResponseBody withOrderId(JsonNullable<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    public CreatePaymentResponseBody withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    public CreatePaymentResponseBody withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public CreatePaymentResponseBody withStatusReason(StatusReason statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = JsonNullable.of(statusReason);
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public CreatePaymentResponseBody withStatusReason(JsonNullable<? extends StatusReason> statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = statusReason;
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public CreatePaymentResponseBody withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public CreatePaymentResponseBody withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public CreatePaymentResponseBody withDetails(Map<String, Object> details) {
        Utils.checkNotNull(details, "details");
        this.details = JsonNullable.of(details);
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public CreatePaymentResponseBody withDetails(JsonNullable<? extends Map<String, Object>> details) {
        Utils.checkNotNull(details, "details");
        this.details = details;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public CreatePaymentResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public CreatePaymentResponseBody withCreatedAt(Optional<String> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public CreatePaymentResponseBody withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public CreatePaymentResponseBody withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public CreatePaymentResponseBody withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public CreatePaymentResponseBody withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public CreatePaymentResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public CreatePaymentResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public CreatePaymentResponseBody withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public CreatePaymentResponseBody withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public CreatePaymentResponseBody withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public CreatePaymentResponseBody withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public CreatePaymentResponseBody withFailedAt(String failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = JsonNullable.of(failedAt);
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public CreatePaymentResponseBody withFailedAt(JsonNullable<String> failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = failedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public CreatePaymentResponseBody withLinks(CreatePaymentLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = Optional.ofNullable(links);
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public CreatePaymentResponseBody withLinks(Optional<? extends CreatePaymentLinks> links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreatePaymentResponseBody other = (CreatePaymentResponseBody) o;
        return 
            Objects.deepEquals(this.resource, other.resource) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.mode, other.mode) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.amountRefunded, other.amountRefunded) &&
            Objects.deepEquals(this.amountRemaining, other.amountRemaining) &&
            Objects.deepEquals(this.amountCaptured, other.amountCaptured) &&
            Objects.deepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Objects.deepEquals(this.settlementAmount, other.settlementAmount) &&
            Objects.deepEquals(this.redirectUrl, other.redirectUrl) &&
            Objects.deepEquals(this.cancelUrl, other.cancelUrl) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.lines, other.lines) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.locale, other.locale) &&
            Objects.deepEquals(this.countryCode, other.countryCode) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.captureMode, other.captureMode) &&
            Objects.deepEquals(this.captureDelay, other.captureDelay) &&
            Objects.deepEquals(this.captureBefore, other.captureBefore) &&
            Objects.deepEquals(this.applicationFee, other.applicationFee) &&
            Objects.deepEquals(this.routing, other.routing) &&
            Objects.deepEquals(this.sequenceType, other.sequenceType) &&
            Objects.deepEquals(this.subscriptionId, other.subscriptionId) &&
            Objects.deepEquals(this.mandateId, other.mandateId) &&
            Objects.deepEquals(this.customerId, other.customerId) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.settlementId, other.settlementId) &&
            Objects.deepEquals(this.orderId, other.orderId) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.statusReason, other.statusReason) &&
            Objects.deepEquals(this.isCancelable, other.isCancelable) &&
            Objects.deepEquals(this.details, other.details) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.authorizedAt, other.authorizedAt) &&
            Objects.deepEquals(this.paidAt, other.paidAt) &&
            Objects.deepEquals(this.canceledAt, other.canceledAt) &&
            Objects.deepEquals(this.expiresAt, other.expiresAt) &&
            Objects.deepEquals(this.expiredAt, other.expiredAt) &&
            Objects.deepEquals(this.failedAt, other.failedAt) &&
            Objects.deepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            resource,
            id,
            mode,
            description,
            amount,
            amountRefunded,
            amountRemaining,
            amountCaptured,
            amountChargedBack,
            settlementAmount,
            redirectUrl,
            cancelUrl,
            webhookUrl,
            lines,
            billingAddress,
            shippingAddress,
            locale,
            countryCode,
            method,
            restrictPaymentMethodsToCountry,
            metadata,
            captureMode,
            captureDelay,
            captureBefore,
            applicationFee,
            routing,
            sequenceType,
            subscriptionId,
            mandateId,
            customerId,
            profileId,
            settlementId,
            orderId,
            status,
            statusReason,
            isCancelable,
            details,
            createdAt,
            authorizedAt,
            paidAt,
            canceledAt,
            expiresAt,
            expiredAt,
            failedAt,
            links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreatePaymentResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "countryCode", countryCode,
                "method", method,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "captureBefore", captureBefore,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "status", status,
                "statusReason", statusReason,
                "isCancelable", isCancelable,
                "details", details,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "failedAt", failedAt,
                "links", links);
    }
    
    public final static class Builder {
 
        private Optional<String> resource;
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> mode = Optional.empty();
 
        private JsonNullable<String> description = JsonNullable.undefined();
 
        private Optional<? extends CreatePaymentPaymentsResponseAmount> amount = Optional.empty();
 
        private JsonNullable<? extends CreatePaymentAmountRefunded> amountRefunded = JsonNullable.undefined();
 
        private JsonNullable<? extends AmountRemaining> amountRemaining = JsonNullable.undefined();
 
        private JsonNullable<? extends AmountCaptured> amountCaptured = JsonNullable.undefined();
 
        private JsonNullable<? extends AmountChargedBack> amountChargedBack = JsonNullable.undefined();
 
        private JsonNullable<? extends SettlementAmount> settlementAmount = JsonNullable.undefined();
 
        private JsonNullable<String> redirectUrl = JsonNullable.undefined();
 
        private JsonNullable<String> cancelUrl = JsonNullable.undefined();
 
        private JsonNullable<String> webhookUrl = JsonNullable.undefined();
 
        private JsonNullable<? extends List<CreatePaymentLines>> lines = JsonNullable.undefined();
 
        private Optional<? extends CreatePaymentBillingAddress> billingAddress = Optional.empty();
 
        private Optional<? extends CreatePaymentShippingAddress> shippingAddress = Optional.empty();
 
        private JsonNullable<String> locale = JsonNullable.undefined();
 
        private JsonNullable<String> countryCode = JsonNullable.undefined();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();
 
        private JsonNullable<? extends CreatePaymentMetadata> metadata = JsonNullable.undefined();
 
        private JsonNullable<String> captureMode = JsonNullable.undefined();
 
        private JsonNullable<String> captureDelay = JsonNullable.undefined();
 
        private JsonNullable<String> captureBefore = JsonNullable.undefined();
 
        private JsonNullable<? extends CreatePaymentApplicationFee> applicationFee = JsonNullable.undefined();
 
        private JsonNullable<? extends List<CreatePaymentRouting>> routing = JsonNullable.undefined();
 
        private JsonNullable<String> sequenceType = JsonNullable.undefined();
 
        private JsonNullable<String> subscriptionId = JsonNullable.undefined();
 
        private JsonNullable<String> mandateId = JsonNullable.undefined();
 
        private JsonNullable<String> customerId = JsonNullable.undefined();
 
        private Optional<String> profileId = Optional.empty();
 
        private JsonNullable<String> settlementId = JsonNullable.undefined();
 
        private JsonNullable<String> orderId = JsonNullable.undefined();
 
        private Optional<String> status = Optional.empty();
 
        private JsonNullable<? extends StatusReason> statusReason = JsonNullable.undefined();
 
        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, Object>> details = JsonNullable.undefined();
 
        private Optional<String> createdAt = Optional.empty();
 
        private JsonNullable<String> authorizedAt = JsonNullable.undefined();
 
        private JsonNullable<String> paidAt = JsonNullable.undefined();
 
        private JsonNullable<String> canceledAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiresAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiredAt = JsonNullable.undefined();
 
        private JsonNullable<String> failedAt = JsonNullable.undefined();
 
        private Optional<? extends CreatePaymentLinks> links = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = Optional.ofNullable(resource);
            return this;
        }

        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
         */
        public Builder resource(Optional<String> resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }

        /**
         * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(Optional<String> mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(JsonNullable<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
         */
        public Builder amount(CreatePaymentPaymentsResponseAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
         */
        public Builder amount(Optional<? extends CreatePaymentPaymentsResponseAmount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(CreatePaymentAmountRefunded amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = JsonNullable.of(amountRefunded);
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(JsonNullable<? extends CreatePaymentAmountRefunded> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(AmountRemaining amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = JsonNullable.of(amountRemaining);
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(JsonNullable<? extends AmountRemaining> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(AmountCaptured amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = JsonNullable.of(amountCaptured);
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(JsonNullable<? extends AmountCaptured> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(AmountChargedBack amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = JsonNullable.of(amountChargedBack);
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(JsonNullable<? extends AmountChargedBack> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(SettlementAmount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = JsonNullable.of(settlementAmount);
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(JsonNullable<? extends SettlementAmount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<CreatePaymentLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<CreatePaymentLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(CreatePaymentBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends CreatePaymentBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(CreatePaymentShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(Optional<? extends CreatePaymentShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<String> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(String countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = JsonNullable.of(countryCode);
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(JsonNullable<String> countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = countryCode;
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(CreatePaymentMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends CreatePaymentMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(String captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](place-a-hold-for-a-payment) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(JsonNullable<String> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(String captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = JsonNullable.of(captureBefore);
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(JsonNullable<String> captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = captureBefore;
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(CreatePaymentApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends CreatePaymentApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(List<CreatePaymentRouting> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(JsonNullable<? extends List<CreatePaymentRouting>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(String sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = JsonNullable.of(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(JsonNullable<String> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = JsonNullable.of(subscriptionId);
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(JsonNullable<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = Optional.ofNullable(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(Optional<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = JsonNullable.of(settlementId);
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(JsonNullable<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = JsonNullable.of(orderId);
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(JsonNullable<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }

        /**
         * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
         * 
         * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The payment's status. Refer to the [documentation regarding statuses](status-change) for more info about which statuses occur at what point.
         * 
         * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(StatusReason statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = JsonNullable.of(statusReason);
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(JsonNullable<? extends StatusReason> statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = statusReason;
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(Map<String, Object> details) {
            Utils.checkNotNull(details, "details");
            this.details = JsonNullable.of(details);
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(JsonNullable<? extends Map<String, Object>> details) {
            Utils.checkNotNull(details, "details");
            this.details = details;
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(Optional<String> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(String failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = JsonNullable.of(failedAt);
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(JsonNullable<String> failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = failedAt;
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(CreatePaymentLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = Optional.ofNullable(links);
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(Optional<? extends CreatePaymentLinks> links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }
        
        public CreatePaymentResponseBody build() {
            if (resource == null) {
                resource = _SINGLETON_VALUE_Resource.value();
            }
            return new CreatePaymentResponseBody(
                resource,
                id,
                mode,
                description,
                amount,
                amountRefunded,
                amountRemaining,
                amountCaptured,
                amountChargedBack,
                settlementAmount,
                redirectUrl,
                cancelUrl,
                webhookUrl,
                lines,
                billingAddress,
                shippingAddress,
                locale,
                countryCode,
                method,
                restrictPaymentMethodsToCountry,
                metadata,
                captureMode,
                captureDelay,
                captureBefore,
                applicationFee,
                routing,
                sequenceType,
                subscriptionId,
                mandateId,
                customerId,
                profileId,
                settlementId,
                orderId,
                status,
                statusReason,
                isCancelable,
                details,
                createdAt,
                authorizedAt,
                paidAt,
                canceledAt,
                expiresAt,
                expiredAt,
                failedAt,
                links);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Resource =
                new LazySingletonValue<>(
                        "resource",
                        "\"payment\"",
                        new TypeReference<Optional<String>>() {});
    }
}
