/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class ListSubscriptionPaymentsPayments {

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonProperty("resource")
    private String resource;

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonProperty("id")
    private String id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonProperty("mode")
    private String mode;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonProperty("description")
    private String description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonProperty("amount")
    private ListSubscriptionPaymentsAmount amount;

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private Optional<? extends ListSubscriptionPaymentsAmountRefunded> amountRefunded;

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private Optional<? extends ListSubscriptionPaymentsAmountRemaining> amountRemaining;

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private Optional<? extends ListSubscriptionPaymentsAmountCaptured> amountCaptured;

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private Optional<? extends ListSubscriptionPaymentsAmountChargedBack> amountChargedBack;

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private Optional<? extends ListSubscriptionPaymentsSettlementAmount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<ListSubscriptionPaymentsLines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends ListSubscriptionPaymentsBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends ListSubscriptionPaymentsShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<String> locale;

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    private JsonNullable<String> countryCode;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends ListSubscriptionPaymentsMetadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<String> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureBefore")
    private JsonNullable<String> captureBefore;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends ListSubscriptionPaymentsApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<ListSubscriptionPaymentsRouting>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("sequenceType")
    private Optional<String> sequenceType;

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private JsonNullable<String> subscriptionId;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonProperty("profileId")
    private String profileId;

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private JsonNullable<String> settlementId;

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private JsonNullable<String> orderId;

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonProperty("status")
    private String status;

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusReason")
    private JsonNullable<? extends ListSubscriptionPaymentsStatusReason> statusReason;

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    private JsonNullable<? extends Map<String, Object>> details;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonProperty("createdAt")
    private String createdAt;

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("failedAt")
    private JsonNullable<String> failedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonProperty("_links")
    private ListSubscriptionPaymentsSubscriptionsLinks links;

    @JsonCreator
    public ListSubscriptionPaymentsPayments(
            @JsonProperty("resource") String resource,
            @JsonProperty("id") String id,
            @JsonProperty("mode") String mode,
            @JsonProperty("description") String description,
            @JsonProperty("amount") ListSubscriptionPaymentsAmount amount,
            @JsonProperty("amountRefunded") Optional<? extends ListSubscriptionPaymentsAmountRefunded> amountRefunded,
            @JsonProperty("amountRemaining") Optional<? extends ListSubscriptionPaymentsAmountRemaining> amountRemaining,
            @JsonProperty("amountCaptured") Optional<? extends ListSubscriptionPaymentsAmountCaptured> amountCaptured,
            @JsonProperty("amountChargedBack") Optional<? extends ListSubscriptionPaymentsAmountChargedBack> amountChargedBack,
            @JsonProperty("settlementAmount") Optional<? extends ListSubscriptionPaymentsSettlementAmount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<ListSubscriptionPaymentsLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends ListSubscriptionPaymentsBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends ListSubscriptionPaymentsShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<String> locale,
            @JsonProperty("countryCode") JsonNullable<String> countryCode,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends ListSubscriptionPaymentsMetadata> metadata,
            @JsonProperty("captureMode") JsonNullable<String> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("captureBefore") JsonNullable<String> captureBefore,
            @JsonProperty("applicationFee") JsonNullable<? extends ListSubscriptionPaymentsApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<ListSubscriptionPaymentsRouting>> routing,
            @JsonProperty("sequenceType") Optional<String> sequenceType,
            @JsonProperty("subscriptionId") JsonNullable<String> subscriptionId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") String profileId,
            @JsonProperty("settlementId") JsonNullable<String> settlementId,
            @JsonProperty("orderId") JsonNullable<String> orderId,
            @JsonProperty("status") String status,
            @JsonProperty("statusReason") JsonNullable<? extends ListSubscriptionPaymentsStatusReason> statusReason,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("details") JsonNullable<? extends Map<String, Object>> details,
            @JsonProperty("createdAt") String createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("failedAt") JsonNullable<String> failedAt,
            @JsonProperty("_links") ListSubscriptionPaymentsSubscriptionsLinks links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(countryCode, "countryCode");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(captureBefore, "captureBefore");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusReason, "statusReason");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(details, "details");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(failedAt, "failedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.countryCode = countryCode;
        this.method = method;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.captureBefore = captureBefore;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.status = status;
        this.statusReason = statusReason;
        this.isCancelable = isCancelable;
        this.details = details;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.failedAt = failedAt;
        this.links = links;
    }
    
    public ListSubscriptionPaymentsPayments(
            String resource,
            String id,
            String mode,
            String description,
            ListSubscriptionPaymentsAmount amount,
            String profileId,
            String status,
            String createdAt,
            ListSubscriptionPaymentsSubscriptionsLinks links) {
        this(resource, id, mode, description, amount, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), profileId, JsonNullable.undefined(), JsonNullable.undefined(), status, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), createdAt, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), links);
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonIgnore
    public String resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonIgnore
    public String mode() {
        return mode;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonIgnore
    public ListSubscriptionPaymentsAmount amount() {
        return amount;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsAmountRefunded> amountRefunded() {
        return (Optional<ListSubscriptionPaymentsAmountRefunded>) amountRefunded;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsAmountRemaining> amountRemaining() {
        return (Optional<ListSubscriptionPaymentsAmountRemaining>) amountRemaining;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsAmountCaptured> amountCaptured() {
        return (Optional<ListSubscriptionPaymentsAmountCaptured>) amountCaptured;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsAmountChargedBack> amountChargedBack() {
        return (Optional<ListSubscriptionPaymentsAmountChargedBack>) amountChargedBack;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsSettlementAmount> settlementAmount() {
        return (Optional<ListSubscriptionPaymentsSettlementAmount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<ListSubscriptionPaymentsLines>> lines() {
        return (JsonNullable<List<ListSubscriptionPaymentsLines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsBillingAddress> billingAddress() {
        return (Optional<ListSubscriptionPaymentsBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListSubscriptionPaymentsShippingAddress> shippingAddress() {
        return (Optional<ListSubscriptionPaymentsShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonIgnore
    public JsonNullable<String> locale() {
        return locale;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonIgnore
    public JsonNullable<String> countryCode() {
        return countryCode;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListSubscriptionPaymentsMetadata> metadata() {
        return (JsonNullable<ListSubscriptionPaymentsMetadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonIgnore
    public JsonNullable<String> captureMode() {
        return captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> captureBefore() {
        return captureBefore;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListSubscriptionPaymentsApplicationFee> applicationFee() {
        return (JsonNullable<ListSubscriptionPaymentsApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<ListSubscriptionPaymentsRouting>> routing() {
        return (JsonNullable<List<ListSubscriptionPaymentsRouting>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonIgnore
    public Optional<String> sequenceType() {
        return sequenceType;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonIgnore
    public JsonNullable<String> subscriptionId() {
        return subscriptionId;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public String profileId() {
        return profileId;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonIgnore
    public JsonNullable<String> settlementId() {
        return settlementId;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonIgnore
    public JsonNullable<String> orderId() {
        return orderId;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonIgnore
    public String status() {
        return status;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListSubscriptionPaymentsStatusReason> statusReason() {
        return (JsonNullable<ListSubscriptionPaymentsStatusReason>) statusReason;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> details() {
        return (JsonNullable<Map<String, Object>>) details;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public String createdAt() {
        return createdAt;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonIgnore
    public JsonNullable<String> failedAt() {
        return failedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonIgnore
    public ListSubscriptionPaymentsSubscriptionsLinks links() {
        return links;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    public ListSubscriptionPaymentsPayments withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    public ListSubscriptionPaymentsPayments withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public ListSubscriptionPaymentsPayments withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public ListSubscriptionPaymentsPayments withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    public ListSubscriptionPaymentsPayments withAmount(ListSubscriptionPaymentsAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public ListSubscriptionPaymentsPayments withAmountRefunded(ListSubscriptionPaymentsAmountRefunded amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = Optional.ofNullable(amountRefunded);
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public ListSubscriptionPaymentsPayments withAmountRefunded(Optional<? extends ListSubscriptionPaymentsAmountRefunded> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public ListSubscriptionPaymentsPayments withAmountRemaining(ListSubscriptionPaymentsAmountRemaining amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = Optional.ofNullable(amountRemaining);
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public ListSubscriptionPaymentsPayments withAmountRemaining(Optional<? extends ListSubscriptionPaymentsAmountRemaining> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public ListSubscriptionPaymentsPayments withAmountCaptured(ListSubscriptionPaymentsAmountCaptured amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = Optional.ofNullable(amountCaptured);
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public ListSubscriptionPaymentsPayments withAmountCaptured(Optional<? extends ListSubscriptionPaymentsAmountCaptured> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public ListSubscriptionPaymentsPayments withAmountChargedBack(ListSubscriptionPaymentsAmountChargedBack amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = Optional.ofNullable(amountChargedBack);
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public ListSubscriptionPaymentsPayments withAmountChargedBack(Optional<? extends ListSubscriptionPaymentsAmountChargedBack> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public ListSubscriptionPaymentsPayments withSettlementAmount(ListSubscriptionPaymentsSettlementAmount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = Optional.ofNullable(settlementAmount);
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public ListSubscriptionPaymentsPayments withSettlementAmount(Optional<? extends ListSubscriptionPaymentsSettlementAmount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public ListSubscriptionPaymentsPayments withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public ListSubscriptionPaymentsPayments withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public ListSubscriptionPaymentsPayments withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public ListSubscriptionPaymentsPayments withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public ListSubscriptionPaymentsPayments withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public ListSubscriptionPaymentsPayments withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public ListSubscriptionPaymentsPayments withLines(List<ListSubscriptionPaymentsLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public ListSubscriptionPaymentsPayments withLines(JsonNullable<? extends List<ListSubscriptionPaymentsLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public ListSubscriptionPaymentsPayments withBillingAddress(ListSubscriptionPaymentsBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public ListSubscriptionPaymentsPayments withBillingAddress(Optional<? extends ListSubscriptionPaymentsBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public ListSubscriptionPaymentsPayments withShippingAddress(ListSubscriptionPaymentsShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public ListSubscriptionPaymentsPayments withShippingAddress(Optional<? extends ListSubscriptionPaymentsShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public ListSubscriptionPaymentsPayments withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public ListSubscriptionPaymentsPayments withLocale(JsonNullable<String> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public ListSubscriptionPaymentsPayments withCountryCode(String countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = JsonNullable.of(countryCode);
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public ListSubscriptionPaymentsPayments withCountryCode(JsonNullable<String> countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = countryCode;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    public ListSubscriptionPaymentsPayments withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
     */
    public ListSubscriptionPaymentsPayments withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public ListSubscriptionPaymentsPayments withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public ListSubscriptionPaymentsPayments withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public ListSubscriptionPaymentsPayments withMetadata(ListSubscriptionPaymentsMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public ListSubscriptionPaymentsPayments withMetadata(JsonNullable<? extends ListSubscriptionPaymentsMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public ListSubscriptionPaymentsPayments withCaptureMode(String captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public ListSubscriptionPaymentsPayments withCaptureMode(JsonNullable<String> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public ListSubscriptionPaymentsPayments withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public ListSubscriptionPaymentsPayments withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public ListSubscriptionPaymentsPayments withCaptureBefore(String captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = JsonNullable.of(captureBefore);
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public ListSubscriptionPaymentsPayments withCaptureBefore(JsonNullable<String> captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = captureBefore;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public ListSubscriptionPaymentsPayments withApplicationFee(ListSubscriptionPaymentsApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public ListSubscriptionPaymentsPayments withApplicationFee(JsonNullable<? extends ListSubscriptionPaymentsApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public ListSubscriptionPaymentsPayments withRouting(List<ListSubscriptionPaymentsRouting> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public ListSubscriptionPaymentsPayments withRouting(JsonNullable<? extends List<ListSubscriptionPaymentsRouting>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public ListSubscriptionPaymentsPayments withSequenceType(String sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = Optional.ofNullable(sequenceType);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public ListSubscriptionPaymentsPayments withSequenceType(Optional<String> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public ListSubscriptionPaymentsPayments withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = JsonNullable.of(subscriptionId);
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public ListSubscriptionPaymentsPayments withSubscriptionId(JsonNullable<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public ListSubscriptionPaymentsPayments withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public ListSubscriptionPaymentsPayments withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public ListSubscriptionPaymentsPayments withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public ListSubscriptionPaymentsPayments withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public ListSubscriptionPaymentsPayments withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public ListSubscriptionPaymentsPayments withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = JsonNullable.of(settlementId);
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public ListSubscriptionPaymentsPayments withSettlementId(JsonNullable<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public ListSubscriptionPaymentsPayments withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = JsonNullable.of(orderId);
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public ListSubscriptionPaymentsPayments withOrderId(JsonNullable<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    public ListSubscriptionPaymentsPayments withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public ListSubscriptionPaymentsPayments withStatusReason(ListSubscriptionPaymentsStatusReason statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = JsonNullable.of(statusReason);
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public ListSubscriptionPaymentsPayments withStatusReason(JsonNullable<? extends ListSubscriptionPaymentsStatusReason> statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = statusReason;
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public ListSubscriptionPaymentsPayments withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public ListSubscriptionPaymentsPayments withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public ListSubscriptionPaymentsPayments withDetails(Map<String, Object> details) {
        Utils.checkNotNull(details, "details");
        this.details = JsonNullable.of(details);
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public ListSubscriptionPaymentsPayments withDetails(JsonNullable<? extends Map<String, Object>> details) {
        Utils.checkNotNull(details, "details");
        this.details = details;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public ListSubscriptionPaymentsPayments withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public ListSubscriptionPaymentsPayments withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public ListSubscriptionPaymentsPayments withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public ListSubscriptionPaymentsPayments withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public ListSubscriptionPaymentsPayments withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public ListSubscriptionPaymentsPayments withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public ListSubscriptionPaymentsPayments withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public ListSubscriptionPaymentsPayments withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public ListSubscriptionPaymentsPayments withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public ListSubscriptionPaymentsPayments withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public ListSubscriptionPaymentsPayments withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public ListSubscriptionPaymentsPayments withFailedAt(String failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = JsonNullable.of(failedAt);
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public ListSubscriptionPaymentsPayments withFailedAt(JsonNullable<String> failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = failedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public ListSubscriptionPaymentsPayments withLinks(ListSubscriptionPaymentsSubscriptionsLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ListSubscriptionPaymentsPayments other = (ListSubscriptionPaymentsPayments) o;
        return 
            Objects.deepEquals(this.resource, other.resource) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.mode, other.mode) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.amountRefunded, other.amountRefunded) &&
            Objects.deepEquals(this.amountRemaining, other.amountRemaining) &&
            Objects.deepEquals(this.amountCaptured, other.amountCaptured) &&
            Objects.deepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Objects.deepEquals(this.settlementAmount, other.settlementAmount) &&
            Objects.deepEquals(this.redirectUrl, other.redirectUrl) &&
            Objects.deepEquals(this.cancelUrl, other.cancelUrl) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.lines, other.lines) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.locale, other.locale) &&
            Objects.deepEquals(this.countryCode, other.countryCode) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.captureMode, other.captureMode) &&
            Objects.deepEquals(this.captureDelay, other.captureDelay) &&
            Objects.deepEquals(this.captureBefore, other.captureBefore) &&
            Objects.deepEquals(this.applicationFee, other.applicationFee) &&
            Objects.deepEquals(this.routing, other.routing) &&
            Objects.deepEquals(this.sequenceType, other.sequenceType) &&
            Objects.deepEquals(this.subscriptionId, other.subscriptionId) &&
            Objects.deepEquals(this.mandateId, other.mandateId) &&
            Objects.deepEquals(this.customerId, other.customerId) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.settlementId, other.settlementId) &&
            Objects.deepEquals(this.orderId, other.orderId) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.statusReason, other.statusReason) &&
            Objects.deepEquals(this.isCancelable, other.isCancelable) &&
            Objects.deepEquals(this.details, other.details) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.authorizedAt, other.authorizedAt) &&
            Objects.deepEquals(this.paidAt, other.paidAt) &&
            Objects.deepEquals(this.canceledAt, other.canceledAt) &&
            Objects.deepEquals(this.expiresAt, other.expiresAt) &&
            Objects.deepEquals(this.expiredAt, other.expiredAt) &&
            Objects.deepEquals(this.failedAt, other.failedAt) &&
            Objects.deepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            resource,
            id,
            mode,
            description,
            amount,
            amountRefunded,
            amountRemaining,
            amountCaptured,
            amountChargedBack,
            settlementAmount,
            redirectUrl,
            cancelUrl,
            webhookUrl,
            lines,
            billingAddress,
            shippingAddress,
            locale,
            countryCode,
            method,
            restrictPaymentMethodsToCountry,
            metadata,
            captureMode,
            captureDelay,
            captureBefore,
            applicationFee,
            routing,
            sequenceType,
            subscriptionId,
            mandateId,
            customerId,
            profileId,
            settlementId,
            orderId,
            status,
            statusReason,
            isCancelable,
            details,
            createdAt,
            authorizedAt,
            paidAt,
            canceledAt,
            expiresAt,
            expiredAt,
            failedAt,
            links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ListSubscriptionPaymentsPayments.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "countryCode", countryCode,
                "method", method,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "captureBefore", captureBefore,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "status", status,
                "statusReason", statusReason,
                "isCancelable", isCancelable,
                "details", details,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "failedAt", failedAt,
                "links", links);
    }
    
    public final static class Builder {
 
        private String resource;
 
        private String id;
 
        private String mode;
 
        private String description;
 
        private ListSubscriptionPaymentsAmount amount;
 
        private Optional<? extends ListSubscriptionPaymentsAmountRefunded> amountRefunded = Optional.empty();
 
        private Optional<? extends ListSubscriptionPaymentsAmountRemaining> amountRemaining = Optional.empty();
 
        private Optional<? extends ListSubscriptionPaymentsAmountCaptured> amountCaptured = Optional.empty();
 
        private Optional<? extends ListSubscriptionPaymentsAmountChargedBack> amountChargedBack = Optional.empty();
 
        private Optional<? extends ListSubscriptionPaymentsSettlementAmount> settlementAmount = Optional.empty();
 
        private JsonNullable<String> redirectUrl = JsonNullable.undefined();
 
        private JsonNullable<String> cancelUrl = JsonNullable.undefined();
 
        private JsonNullable<String> webhookUrl = JsonNullable.undefined();
 
        private JsonNullable<? extends List<ListSubscriptionPaymentsLines>> lines = JsonNullable.undefined();
 
        private Optional<? extends ListSubscriptionPaymentsBillingAddress> billingAddress = Optional.empty();
 
        private Optional<? extends ListSubscriptionPaymentsShippingAddress> shippingAddress = Optional.empty();
 
        private JsonNullable<String> locale = JsonNullable.undefined();
 
        private JsonNullable<String> countryCode = JsonNullable.undefined();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();
 
        private JsonNullable<? extends ListSubscriptionPaymentsMetadata> metadata = JsonNullable.undefined();
 
        private JsonNullable<String> captureMode = JsonNullable.undefined();
 
        private JsonNullable<String> captureDelay = JsonNullable.undefined();
 
        private JsonNullable<String> captureBefore = JsonNullable.undefined();
 
        private JsonNullable<? extends ListSubscriptionPaymentsApplicationFee> applicationFee = JsonNullable.undefined();
 
        private JsonNullable<? extends List<ListSubscriptionPaymentsRouting>> routing = JsonNullable.undefined();
 
        private Optional<String> sequenceType = Optional.empty();
 
        private JsonNullable<String> subscriptionId = JsonNullable.undefined();
 
        private JsonNullable<String> mandateId = JsonNullable.undefined();
 
        private JsonNullable<String> customerId = JsonNullable.undefined();
 
        private String profileId;
 
        private JsonNullable<String> settlementId = JsonNullable.undefined();
 
        private JsonNullable<String> orderId = JsonNullable.undefined();
 
        private String status;
 
        private JsonNullable<? extends ListSubscriptionPaymentsStatusReason> statusReason = JsonNullable.undefined();
 
        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, Object>> details = JsonNullable.undefined();
 
        private String createdAt;
 
        private JsonNullable<String> authorizedAt = JsonNullable.undefined();
 
        private JsonNullable<String> paidAt = JsonNullable.undefined();
 
        private JsonNullable<String> canceledAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiresAt = JsonNullable.undefined();
 
        private JsonNullable<String> expiredAt = JsonNullable.undefined();
 
        private JsonNullable<String> failedAt = JsonNullable.undefined();
 
        private ListSubscriptionPaymentsSubscriptionsLinks links;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }

        /**
         * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
         */
        public Builder amount(ListSubscriptionPaymentsAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(ListSubscriptionPaymentsAmountRefunded amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = Optional.ofNullable(amountRefunded);
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(Optional<? extends ListSubscriptionPaymentsAmountRefunded> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(ListSubscriptionPaymentsAmountRemaining amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = Optional.ofNullable(amountRemaining);
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(Optional<? extends ListSubscriptionPaymentsAmountRemaining> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(ListSubscriptionPaymentsAmountCaptured amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = Optional.ofNullable(amountCaptured);
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(Optional<? extends ListSubscriptionPaymentsAmountCaptured> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(ListSubscriptionPaymentsAmountChargedBack amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = Optional.ofNullable(amountChargedBack);
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(Optional<? extends ListSubscriptionPaymentsAmountChargedBack> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(ListSubscriptionPaymentsSettlementAmount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = Optional.ofNullable(settlementAmount);
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(Optional<? extends ListSubscriptionPaymentsSettlementAmount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<ListSubscriptionPaymentsLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<ListSubscriptionPaymentsLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(ListSubscriptionPaymentsBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends ListSubscriptionPaymentsBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(ListSubscriptionPaymentsShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(Optional<? extends ListSubscriptionPaymentsShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<String> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(String countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = JsonNullable.of(countryCode);
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(JsonNullable<String> countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = countryCode;
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `riverty` `satispay` `swish` `trustly` `twint` `voucher`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(ListSubscriptionPaymentsMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends ListSubscriptionPaymentsMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(String captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(JsonNullable<String> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(String captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = JsonNullable.of(captureBefore);
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(JsonNullable<String> captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = captureBefore;
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(ListSubscriptionPaymentsApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends ListSubscriptionPaymentsApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(List<ListSubscriptionPaymentsRouting> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(JsonNullable<? extends List<ListSubscriptionPaymentsRouting>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(String sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = Optional.ofNullable(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(Optional<String> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = JsonNullable.of(subscriptionId);
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(JsonNullable<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = JsonNullable.of(settlementId);
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(JsonNullable<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = JsonNullable.of(orderId);
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(JsonNullable<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }

        /**
         * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
         * 
         * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(ListSubscriptionPaymentsStatusReason statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = JsonNullable.of(statusReason);
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(JsonNullable<? extends ListSubscriptionPaymentsStatusReason> statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = statusReason;
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(Map<String, Object> details) {
            Utils.checkNotNull(details, "details");
            this.details = JsonNullable.of(details);
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(JsonNullable<? extends Map<String, Object>> details) {
            Utils.checkNotNull(details, "details");
            this.details = details;
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(String failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = JsonNullable.of(failedAt);
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(JsonNullable<String> failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = failedAt;
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(ListSubscriptionPaymentsSubscriptionsLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }
        
        public ListSubscriptionPaymentsPayments build() {
            return new ListSubscriptionPaymentsPayments(
                resource,
                id,
                mode,
                description,
                amount,
                amountRefunded,
                amountRemaining,
                amountCaptured,
                amountChargedBack,
                settlementAmount,
                redirectUrl,
                cancelUrl,
                webhookUrl,
                lines,
                billingAddress,
                shippingAddress,
                locale,
                countryCode,
                method,
                restrictPaymentMethodsToCountry,
                metadata,
                captureMode,
                captureDelay,
                captureBefore,
                applicationFee,
                routing,
                sequenceType,
                subscriptionId,
                mandateId,
                customerId,
                profileId,
                settlementId,
                orderId,
                status,
                statusReason,
                isCancelable,
                details,
                createdAt,
                authorizedAt,
                paidAt,
                canceledAt,
                expiresAt,
                expiredAt,
                failedAt,
                links);
        }
    }
}
