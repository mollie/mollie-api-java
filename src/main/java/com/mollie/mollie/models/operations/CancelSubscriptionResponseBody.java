/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * CancelSubscriptionResponseBody
 * 
 * <p>The updated subscription object with status `canceled`. For a complete reference of the subscription object, refer to the [Get subscription endpoint](get-subscription) documentation.
 */
public class CancelSubscriptionResponseBody {

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource")
    private Optional<String> resource;

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mode")
    private Optional<String> mode;

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends CancelSubscriptionAmount> amount;

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("times")
    private JsonNullable<Long> times;

    /**
     * Number of payments left for the subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timesRemaining")
    private Optional<Long> timesRemaining;

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days` `... weeks` `... months`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private Optional<String> interval;

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("startDate")
    private Optional<String> startDate;

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nextPaymentDate")
    private JsonNullable<String> nextPaymentDate;

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * <p>Possible values: `creditcard` `directdebit` `paypal`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private Optional<? extends CancelSubscriptionApplicationFee> applicationFee;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends CancelSubscriptionMetadata> metadata;

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private Optional<String> webhookUrl;

    /**
     * The customer this subscription belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<String> createdAt;

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("_links")
    private Optional<? extends CancelSubscriptionLinks> links;

    @JsonCreator
    public CancelSubscriptionResponseBody(
            @JsonProperty("resource") Optional<String> resource,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("mode") Optional<String> mode,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("amount") Optional<? extends CancelSubscriptionAmount> amount,
            @JsonProperty("times") JsonNullable<Long> times,
            @JsonProperty("timesRemaining") Optional<Long> timesRemaining,
            @JsonProperty("interval") Optional<String> interval,
            @JsonProperty("startDate") Optional<String> startDate,
            @JsonProperty("nextPaymentDate") JsonNullable<String> nextPaymentDate,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("applicationFee") Optional<? extends CancelSubscriptionApplicationFee> applicationFee,
            @JsonProperty("metadata") JsonNullable<? extends CancelSubscriptionMetadata> metadata,
            @JsonProperty("webhookUrl") Optional<String> webhookUrl,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("createdAt") Optional<String> createdAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("_links") Optional<? extends CancelSubscriptionLinks> links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(times, "times");
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.status = status;
        this.amount = amount;
        this.times = times;
        this.timesRemaining = timesRemaining;
        this.interval = interval;
        this.startDate = startDate;
        this.nextPaymentDate = nextPaymentDate;
        this.description = description;
        this.method = method;
        this.applicationFee = applicationFee;
        this.metadata = metadata;
        this.webhookUrl = webhookUrl;
        this.customerId = customerId;
        this.mandateId = mandateId;
        this.createdAt = createdAt;
        this.canceledAt = canceledAt;
        this.links = links;
    }
    
    public CancelSubscriptionResponseBody() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    @JsonIgnore
    public Optional<String> resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonIgnore
    public Optional<String> mode() {
        return mode;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CancelSubscriptionAmount> amount() {
        return (Optional<CancelSubscriptionAmount>) amount;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonIgnore
    public JsonNullable<Long> times() {
        return times;
    }

    /**
     * Number of payments left for the subscription.
     */
    @JsonIgnore
    public Optional<Long> timesRemaining() {
        return timesRemaining;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days` `... weeks` `... months`
     */
    @JsonIgnore
    public Optional<String> interval() {
        return interval;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonIgnore
    public Optional<String> startDate() {
        return startDate;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    @JsonIgnore
    public JsonNullable<String> nextPaymentDate() {
        return nextPaymentDate;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * <p>Possible values: `creditcard` `directdebit` `paypal`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CancelSubscriptionApplicationFee> applicationFee() {
        return (Optional<CancelSubscriptionApplicationFee>) applicationFee;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CancelSubscriptionMetadata> metadata() {
        return (JsonNullable<CancelSubscriptionMetadata>) metadata;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonIgnore
    public Optional<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer this subscription belongs to.
     */
    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public Optional<String> createdAt() {
        return createdAt;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CancelSubscriptionLinks> links() {
        return (Optional<CancelSubscriptionLinks>) links;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    public CancelSubscriptionResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = Optional.ofNullable(resource);
        return this;
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    public CancelSubscriptionResponseBody withResource(Optional<String> resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public CancelSubscriptionResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public CancelSubscriptionResponseBody withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public CancelSubscriptionResponseBody withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = Optional.ofNullable(mode);
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public CancelSubscriptionResponseBody withMode(Optional<String> mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    public CancelSubscriptionResponseBody withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    public CancelSubscriptionResponseBody withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    public CancelSubscriptionResponseBody withAmount(CancelSubscriptionAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    public CancelSubscriptionResponseBody withAmount(Optional<? extends CancelSubscriptionAmount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public CancelSubscriptionResponseBody withTimes(long times) {
        Utils.checkNotNull(times, "times");
        this.times = JsonNullable.of(times);
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public CancelSubscriptionResponseBody withTimes(JsonNullable<Long> times) {
        Utils.checkNotNull(times, "times");
        this.times = times;
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public CancelSubscriptionResponseBody withTimesRemaining(long timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = Optional.ofNullable(timesRemaining);
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public CancelSubscriptionResponseBody withTimesRemaining(Optional<Long> timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = timesRemaining;
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days` `... weeks` `... months`
     */
    public CancelSubscriptionResponseBody withInterval(String interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = Optional.ofNullable(interval);
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * <p>Possible values: `... days` `... weeks` `... months`
     */
    public CancelSubscriptionResponseBody withInterval(Optional<String> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public CancelSubscriptionResponseBody withStartDate(String startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public CancelSubscriptionResponseBody withStartDate(Optional<String> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    public CancelSubscriptionResponseBody withNextPaymentDate(String nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    public CancelSubscriptionResponseBody withNextPaymentDate(JsonNullable<String> nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = nextPaymentDate;
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public CancelSubscriptionResponseBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public CancelSubscriptionResponseBody withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * <p>Possible values: `creditcard` `directdebit` `paypal`
     */
    public CancelSubscriptionResponseBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * <p>Possible values: `creditcard` `directdebit` `paypal`
     */
    public CancelSubscriptionResponseBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    public CancelSubscriptionResponseBody withApplicationFee(CancelSubscriptionApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = Optional.ofNullable(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    public CancelSubscriptionResponseBody withApplicationFee(Optional<? extends CancelSubscriptionApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public CancelSubscriptionResponseBody withMetadata(CancelSubscriptionMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public CancelSubscriptionResponseBody withMetadata(JsonNullable<? extends CancelSubscriptionMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    public CancelSubscriptionResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = Optional.ofNullable(webhookUrl);
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    public CancelSubscriptionResponseBody withWebhookUrl(Optional<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public CancelSubscriptionResponseBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public CancelSubscriptionResponseBody withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public CancelSubscriptionResponseBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public CancelSubscriptionResponseBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public CancelSubscriptionResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public CancelSubscriptionResponseBody withCreatedAt(Optional<String> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    public CancelSubscriptionResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    public CancelSubscriptionResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public CancelSubscriptionResponseBody withLinks(CancelSubscriptionLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = Optional.ofNullable(links);
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public CancelSubscriptionResponseBody withLinks(Optional<? extends CancelSubscriptionLinks> links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CancelSubscriptionResponseBody other = (CancelSubscriptionResponseBody) o;
        return 
            Objects.deepEquals(this.resource, other.resource) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.mode, other.mode) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.times, other.times) &&
            Objects.deepEquals(this.timesRemaining, other.timesRemaining) &&
            Objects.deepEquals(this.interval, other.interval) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.nextPaymentDate, other.nextPaymentDate) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.applicationFee, other.applicationFee) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.customerId, other.customerId) &&
            Objects.deepEquals(this.mandateId, other.mandateId) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.canceledAt, other.canceledAt) &&
            Objects.deepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            resource,
            id,
            mode,
            status,
            amount,
            times,
            timesRemaining,
            interval,
            startDate,
            nextPaymentDate,
            description,
            method,
            applicationFee,
            metadata,
            webhookUrl,
            customerId,
            mandateId,
            createdAt,
            canceledAt,
            links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CancelSubscriptionResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "status", status,
                "amount", amount,
                "times", times,
                "timesRemaining", timesRemaining,
                "interval", interval,
                "startDate", startDate,
                "nextPaymentDate", nextPaymentDate,
                "description", description,
                "method", method,
                "applicationFee", applicationFee,
                "metadata", metadata,
                "webhookUrl", webhookUrl,
                "customerId", customerId,
                "mandateId", mandateId,
                "createdAt", createdAt,
                "canceledAt", canceledAt,
                "links", links);
    }
    
    public final static class Builder {
 
        private Optional<String> resource;
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> mode = Optional.empty();
 
        private Optional<String> status = Optional.empty();
 
        private Optional<? extends CancelSubscriptionAmount> amount = Optional.empty();
 
        private JsonNullable<Long> times = JsonNullable.undefined();
 
        private Optional<Long> timesRemaining = Optional.empty();
 
        private Optional<String> interval = Optional.empty();
 
        private Optional<String> startDate = Optional.empty();
 
        private JsonNullable<String> nextPaymentDate = JsonNullable.undefined();
 
        private Optional<String> description = Optional.empty();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private Optional<? extends CancelSubscriptionApplicationFee> applicationFee = Optional.empty();
 
        private JsonNullable<? extends CancelSubscriptionMetadata> metadata = JsonNullable.undefined();
 
        private Optional<String> webhookUrl = Optional.empty();
 
        private Optional<String> customerId = Optional.empty();
 
        private JsonNullable<String> mandateId = JsonNullable.undefined();
 
        private Optional<String> createdAt = Optional.empty();
 
        private JsonNullable<String> canceledAt = JsonNullable.undefined();
 
        private Optional<? extends CancelSubscriptionLinks> links = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = Optional.ofNullable(resource);
            return this;
        }

        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
         */
        public Builder resource(Optional<String> resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }

        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(Optional<String> mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
         * 
         * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
         * 
         * <p>Possible values: `pending` `active` `canceled` `suspended` `completed`
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(CancelSubscriptionAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(Optional<? extends CancelSubscriptionAmount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(long times) {
            Utils.checkNotNull(times, "times");
            this.times = JsonNullable.of(times);
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(JsonNullable<Long> times) {
            Utils.checkNotNull(times, "times");
            this.times = times;
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(long timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = Optional.ofNullable(timesRemaining);
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(Optional<Long> timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = timesRemaining;
            return this;
        }

        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         * 
         * <p>Possible values: `... days` `... weeks` `... months`
         */
        public Builder interval(String interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = Optional.ofNullable(interval);
            return this;
        }

        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         * 
         * <p>Possible values: `... days` `... weeks` `... months`
         */
        public Builder interval(Optional<String> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }

        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(String startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(Optional<String> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
         */
        public Builder nextPaymentDate(String nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
         */
        public Builder nextPaymentDate(JsonNullable<String> nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = nextPaymentDate;
            return this;
        }

        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
         * 
         * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
         * 
         * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         * 
         * <p>Possible values: `creditcard` `directdebit` `paypal`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         * 
         * <p>Possible values: `creditcard` `directdebit` `paypal`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
         */
        public Builder applicationFee(CancelSubscriptionApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = Optional.ofNullable(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
         */
        public Builder applicationFee(Optional<? extends CancelSubscriptionApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         * 
         * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(CancelSubscriptionMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         * 
         * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(JsonNullable<? extends CancelSubscriptionMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = Optional.ofNullable(webhookUrl);
            return this;
        }

        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(Optional<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }

        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(Optional<String> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(CancelSubscriptionLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = Optional.ofNullable(links);
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(Optional<? extends CancelSubscriptionLinks> links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }
        
        public CancelSubscriptionResponseBody build() {
            if (resource == null) {
                resource = _SINGLETON_VALUE_Resource.value();
            }
            return new CancelSubscriptionResponseBody(
                resource,
                id,
                mode,
                status,
                amount,
                times,
                timesRemaining,
                interval,
                startDate,
                nextPaymentDate,
                description,
                method,
                applicationFee,
                metadata,
                webhookUrl,
                customerId,
                mandateId,
                createdAt,
                canceledAt,
                links);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Resource =
                new LazySingletonValue<>(
                        "resource",
                        "\"subscription\"",
                        new TypeReference<Optional<String>>() {});
    }
}
