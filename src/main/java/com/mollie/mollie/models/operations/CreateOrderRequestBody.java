/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.mollie.mollie.models.operations;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class CreateOrderRequestBody {

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    @JsonProperty("orderNumber")
    private String orderNumber;

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    @JsonProperty("lines")
    private List<Lines> lines;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    @JsonProperty("amount")
    private Amount amount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    @JsonProperty("billingAddress")
    private BillingAddress billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends ShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    @JsonProperty("locale")
    private String locale;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shopperCountryMustMatchBillingCountry")
    private Optional<Boolean> shopperCountryMustMatchBillingCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends CreateOrderMetadata> metadata;

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment")
    private JsonNullable<? extends Payment> payment;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private JsonNullable<String> profileId;

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    @JsonCreator
    public CreateOrderRequestBody(
            @JsonProperty("orderNumber") String orderNumber,
            @JsonProperty("lines") List<Lines> lines,
            @JsonProperty("amount") Amount amount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("billingAddress") BillingAddress billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends ShippingAddress> shippingAddress,
            @JsonProperty("locale") String locale,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("shopperCountryMustMatchBillingCountry") Optional<Boolean> shopperCountryMustMatchBillingCountry,
            @JsonProperty("metadata") JsonNullable<? extends CreateOrderMetadata> metadata,
            @JsonProperty("payment") JsonNullable<? extends Payment> payment,
            @JsonProperty("profileId") JsonNullable<String> profileId,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(payment, "payment");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(testmode, "testmode");
        this.orderNumber = orderNumber;
        this.lines = lines;
        this.amount = amount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.method = method;
        this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
        this.metadata = metadata;
        this.payment = payment;
        this.profileId = profileId;
        this.expiresAt = expiresAt;
        this.testmode = testmode;
    }
    
    public CreateOrderRequestBody(
            String orderNumber,
            List<Lines> lines,
            Amount amount,
            BillingAddress billingAddress,
            String locale) {
        this(orderNumber, lines, amount, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), billingAddress, Optional.empty(), locale, JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined());
    }

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    @JsonIgnore
    public String orderNumber() {
        return orderNumber;
    }

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    @JsonIgnore
    public List<Lines> lines() {
        return lines;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    @JsonIgnore
    public Amount amount() {
        return amount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    @JsonIgnore
    public BillingAddress billingAddress() {
        return billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ShippingAddress> shippingAddress() {
        return (Optional<ShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    @JsonIgnore
    public String locale() {
        return locale;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    @JsonIgnore
    public Optional<Boolean> shopperCountryMustMatchBillingCountry() {
        return shopperCountryMustMatchBillingCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateOrderMetadata> metadata() {
        return (JsonNullable<CreateOrderMetadata>) metadata;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Payment> payment() {
        return (JsonNullable<Payment>) payment;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonIgnore
    public JsonNullable<String> profileId() {
        return profileId;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The order number for this order. We recommend each order number to be unique.
     */
    public CreateOrderRequestBody withOrderNumber(String orderNumber) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        this.orderNumber = orderNumber;
        return this;
    }

    /**
     * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
     * 
     * All lines must have the same currency as the payment.
     */
    public CreateOrderRequestBody withLines(List<Lines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     */
    public CreateOrderRequestBody withAmount(Amount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateOrderRequestBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateOrderRequestBody withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateOrderRequestBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateOrderRequestBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateOrderRequestBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send order status updates to.
     * 
     * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
     * 
     * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateOrderRequestBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
     */
    public CreateOrderRequestBody withBillingAddress(BillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    public CreateOrderRequestBody withShippingAddress(ShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
     */
    public CreateOrderRequestBody withShippingAddress(Optional<? extends ShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     * 
     * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
     */
    public CreateOrderRequestBody withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    public CreateOrderRequestBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
     */
    public CreateOrderRequestBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    public CreateOrderRequestBody withShopperCountryMustMatchBillingCountry(boolean shopperCountryMustMatchBillingCountry) {
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        this.shopperCountryMustMatchBillingCountry = Optional.ofNullable(shopperCountryMustMatchBillingCountry);
        return this;
    }

    /**
     * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
     * 
     * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
     */
    public CreateOrderRequestBody withShopperCountryMustMatchBillingCountry(Optional<Boolean> shopperCountryMustMatchBillingCountry) {
        Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
        this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateOrderRequestBody withMetadata(CreateOrderMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateOrderRequestBody withMetadata(JsonNullable<? extends CreateOrderMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    public CreateOrderRequestBody withPayment(Payment payment) {
        Utils.checkNotNull(payment, "payment");
        this.payment = JsonNullable.of(payment);
        return this;
    }

    /**
     * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
     */
    public CreateOrderRequestBody withPayment(JsonNullable<? extends Payment> payment) {
        Utils.checkNotNull(payment, "payment");
        this.payment = payment;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public CreateOrderRequestBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = JsonNullable.of(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public CreateOrderRequestBody withProfileId(JsonNullable<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    public CreateOrderRequestBody withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
     * 
     * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
     */
    public CreateOrderRequestBody withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    public CreateOrderRequestBody withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    public CreateOrderRequestBody withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateOrderRequestBody other = (CreateOrderRequestBody) o;
        return 
            Objects.deepEquals(this.orderNumber, other.orderNumber) &&
            Objects.deepEquals(this.lines, other.lines) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.redirectUrl, other.redirectUrl) &&
            Objects.deepEquals(this.cancelUrl, other.cancelUrl) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.locale, other.locale) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.shopperCountryMustMatchBillingCountry, other.shopperCountryMustMatchBillingCountry) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.payment, other.payment) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.expiresAt, other.expiresAt) &&
            Objects.deepEquals(this.testmode, other.testmode);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            orderNumber,
            lines,
            amount,
            redirectUrl,
            cancelUrl,
            webhookUrl,
            billingAddress,
            shippingAddress,
            locale,
            method,
            shopperCountryMustMatchBillingCountry,
            metadata,
            payment,
            profileId,
            expiresAt,
            testmode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateOrderRequestBody.class,
                "orderNumber", orderNumber,
                "lines", lines,
                "amount", amount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "method", method,
                "shopperCountryMustMatchBillingCountry", shopperCountryMustMatchBillingCountry,
                "metadata", metadata,
                "payment", payment,
                "profileId", profileId,
                "expiresAt", expiresAt,
                "testmode", testmode);
    }
    
    public final static class Builder {
 
        private String orderNumber;
 
        private List<Lines> lines;
 
        private Amount amount;
 
        private JsonNullable<String> redirectUrl = JsonNullable.undefined();
 
        private JsonNullable<String> cancelUrl = JsonNullable.undefined();
 
        private JsonNullable<String> webhookUrl = JsonNullable.undefined();
 
        private BillingAddress billingAddress;
 
        private Optional<? extends ShippingAddress> shippingAddress = Optional.empty();
 
        private String locale;
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private Optional<Boolean> shopperCountryMustMatchBillingCountry = Optional.empty();
 
        private JsonNullable<? extends CreateOrderMetadata> metadata = JsonNullable.undefined();
 
        private JsonNullable<? extends Payment> payment = JsonNullable.undefined();
 
        private JsonNullable<String> profileId = JsonNullable.undefined();
 
        private JsonNullable<String> expiresAt = JsonNullable.undefined();
 
        private JsonNullable<Boolean> testmode;  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The order number for this order. We recommend each order number to be unique.
         */
        public Builder orderNumber(String orderNumber) {
            Utils.checkNotNull(orderNumber, "orderNumber");
            this.orderNumber = orderNumber;
            return this;
        }

        /**
         * The order lines for the order. Each line contains details such as a description of the item ordered and its price.
         * 
         * All lines must have the same currency as the payment.
         */
        public Builder lines(List<Lines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         */
        public Builder amount(Amount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }

        /**
         * The webhook URL where we will send order status updates to.
         * 
         * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
         * 
         * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send order status updates to.
         * 
         * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your order.
         * 
         * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * The customer's billing address details. The billing address is required, unless a fast checkout method like PayPal Express Checkout is providing the billing address.
         */
        public Builder billingAddress(BillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
         */
        public Builder shippingAddress(ShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
         */
        public Builder shippingAddress(Optional<? extends ShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         * 
         * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * Possible values: `applepay` `bancomatpay` `bancontact` `banktransfer` `belfius` `billie` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `klarna` `klarnapaylater` `klarnapaynow` `klarnasliceit` `mybank` `paypal` `paysafecard` `przelewy24` `riverty` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
         * 
         * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
         */
        public Builder shopperCountryMustMatchBillingCountry(boolean shopperCountryMustMatchBillingCountry) {
            Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
            this.shopperCountryMustMatchBillingCountry = Optional.ofNullable(shopperCountryMustMatchBillingCountry);
            return this;
        }

        /**
         * For digital goods, you must make sure to apply the VAT rate from your customer's country in most jurisdictions. You can use this parameter to restrict the payment methods available to your customer to methods from the billing country only.
         * 
         * This field is similar to the `restrictPaymentMethodsToCountry` field in the Payments API.
         */
        public Builder shopperCountryMustMatchBillingCountry(Optional<Boolean> shopperCountryMustMatchBillingCountry) {
            Utils.checkNotNull(shopperCountryMustMatchBillingCountry, "shopperCountryMustMatchBillingCountry");
            this.shopperCountryMustMatchBillingCountry = shopperCountryMustMatchBillingCountry;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(CreateOrderMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends CreateOrderMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
         */
        public Builder payment(Payment payment) {
            Utils.checkNotNull(payment, "payment");
            this.payment = JsonNullable.of(payment);
            return this;
        }

        /**
         * Any payment specific properties (for example, the `dueDate` for bank transfer payments) can be passed here. See [method-specific parameters](extra-payment-parameters) for all the possible fields.
         */
        public Builder payment(JsonNullable<? extends Payment> payment) {
            Utils.checkNotNull(payment, "payment");
            this.payment = payment;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = JsonNullable.of(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(JsonNullable<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
         * 
         * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date the order should expire in `YYYY-MM-DD` format. The minimum date is tomorrow and the maximum date is 100 days after tomorrow.
         * 
         * It is not possible to use Klarna when your expiry date is more than 28 days in the future, unless you agreed on a different maximum with Klarna.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }
        
        public CreateOrderRequestBody build() {
            if (testmode == null) {
                testmode = _SINGLETON_VALUE_Testmode.value();
            }            return new CreateOrderRequestBody(
                orderNumber,
                lines,
                amount,
                redirectUrl,
                cancelUrl,
                webhookUrl,
                billingAddress,
                shippingAddress,
                locale,
                method,
                shopperCountryMustMatchBillingCountry,
                metadata,
                payment,
                profileId,
                expiresAt,
                testmode);
        }

        private static final LazySingletonValue<JsonNullable<Boolean>> _SINGLETON_VALUE_Testmode =
                new LazySingletonValue<>(
                        "testmode",
                        "false",
                        new TypeReference<JsonNullable<Boolean>>() {});
    }
}

