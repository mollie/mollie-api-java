/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class CreateCustomerPaymentRequestBody {

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonProperty("amount")
    private CreateCustomerPaymentAmount amount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("redirectUrl")
    private Optional<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment method `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<CreateCustomerPaymentLines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends CreateCustomerPaymentBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends CreateCustomerPaymentShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<String> locale;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issuer")
    private JsonNullable<String> issuer;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends CreateCustomerPaymentMetadata> metadata;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
     * 
     * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<String> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends CreateCustomerPaymentApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<CreateCustomerPaymentRouting>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sequenceType")
    private JsonNullable<String> sequenceType;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private Optional<String> profileId;

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dueDate")
    private Optional<String> dueDate;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    @JsonCreator
    public CreateCustomerPaymentRequestBody(
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("amount") CreateCustomerPaymentAmount amount,
            @JsonProperty("redirectUrl") Optional<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<CreateCustomerPaymentLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends CreateCustomerPaymentBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends CreateCustomerPaymentShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<String> locale,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("issuer") JsonNullable<String> issuer,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends CreateCustomerPaymentMetadata> metadata,
            @JsonProperty("captureMode") JsonNullable<String> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("applicationFee") JsonNullable<? extends CreateCustomerPaymentApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<CreateCustomerPaymentRouting>> routing,
            @JsonProperty("sequenceType") JsonNullable<String> sequenceType,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") Optional<String> profileId,
            @JsonProperty("dueDate") Optional<String> dueDate,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(issuer, "issuer");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(testmode, "testmode");
        this.description = description;
        this.amount = amount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.method = method;
        this.issuer = issuer;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.dueDate = dueDate;
        this.testmode = testmode;
    }
    
    public CreateCustomerPaymentRequestBody(
            CreateCustomerPaymentAmount amount) {
        this(Optional.empty(), amount, Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined());
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonIgnore
    public CreateCustomerPaymentAmount amount() {
        return amount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public Optional<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment method `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreateCustomerPaymentLines>> lines() {
        return (JsonNullable<List<CreateCustomerPaymentLines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentBillingAddress> billingAddress() {
        return (Optional<CreateCustomerPaymentBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentShippingAddress> shippingAddress() {
        return (Optional<CreateCustomerPaymentShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonIgnore
    public JsonNullable<String> locale() {
        return locale;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonIgnore
    public JsonNullable<String> issuer() {
        return issuer;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateCustomerPaymentMetadata> metadata() {
        return (JsonNullable<CreateCustomerPaymentMetadata>) metadata;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
     * 
     * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonIgnore
    public JsonNullable<String> captureMode() {
        return captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateCustomerPaymentApplicationFee> applicationFee() {
        return (JsonNullable<CreateCustomerPaymentApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreateCustomerPaymentRouting>> routing() {
        return (JsonNullable<List<CreateCustomerPaymentRouting>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonIgnore
    public JsonNullable<String> sequenceType() {
        return sequenceType;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public Optional<String> profileId() {
        return profileId;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonIgnore
    public Optional<String> dueDate() {
        return dueDate;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreateCustomerPaymentRequestBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreateCustomerPaymentRequestBody withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    public CreateCustomerPaymentRequestBody withAmount(CreateCustomerPaymentAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateCustomerPaymentRequestBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = Optional.ofNullable(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateCustomerPaymentRequestBody withRedirectUrl(Optional<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateCustomerPaymentRequestBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateCustomerPaymentRequestBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateCustomerPaymentRequestBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateCustomerPaymentRequestBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment method `voucher`.
     */
    public CreateCustomerPaymentRequestBody withLines(List<CreateCustomerPaymentLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment method `voucher`.
     */
    public CreateCustomerPaymentRequestBody withLines(JsonNullable<? extends List<CreateCustomerPaymentLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`.
     */
    public CreateCustomerPaymentRequestBody withBillingAddress(CreateCustomerPaymentBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`.
     */
    public CreateCustomerPaymentRequestBody withBillingAddress(Optional<? extends CreateCustomerPaymentBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreateCustomerPaymentRequestBody withShippingAddress(CreateCustomerPaymentShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreateCustomerPaymentRequestBody withShippingAddress(Optional<? extends CreateCustomerPaymentShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreateCustomerPaymentRequestBody withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreateCustomerPaymentRequestBody withLocale(JsonNullable<String> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
     */
    public CreateCustomerPaymentRequestBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     * 
     * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
     */
    public CreateCustomerPaymentRequestBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public CreateCustomerPaymentRequestBody withIssuer(String issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = JsonNullable.of(issuer);
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public CreateCustomerPaymentRequestBody withIssuer(JsonNullable<String> issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = issuer;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreateCustomerPaymentRequestBody withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreateCustomerPaymentRequestBody withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateCustomerPaymentRequestBody withMetadata(CreateCustomerPaymentMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateCustomerPaymentRequestBody withMetadata(JsonNullable<? extends CreateCustomerPaymentMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
     * 
     * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreateCustomerPaymentRequestBody withCaptureMode(String captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
     * 
     * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreateCustomerPaymentRequestBody withCaptureMode(JsonNullable<String> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreateCustomerPaymentRequestBody withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreateCustomerPaymentRequestBody withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreateCustomerPaymentRequestBody withApplicationFee(CreateCustomerPaymentApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreateCustomerPaymentRequestBody withApplicationFee(JsonNullable<? extends CreateCustomerPaymentApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreateCustomerPaymentRequestBody withRouting(List<CreateCustomerPaymentRouting> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreateCustomerPaymentRequestBody withRouting(JsonNullable<? extends List<CreateCustomerPaymentRouting>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreateCustomerPaymentRequestBody withSequenceType(String sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = JsonNullable.of(sequenceType);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreateCustomerPaymentRequestBody withSequenceType(JsonNullable<String> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreateCustomerPaymentRequestBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreateCustomerPaymentRequestBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreateCustomerPaymentRequestBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreateCustomerPaymentRequestBody withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreateCustomerPaymentRequestBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = Optional.ofNullable(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreateCustomerPaymentRequestBody withProfileId(Optional<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public CreateCustomerPaymentRequestBody withDueDate(String dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = Optional.ofNullable(dueDate);
        return this;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public CreateCustomerPaymentRequestBody withDueDate(Optional<String> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    public CreateCustomerPaymentRequestBody withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
     */
    public CreateCustomerPaymentRequestBody withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateCustomerPaymentRequestBody other = (CreateCustomerPaymentRequestBody) o;
        return 
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.redirectUrl, other.redirectUrl) &&
            Objects.deepEquals(this.cancelUrl, other.cancelUrl) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.lines, other.lines) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.locale, other.locale) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.issuer, other.issuer) &&
            Objects.deepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.captureMode, other.captureMode) &&
            Objects.deepEquals(this.captureDelay, other.captureDelay) &&
            Objects.deepEquals(this.applicationFee, other.applicationFee) &&
            Objects.deepEquals(this.routing, other.routing) &&
            Objects.deepEquals(this.sequenceType, other.sequenceType) &&
            Objects.deepEquals(this.mandateId, other.mandateId) &&
            Objects.deepEquals(this.customerId, other.customerId) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.dueDate, other.dueDate) &&
            Objects.deepEquals(this.testmode, other.testmode);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            description,
            amount,
            redirectUrl,
            cancelUrl,
            webhookUrl,
            lines,
            billingAddress,
            shippingAddress,
            locale,
            method,
            issuer,
            restrictPaymentMethodsToCountry,
            metadata,
            captureMode,
            captureDelay,
            applicationFee,
            routing,
            sequenceType,
            mandateId,
            customerId,
            profileId,
            dueDate,
            testmode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateCustomerPaymentRequestBody.class,
                "description", description,
                "amount", amount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "method", method,
                "issuer", issuer,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "dueDate", dueDate,
                "testmode", testmode);
    }
    
    public final static class Builder {
 
        private Optional<String> description = Optional.empty();
 
        private CreateCustomerPaymentAmount amount;
 
        private Optional<String> redirectUrl = Optional.empty();
 
        private JsonNullable<String> cancelUrl = JsonNullable.undefined();
 
        private JsonNullable<String> webhookUrl = JsonNullable.undefined();
 
        private JsonNullable<? extends List<CreateCustomerPaymentLines>> lines = JsonNullable.undefined();
 
        private Optional<? extends CreateCustomerPaymentBillingAddress> billingAddress = Optional.empty();
 
        private Optional<? extends CreateCustomerPaymentShippingAddress> shippingAddress = Optional.empty();
 
        private JsonNullable<String> locale = JsonNullable.undefined();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private JsonNullable<String> issuer = JsonNullable.undefined();
 
        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();
 
        private JsonNullable<? extends CreateCustomerPaymentMetadata> metadata = JsonNullable.undefined();
 
        private JsonNullable<String> captureMode = JsonNullable.undefined();
 
        private JsonNullable<String> captureDelay = JsonNullable.undefined();
 
        private JsonNullable<? extends CreateCustomerPaymentApplicationFee> applicationFee = JsonNullable.undefined();
 
        private JsonNullable<? extends List<CreateCustomerPaymentRouting>> routing = JsonNullable.undefined();
 
        private JsonNullable<String> sequenceType = JsonNullable.undefined();
 
        private JsonNullable<String> mandateId = JsonNullable.undefined();
 
        private JsonNullable<String> customerId = JsonNullable.undefined();
 
        private Optional<String> profileId = Optional.empty();
 
        private Optional<String> dueDate = Optional.empty();
 
        private JsonNullable<Boolean> testmode;
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
         */
        public Builder amount(CreateCustomerPaymentAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = Optional.ofNullable(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(Optional<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment method `voucher`.
         */
        public Builder lines(List<CreateCustomerPaymentLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment method `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<CreateCustomerPaymentLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`.
         */
        public Builder billingAddress(CreateCustomerPaymentBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`.
         */
        public Builder billingAddress(Optional<? extends CreateCustomerPaymentBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(CreateCustomerPaymentShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(Optional<? extends CreateCustomerPaymentShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<String> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         * 
         * <p>Possible values: `alma` `applepay` `bacs` `bancomatpay` `bancontact` `banktransfer` `belfius` `blik` `creditcard` `directdebit` `eps` `giftcard` `ideal` `in3` `kbc` `mbway` `multibanco` `mybank` `payconiq` `paypal` `paysafecard` `pointofsale` `przelewy24` `satispay` `trustly` `twint` `voucher`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(String issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = JsonNullable.of(issuer);
            return this;
        }

        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(JsonNullable<String> issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = issuer;
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(CreateCustomerPaymentMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends CreateCustomerPaymentMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
         * 
         * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(String captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>By default, the customer's card or bank account is immediately charged when they complete the payment.
         * 
         * <p>Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(JsonNullable<String> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(CreateCustomerPaymentApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends CreateCustomerPaymentApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(List<CreateCustomerPaymentRouting> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(JsonNullable<? extends List<CreateCustomerPaymentRouting>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(String sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = JsonNullable.of(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(JsonNullable<String> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = Optional.ofNullable(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(Optional<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(String dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = Optional.ofNullable(dueDate);
            return this;
        }

        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(Optional<String> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }
        
        public CreateCustomerPaymentRequestBody build() {
            if (testmode == null) {
                testmode = _SINGLETON_VALUE_Testmode.value();
            }
            return new CreateCustomerPaymentRequestBody(
                description,
                amount,
                redirectUrl,
                cancelUrl,
                webhookUrl,
                lines,
                billingAddress,
                shippingAddress,
                locale,
                method,
                issuer,
                restrictPaymentMethodsToCountry,
                metadata,
                captureMode,
                captureDelay,
                applicationFee,
                routing,
                sequenceType,
                mandateId,
                customerId,
                profileId,
                dueDate,
                testmode);
        }

        private static final LazySingletonValue<JsonNullable<Boolean>> _SINGLETON_VALUE_Testmode =
                new LazySingletonValue<>(
                        "testmode",
                        "false",
                        new TypeReference<JsonNullable<Boolean>>() {});
    }
}
