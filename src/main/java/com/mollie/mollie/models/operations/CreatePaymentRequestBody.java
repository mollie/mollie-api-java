/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class CreatePaymentRequestBody {
    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonProperty("description")
    private String description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    @JsonProperty("amount")
    private Amount amount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("redirectUrl")
    private Optional<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<Lines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends BillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends ShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<? extends CreatePaymentLocale> locale;

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends Method> method;

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issuer")
    private JsonNullable<String> issuer;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Metadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<? extends CaptureMode> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends ApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<Routing>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sequenceType")
    private JsonNullable<? extends SequenceType> sequenceType;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private Optional<String> profileId;

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dueDate")
    private Optional<String> dueDate;

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private JsonNullable<Boolean> testmode;

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applePayPaymentToken")
    private Optional<String> applePayPaymentToken;

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company")
    private Optional<? extends Company> company;

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cardToken")
    private Optional<String> cardToken;

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("voucherNumber")
    private Optional<String> voucherNumber;

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("voucherPin")
    private Optional<String> voucherPin;

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("consumerDateOfBirth")
    private Optional<LocalDate> consumerDateOfBirth;

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("extraMerchantData")
    private Optional<? extends Map<String, Object>> extraMerchantData;

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sessionId")
    private Optional<String> sessionId;

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("digitalGoods")
    private Optional<Boolean> digitalGoods;

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerReference")
    private Optional<String> customerReference;

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("terminalId")
    private Optional<String> terminalId;

    @JsonCreator
    public CreatePaymentRequestBody(
            @JsonProperty("description") String description,
            @JsonProperty("amount") Amount amount,
            @JsonProperty("redirectUrl") Optional<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<Lines>> lines,
            @JsonProperty("billingAddress") Optional<? extends BillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends ShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<? extends CreatePaymentLocale> locale,
            @JsonProperty("method") JsonNullable<? extends Method> method,
            @JsonProperty("issuer") JsonNullable<String> issuer,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends Metadata> metadata,
            @JsonProperty("captureMode") JsonNullable<? extends CaptureMode> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("applicationFee") JsonNullable<? extends ApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<Routing>> routing,
            @JsonProperty("sequenceType") JsonNullable<? extends SequenceType> sequenceType,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") Optional<String> profileId,
            @JsonProperty("dueDate") Optional<String> dueDate,
            @JsonProperty("testmode") JsonNullable<Boolean> testmode,
            @JsonProperty("applePayPaymentToken") Optional<String> applePayPaymentToken,
            @JsonProperty("company") Optional<? extends Company> company,
            @JsonProperty("cardToken") Optional<String> cardToken,
            @JsonProperty("voucherNumber") Optional<String> voucherNumber,
            @JsonProperty("voucherPin") Optional<String> voucherPin,
            @JsonProperty("consumerDateOfBirth") Optional<LocalDate> consumerDateOfBirth,
            @JsonProperty("extraMerchantData") Optional<? extends Map<String, Object>> extraMerchantData,
            @JsonProperty("sessionId") Optional<String> sessionId,
            @JsonProperty("digitalGoods") Optional<Boolean> digitalGoods,
            @JsonProperty("customerReference") Optional<String> customerReference,
            @JsonProperty("terminalId") Optional<String> terminalId) {
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(issuer, "issuer");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(testmode, "testmode");
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        Utils.checkNotNull(company, "company");
        Utils.checkNotNull(cardToken, "cardToken");
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        Utils.checkNotNull(voucherPin, "voucherPin");
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        Utils.checkNotNull(sessionId, "sessionId");
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        Utils.checkNotNull(customerReference, "customerReference");
        Utils.checkNotNull(terminalId, "terminalId");
        this.description = description;
        this.amount = amount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.method = method;
        this.issuer = issuer;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.dueDate = dueDate;
        this.testmode = testmode;
        this.applePayPaymentToken = applePayPaymentToken;
        this.company = company;
        this.cardToken = cardToken;
        this.voucherNumber = voucherNumber;
        this.voucherPin = voucherPin;
        this.consumerDateOfBirth = consumerDateOfBirth;
        this.extraMerchantData = extraMerchantData;
        this.sessionId = sessionId;
        this.digitalGoods = digitalGoods;
        this.customerReference = customerReference;
        this.terminalId = terminalId;
    }
    
    public CreatePaymentRequestBody(
            String description,
            Amount amount) {
        this(description, amount, Optional.empty(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty());
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    @JsonIgnore
    public Amount amount() {
        return amount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public Optional<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<Lines>> lines() {
        return (JsonNullable<List<Lines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BillingAddress> billingAddress() {
        return (Optional<BillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ShippingAddress> shippingAddress() {
        return (Optional<ShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreatePaymentLocale> locale() {
        return (JsonNullable<CreatePaymentLocale>) locale;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Method> method() {
        return (JsonNullable<Method>) method;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    @JsonIgnore
    public JsonNullable<String> issuer() {
        return issuer;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Metadata> metadata() {
        return (JsonNullable<Metadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CaptureMode> captureMode() {
        return (JsonNullable<CaptureMode>) captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ApplicationFee> applicationFee() {
        return (JsonNullable<ApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<Routing>> routing() {
        return (JsonNullable<List<Routing>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SequenceType> sequenceType() {
        return (JsonNullable<SequenceType>) sequenceType;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public Optional<String> profileId() {
        return profileId;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    @JsonIgnore
    public Optional<String> dueDate() {
        return dueDate;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    @JsonIgnore
    public JsonNullable<Boolean> testmode() {
        return testmode;
    }

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    @JsonIgnore
    public Optional<String> applePayPaymentToken() {
        return applePayPaymentToken;
    }

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Company> company() {
        return (Optional<Company>) company;
    }

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    @JsonIgnore
    public Optional<String> cardToken() {
        return cardToken;
    }

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    @JsonIgnore
    public Optional<String> voucherNumber() {
        return voucherNumber;
    }

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    @JsonIgnore
    public Optional<String> voucherPin() {
        return voucherPin;
    }

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    @JsonIgnore
    public Optional<LocalDate> consumerDateOfBirth() {
        return consumerDateOfBirth;
    }

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, Object>> extraMerchantData() {
        return (Optional<Map<String, Object>>) extraMerchantData;
    }

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    @JsonIgnore
    public Optional<String> sessionId() {
        return sessionId;
    }

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    @JsonIgnore
    public Optional<Boolean> digitalGoods() {
        return digitalGoods;
    }

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    @JsonIgnore
    public Optional<String> customerReference() {
        return customerReference;
    }

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    @JsonIgnore
    public Optional<String> terminalId() {
        return terminalId;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreatePaymentRequestBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    public CreatePaymentRequestBody withAmount(Amount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreatePaymentRequestBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = Optional.ofNullable(redirectUrl);
        return this;
    }


    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreatePaymentRequestBody withRedirectUrl(Optional<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public CreatePaymentRequestBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public CreatePaymentRequestBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public CreatePaymentRequestBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public CreatePaymentRequestBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreatePaymentRequestBody withLines(List<Lines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreatePaymentRequestBody withLines(JsonNullable<? extends List<Lines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreatePaymentRequestBody withBillingAddress(BillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreatePaymentRequestBody withBillingAddress(Optional<? extends BillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    public CreatePaymentRequestBody withShippingAddress(ShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    public CreatePaymentRequestBody withShippingAddress(Optional<? extends ShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreatePaymentRequestBody withLocale(CreatePaymentLocale locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreatePaymentRequestBody withLocale(JsonNullable<? extends CreatePaymentLocale> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public CreatePaymentRequestBody withMethod(Method method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
     * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
     * parameter enables you to fully integrate the payment method selection into your website.
     * 
     * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
     * but will only show the methods specified in the array. For example, you can use this functionality to only show
     * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
     */
    public CreatePaymentRequestBody withMethod(JsonNullable<? extends Method> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public CreatePaymentRequestBody withIssuer(String issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = JsonNullable.of(issuer);
        return this;
    }

    /**
     * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
     * 
     * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
     * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
     * 
     * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
     * method, the customer may still need to select the appropriate issuer before the payment can proceed.
     * 
     * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
     * up front.
     * 
     * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
     * `issuers` include.
     * 
     * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
     */
    public CreatePaymentRequestBody withIssuer(JsonNullable<String> issuer) {
        Utils.checkNotNull(issuer, "issuer");
        this.issuer = issuer;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreatePaymentRequestBody withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreatePaymentRequestBody withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreatePaymentRequestBody withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreatePaymentRequestBody withMetadata(JsonNullable<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public CreatePaymentRequestBody withCaptureMode(CaptureMode captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public CreatePaymentRequestBody withCaptureMode(JsonNullable<? extends CaptureMode> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreatePaymentRequestBody withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreatePaymentRequestBody withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public CreatePaymentRequestBody withApplicationFee(ApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public CreatePaymentRequestBody withApplicationFee(JsonNullable<? extends ApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public CreatePaymentRequestBody withRouting(List<Routing> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public CreatePaymentRequestBody withRouting(JsonNullable<? extends List<Routing>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    public CreatePaymentRequestBody withSequenceType(SequenceType sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = JsonNullable.of(sequenceType);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    public CreatePaymentRequestBody withSequenceType(JsonNullable<? extends SequenceType> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    public CreatePaymentRequestBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    public CreatePaymentRequestBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreatePaymentRequestBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreatePaymentRequestBody withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreatePaymentRequestBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = Optional.ofNullable(profileId);
        return this;
    }


    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreatePaymentRequestBody withProfileId(Optional<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public CreatePaymentRequestBody withDueDate(String dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = Optional.ofNullable(dueDate);
        return this;
    }


    /**
     * The date by which the payment should be completed in `YYYY-MM-DD` format
     */
    public CreatePaymentRequestBody withDueDate(Optional<String> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public CreatePaymentRequestBody withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = JsonNullable.of(testmode);
        return this;
    }

    /**
     * Whether to create the entity in test mode or live mode.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
     * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
     * `testmode` to `true`.
     */
    public CreatePaymentRequestBody withTestmode(JsonNullable<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    public CreatePaymentRequestBody withApplePayPaymentToken(String applePayPaymentToken) {
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        this.applePayPaymentToken = Optional.ofNullable(applePayPaymentToken);
        return this;
    }


    /**
     * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
     * The token contains the payment information needed to authorize the payment.
     * 
     * <p>The object should be passed encoded in a JSON string.
     */
    public CreatePaymentRequestBody withApplePayPaymentToken(Optional<String> applePayPaymentToken) {
        Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
        this.applePayPaymentToken = applePayPaymentToken;
        return this;
    }

    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    public CreatePaymentRequestBody withCompany(Company company) {
        Utils.checkNotNull(company, "company");
        this.company = Optional.ofNullable(company);
        return this;
    }


    /**
     * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
     * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
     * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
     */
    public CreatePaymentRequestBody withCompany(Optional<? extends Company> company) {
        Utils.checkNotNull(company, "company");
        this.company = company;
        return this;
    }

    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    public CreatePaymentRequestBody withCardToken(String cardToken) {
        Utils.checkNotNull(cardToken, "cardToken");
        this.cardToken = Optional.ofNullable(cardToken);
        return this;
    }


    /**
     * When creating credit card payments using Mollie Components, you need to provide the card token you received from
     * the card component in this field. The token represents the customer's card information needed to complete the
     * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
     * enough.
     */
    public CreatePaymentRequestBody withCardToken(Optional<String> cardToken) {
        Utils.checkNotNull(cardToken, "cardToken");
        this.cardToken = cardToken;
        return this;
    }

    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    public CreatePaymentRequestBody withVoucherNumber(String voucherNumber) {
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        this.voucherNumber = Optional.ofNullable(voucherNumber);
        return this;
    }


    /**
     * The card token you received from the card component of Mollie Components. The token represents the customer's card
     * information needed to complete the payment.
     */
    public CreatePaymentRequestBody withVoucherNumber(Optional<String> voucherNumber) {
        Utils.checkNotNull(voucherNumber, "voucherNumber");
        this.voucherNumber = voucherNumber;
        return this;
    }

    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    public CreatePaymentRequestBody withVoucherPin(String voucherPin) {
        Utils.checkNotNull(voucherPin, "voucherPin");
        this.voucherPin = Optional.ofNullable(voucherPin);
        return this;
    }


    /**
     * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
     */
    public CreatePaymentRequestBody withVoucherPin(Optional<String> voucherPin) {
        Utils.checkNotNull(voucherPin, "voucherPin");
        this.voucherPin = voucherPin;
        return this;
    }

    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    public CreatePaymentRequestBody withConsumerDateOfBirth(LocalDate consumerDateOfBirth) {
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        this.consumerDateOfBirth = Optional.ofNullable(consumerDateOfBirth);
        return this;
    }


    /**
     * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
     * the payment process.
     */
    public CreatePaymentRequestBody withConsumerDateOfBirth(Optional<LocalDate> consumerDateOfBirth) {
        Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
        this.consumerDateOfBirth = consumerDateOfBirth;
        return this;
    }

    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    public CreatePaymentRequestBody withExtraMerchantData(Map<String, Object> extraMerchantData) {
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        this.extraMerchantData = Optional.ofNullable(extraMerchantData);
        return this;
    }


    /**
     * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
     * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
     * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
     */
    public CreatePaymentRequestBody withExtraMerchantData(Optional<? extends Map<String, Object>> extraMerchantData) {
        Utils.checkNotNull(extraMerchantData, "extraMerchantData");
        this.extraMerchantData = extraMerchantData;
        return this;
    }

    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    public CreatePaymentRequestBody withSessionId(String sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = Optional.ofNullable(sessionId);
        return this;
    }


    /**
     * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
     * on-demand payment.
     */
    public CreatePaymentRequestBody withSessionId(Optional<String> sessionId) {
        Utils.checkNotNull(sessionId, "sessionId");
        this.sessionId = sessionId;
        return this;
    }

    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    public CreatePaymentRequestBody withDigitalGoods(boolean digitalGoods) {
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        this.digitalGoods = Optional.ofNullable(digitalGoods);
        return this;
    }


    /**
     * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
     * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
     */
    public CreatePaymentRequestBody withDigitalGoods(Optional<Boolean> digitalGoods) {
        Utils.checkNotNull(digitalGoods, "digitalGoods");
        this.digitalGoods = digitalGoods;
        return this;
    }

    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    public CreatePaymentRequestBody withCustomerReference(String customerReference) {
        Utils.checkNotNull(customerReference, "customerReference");
        this.customerReference = Optional.ofNullable(customerReference);
        return this;
    }


    /**
     * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
     * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
     */
    public CreatePaymentRequestBody withCustomerReference(Optional<String> customerReference) {
        Utils.checkNotNull(customerReference, "customerReference");
        this.customerReference = customerReference;
        return this;
    }

    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    public CreatePaymentRequestBody withTerminalId(String terminalId) {
        Utils.checkNotNull(terminalId, "terminalId");
        this.terminalId = Optional.ofNullable(terminalId);
        return this;
    }


    /**
     * The ID of the terminal device where you want to initiate the payment on.
     */
    public CreatePaymentRequestBody withTerminalId(Optional<String> terminalId) {
        Utils.checkNotNull(terminalId, "terminalId");
        this.terminalId = terminalId;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreatePaymentRequestBody other = (CreatePaymentRequestBody) o;
        return 
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.issuer, other.issuer) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.captureMode, other.captureMode) &&
            Utils.enhancedDeepEquals(this.captureDelay, other.captureDelay) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.routing, other.routing) &&
            Utils.enhancedDeepEquals(this.sequenceType, other.sequenceType) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.dueDate, other.dueDate) &&
            Utils.enhancedDeepEquals(this.testmode, other.testmode) &&
            Utils.enhancedDeepEquals(this.applePayPaymentToken, other.applePayPaymentToken) &&
            Utils.enhancedDeepEquals(this.company, other.company) &&
            Utils.enhancedDeepEquals(this.cardToken, other.cardToken) &&
            Utils.enhancedDeepEquals(this.voucherNumber, other.voucherNumber) &&
            Utils.enhancedDeepEquals(this.voucherPin, other.voucherPin) &&
            Utils.enhancedDeepEquals(this.consumerDateOfBirth, other.consumerDateOfBirth) &&
            Utils.enhancedDeepEquals(this.extraMerchantData, other.extraMerchantData) &&
            Utils.enhancedDeepEquals(this.sessionId, other.sessionId) &&
            Utils.enhancedDeepEquals(this.digitalGoods, other.digitalGoods) &&
            Utils.enhancedDeepEquals(this.customerReference, other.customerReference) &&
            Utils.enhancedDeepEquals(this.terminalId, other.terminalId);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            description, amount, redirectUrl,
            cancelUrl, webhookUrl, lines,
            billingAddress, shippingAddress, locale,
            method, issuer, restrictPaymentMethodsToCountry,
            metadata, captureMode, captureDelay,
            applicationFee, routing, sequenceType,
            mandateId, customerId, profileId,
            dueDate, testmode, applePayPaymentToken,
            company, cardToken, voucherNumber,
            voucherPin, consumerDateOfBirth, extraMerchantData,
            sessionId, digitalGoods, customerReference,
            terminalId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreatePaymentRequestBody.class,
                "description", description,
                "amount", amount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "method", method,
                "issuer", issuer,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "dueDate", dueDate,
                "testmode", testmode,
                "applePayPaymentToken", applePayPaymentToken,
                "company", company,
                "cardToken", cardToken,
                "voucherNumber", voucherNumber,
                "voucherPin", voucherPin,
                "consumerDateOfBirth", consumerDateOfBirth,
                "extraMerchantData", extraMerchantData,
                "sessionId", sessionId,
                "digitalGoods", digitalGoods,
                "customerReference", customerReference,
                "terminalId", terminalId);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String description;

        private Amount amount;

        private Optional<String> redirectUrl = Optional.empty();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends List<Lines>> lines = JsonNullable.undefined();

        private Optional<? extends BillingAddress> billingAddress = Optional.empty();

        private Optional<? extends ShippingAddress> shippingAddress = Optional.empty();

        private JsonNullable<? extends CreatePaymentLocale> locale = JsonNullable.undefined();

        private JsonNullable<? extends Method> method = JsonNullable.undefined();

        private JsonNullable<String> issuer = JsonNullable.undefined();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<? extends Metadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends CaptureMode> captureMode = JsonNullable.undefined();

        private JsonNullable<String> captureDelay = JsonNullable.undefined();

        private JsonNullable<? extends ApplicationFee> applicationFee = JsonNullable.undefined();

        private JsonNullable<? extends List<Routing>> routing = JsonNullable.undefined();

        private JsonNullable<? extends SequenceType> sequenceType = JsonNullable.undefined();

        private JsonNullable<String> mandateId = JsonNullable.undefined();

        private JsonNullable<String> customerId = JsonNullable.undefined();

        private Optional<String> profileId = Optional.empty();

        private Optional<String> dueDate = Optional.empty();

        private JsonNullable<Boolean> testmode = JsonNullable.undefined();

        private Optional<String> applePayPaymentToken = Optional.empty();

        private Optional<? extends Company> company = Optional.empty();

        private Optional<String> cardToken = Optional.empty();

        private Optional<String> voucherNumber = Optional.empty();

        private Optional<String> voucherPin = Optional.empty();

        private Optional<LocalDate> consumerDateOfBirth = Optional.empty();

        private Optional<? extends Map<String, Object>> extraMerchantData = Optional.empty();

        private Optional<String> sessionId = Optional.empty();

        private Optional<Boolean> digitalGoods = Optional.empty();

        private Optional<String> customerReference = Optional.empty();

        private Optional<String> terminalId = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
         * retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
         * tip amount.
         */
        public Builder amount(Amount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = Optional.ofNullable(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(Optional<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<Lines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<Lines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(BillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends BillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         */
        public Builder shippingAddress(ShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         */
        public Builder shippingAddress(Optional<? extends ShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
         * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
         * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
         * locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
         * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
         * customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(CreatePaymentLocale locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
         * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
         * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
         * locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
         * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
         * customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<? extends CreatePaymentLocale> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(Method method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment
         * method and your customer will skip the selection screen and is sent directly to the chosen payment method. The
         * parameter enables you to fully integrate the payment method selection into your website.
         * 
         * <p>You can also specify the methods in an array. By doing so we will still show the payment method selection screen
         * but will only show the methods specified in the array. For example, you can use this functionality to only show
         * payment methods from a specific country to your customer `['bancontact', 'belfius']`.
         */
        public Builder method(JsonNullable<? extends Method> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(String issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = JsonNullable.of(issuer);
            return this;
        }

        /**
         * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
         * 
         * <p>**⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information
         * on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
         * 
         * <p>Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment
         * method, the customer may still need to select the appropriate issuer before the payment can proceed.
         * 
         * <p>We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API
         * up front.
         * 
         * <p>The full list of issuers for a specific method can be retrieved via the Methods API by using the optional
         * `issuers` include.
         * 
         * <p>A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
         */
        public Builder issuer(JsonNullable<String> issuer) {
            Utils.checkNotNull(issuer, "issuer");
            this.issuer = issuer;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(CaptureMode captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(JsonNullable<? extends CaptureMode> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }


        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(ApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends ApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(List<Routing> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(JsonNullable<? extends List<Routing>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
         * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
         * on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
         * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
         * are set up correctly for recurring payments.
         */
        public Builder sequenceType(SequenceType sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = JsonNullable.of(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
         * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
         * on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
         * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
         * are set up correctly for recurring payments.
         */
        public Builder sequenceType(JsonNullable<? extends SequenceType> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
         * the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
         * the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
         * payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
         * payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
         * Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = Optional.ofNullable(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
         * Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(Optional<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(String dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = Optional.ofNullable(dueDate);
            return this;
        }

        /**
         * The date by which the payment should be completed in `YYYY-MM-DD` format
         */
        public Builder dueDate(Optional<String> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }


        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = JsonNullable.of(testmode);
            return this;
        }

        /**
         * Whether to create the entity in test mode or live mode.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be
         * omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(JsonNullable<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }


        /**
         * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
         * The token contains the payment information needed to authorize the payment.
         * 
         * <p>The object should be passed encoded in a JSON string.
         */
        public Builder applePayPaymentToken(String applePayPaymentToken) {
            Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
            this.applePayPaymentToken = Optional.ofNullable(applePayPaymentToken);
            return this;
        }

        /**
         * The Apple Pay Payment token object (encoded as JSON) that is part of the result of authorizing a payment request.
         * The token contains the payment information needed to authorize the payment.
         * 
         * <p>The object should be passed encoded in a JSON string.
         */
        public Builder applePayPaymentToken(Optional<String> applePayPaymentToken) {
            Utils.checkNotNull(applePayPaymentToken, "applePayPaymentToken");
            this.applePayPaymentToken = applePayPaymentToken;
            return this;
        }


        /**
         * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
         * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
         * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
         */
        public Builder company(Company company) {
            Utils.checkNotNull(company, "company");
            this.company = Optional.ofNullable(company);
            return this;
        }

        /**
         * Billie is a business-to-business (B2B) payment method. It requires extra information to identify the organization
         * that is completing the payment. It is recommended to include these parameters up front for a seamless flow.
         * Otherwise, Billie will ask the customer to complete the missing fields during checkout.
         */
        public Builder company(Optional<? extends Company> company) {
            Utils.checkNotNull(company, "company");
            this.company = company;
            return this;
        }


        /**
         * When creating credit card payments using Mollie Components, you need to provide the card token you received from
         * the card component in this field. The token represents the customer's card information needed to complete the
         * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
         * enough.
         */
        public Builder cardToken(String cardToken) {
            Utils.checkNotNull(cardToken, "cardToken");
            this.cardToken = Optional.ofNullable(cardToken);
            return this;
        }

        /**
         * When creating credit card payments using Mollie Components, you need to provide the card token you received from
         * the card component in this field. The token represents the customer's card information needed to complete the
         * payment. Note: field only valid for oneoff and first payments. For recurring payments, the customerId alone is
         * enough.
         */
        public Builder cardToken(Optional<String> cardToken) {
            Utils.checkNotNull(cardToken, "cardToken");
            this.cardToken = cardToken;
            return this;
        }


        /**
         * The card token you received from the card component of Mollie Components. The token represents the customer's card
         * information needed to complete the payment.
         */
        public Builder voucherNumber(String voucherNumber) {
            Utils.checkNotNull(voucherNumber, "voucherNumber");
            this.voucherNumber = Optional.ofNullable(voucherNumber);
            return this;
        }

        /**
         * The card token you received from the card component of Mollie Components. The token represents the customer's card
         * information needed to complete the payment.
         */
        public Builder voucherNumber(Optional<String> voucherNumber) {
            Utils.checkNotNull(voucherNumber, "voucherNumber");
            this.voucherNumber = voucherNumber;
            return this;
        }


        /**
         * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
         */
        public Builder voucherPin(String voucherPin) {
            Utils.checkNotNull(voucherPin, "voucherPin");
            this.voucherPin = Optional.ofNullable(voucherPin);
            return this;
        }

        /**
         * The PIN on the gift card. You can supply this to prefill the PIN, if the card has any.
         */
        public Builder voucherPin(Optional<String> voucherPin) {
            Utils.checkNotNull(voucherPin, "voucherPin");
            this.voucherPin = voucherPin;
            return this;
        }


        /**
         * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
         * the payment process.
         */
        public Builder consumerDateOfBirth(LocalDate consumerDateOfBirth) {
            Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
            this.consumerDateOfBirth = Optional.ofNullable(consumerDateOfBirth);
            return this;
        }

        /**
         * The customer's date of birth. If not provided via the API, iDeal in3 will ask the customer to provide it during
         * the payment process.
         */
        public Builder consumerDateOfBirth(Optional<LocalDate> consumerDateOfBirth) {
            Utils.checkNotNull(consumerDateOfBirth, "consumerDateOfBirth");
            this.consumerDateOfBirth = consumerDateOfBirth;
            return this;
        }


        /**
         * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
         * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
         * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
         */
        public Builder extraMerchantData(Map<String, Object> extraMerchantData) {
            Utils.checkNotNull(extraMerchantData, "extraMerchantData");
            this.extraMerchantData = Optional.ofNullable(extraMerchantData);
            return this;
        }

        /**
         * For some industries, additional purchase information can be sent to Klarna to increase the authorization rate.
         * You can submit your extra data in this field if you have agreed upon this with Klarna. This field should be an
         * object containing any of the allowed keys and sub-objects described at the Klarna Developer Documentation.
         */
        public Builder extraMerchantData(Optional<? extends Map<String, Object>> extraMerchantData) {
            Utils.checkNotNull(extraMerchantData, "extraMerchantData");
            this.extraMerchantData = extraMerchantData;
            return this;
        }


        /**
         * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
         * on-demand payment.
         */
        public Builder sessionId(String sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = Optional.ofNullable(sessionId);
            return this;
        }

        /**
         * The unique ID you have used for the PayPal fraud library. You should include this if you use PayPal for an
         * on-demand payment.
         */
        public Builder sessionId(Optional<String> sessionId) {
            Utils.checkNotNull(sessionId, "sessionId");
            this.sessionId = sessionId;
            return this;
        }


        /**
         * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
         * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
         */
        public Builder digitalGoods(boolean digitalGoods) {
            Utils.checkNotNull(digitalGoods, "digitalGoods");
            this.digitalGoods = Optional.ofNullable(digitalGoods);
            return this;
        }

        /**
         * Indicate if you are about to deliver digital goods, such as for example a software license. Setting this parameter
         * can have consequences for your PayPal Seller Protection. Refer to PayPal's documentation for more information.
         */
        public Builder digitalGoods(Optional<Boolean> digitalGoods) {
            Utils.checkNotNull(digitalGoods, "digitalGoods");
            this.digitalGoods = digitalGoods;
            return this;
        }


        /**
         * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
         * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
         */
        public Builder customerReference(String customerReference) {
            Utils.checkNotNull(customerReference, "customerReference");
            this.customerReference = Optional.ofNullable(customerReference);
            return this;
        }

        /**
         * Used by paysafecard for customer identification across payments. When you generate a customer reference yourself,
         * make sure not to put personal identifiable information or IP addresses in the customer reference directly.
         */
        public Builder customerReference(Optional<String> customerReference) {
            Utils.checkNotNull(customerReference, "customerReference");
            this.customerReference = customerReference;
            return this;
        }


        /**
         * The ID of the terminal device where you want to initiate the payment on.
         */
        public Builder terminalId(String terminalId) {
            Utils.checkNotNull(terminalId, "terminalId");
            this.terminalId = Optional.ofNullable(terminalId);
            return this;
        }

        /**
         * The ID of the terminal device where you want to initiate the payment on.
         */
        public Builder terminalId(Optional<String> terminalId) {
            Utils.checkNotNull(terminalId, "terminalId");
            this.terminalId = terminalId;
            return this;
        }

        public CreatePaymentRequestBody build() {

            return new CreatePaymentRequestBody(
                description, amount, redirectUrl,
                cancelUrl, webhookUrl, lines,
                billingAddress, shippingAddress, locale,
                method, issuer, restrictPaymentMethodsToCountry,
                metadata, captureMode, captureDelay,
                applicationFee, routing, sequenceType,
                mandateId, customerId, profileId,
                dueDate, testmode, applePayPaymentToken,
                company, cardToken, voucherNumber,
                voucherPin, consumerDateOfBirth, extraMerchantData,
                sessionId, digitalGoods, customerReference,
                terminalId);
        }

    }
}
