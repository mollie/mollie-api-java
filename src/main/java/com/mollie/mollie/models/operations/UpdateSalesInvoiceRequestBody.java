/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.models.components.SalesInvoiceDiscount;
import com.mollie.mollie.models.components.SalesInvoiceEmailDetails;
import com.mollie.mollie.models.components.SalesInvoiceLineItem;
import com.mollie.mollie.models.components.SalesInvoicePaymentDetails;
import com.mollie.mollie.models.components.SalesInvoicePaymentTerm;
import com.mollie.mollie.models.components.SalesInvoiceRecipient;
import com.mollie.mollie.models.components.SalesInvoiceStatus;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class UpdateSalesInvoiceRequestBody {
    /**
     * Whether the entity was created in test mode or live mode. This field does not update the mode of the
     * entity.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
     * parameter must
     * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
     * mode by setting
     * `testmode` to `true`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("testmode")
    private Optional<Boolean> testmode;

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
     * sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this
     * to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     * - `paymentDetails` is required if invoice should be set directly to `paid`
     * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
     * to `paid`
     * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends SalesInvoiceStatus> status;

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;

    /**
     * The payment term to be set on the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paymentTerm")
    private JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paymentDetails")
    private Optional<? extends SalesInvoicePaymentDetails> paymentDetails;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("emailDetails")
    private JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails;

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system
     * contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that
     * recipient management
     * is not required to send a first invoice to a recipient.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipientIdentifier")
    private Optional<String> recipientIdentifier;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipient")
    private JsonNullable<? extends SalesInvoiceRecipient> recipient;

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<SalesInvoiceLineItem>> lines;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discount")
    private JsonNullable<? extends SalesInvoiceDiscount> discount;

    @JsonCreator
    public UpdateSalesInvoiceRequestBody(
            @JsonProperty("testmode") Optional<Boolean> testmode,
            @JsonProperty("status") Optional<? extends SalesInvoiceStatus> status,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("paymentTerm") JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm,
            @JsonProperty("paymentDetails") Optional<? extends SalesInvoicePaymentDetails> paymentDetails,
            @JsonProperty("emailDetails") JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails,
            @JsonProperty("recipientIdentifier") Optional<String> recipientIdentifier,
            @JsonProperty("recipient") JsonNullable<? extends SalesInvoiceRecipient> recipient,
            @JsonProperty("lines") JsonNullable<? extends List<SalesInvoiceLineItem>> lines,
            @JsonProperty("discount") JsonNullable<? extends SalesInvoiceDiscount> discount) {
        Utils.checkNotNull(testmode, "testmode");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        Utils.checkNotNull(emailDetails, "emailDetails");
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        Utils.checkNotNull(recipient, "recipient");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(discount, "discount");
        this.testmode = testmode;
        this.status = status;
        this.memo = memo;
        this.paymentTerm = paymentTerm;
        this.paymentDetails = paymentDetails;
        this.emailDetails = emailDetails;
        this.recipientIdentifier = recipientIdentifier;
        this.recipient = recipient;
        this.lines = lines;
        this.discount = discount;
    }
    
    public UpdateSalesInvoiceRequestBody() {
        this(Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined());
    }

    /**
     * Whether the entity was created in test mode or live mode. This field does not update the mode of the
     * entity.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
     * parameter must
     * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
     * mode by setting
     * `testmode` to `true`.
     */
    @JsonIgnore
    public Optional<Boolean> testmode() {
        return testmode;
    }

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
     * sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this
     * to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     * - `paymentDetails` is required if invoice should be set directly to `paid`
     * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
     * to `paid`
     * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SalesInvoiceStatus> status() {
        return (Optional<SalesInvoiceStatus>) status;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    /**
     * The payment term to be set on the invoice.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoicePaymentTerm> paymentTerm() {
        return (JsonNullable<SalesInvoicePaymentTerm>) paymentTerm;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SalesInvoicePaymentDetails> paymentDetails() {
        return (Optional<SalesInvoicePaymentDetails>) paymentDetails;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceEmailDetails> emailDetails() {
        return (JsonNullable<SalesInvoiceEmailDetails>) emailDetails;
    }

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system
     * contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that
     * recipient management
     * is not required to send a first invoice to a recipient.
     */
    @JsonIgnore
    public Optional<String> recipientIdentifier() {
        return recipientIdentifier;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceRecipient> recipient() {
        return (JsonNullable<SalesInvoiceRecipient>) recipient;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<SalesInvoiceLineItem>> lines() {
        return (JsonNullable<List<SalesInvoiceLineItem>>) lines;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<SalesInvoiceDiscount> discount() {
        return (JsonNullable<SalesInvoiceDiscount>) discount;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Whether the entity was created in test mode or live mode. This field does not update the mode of the
     * entity.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
     * parameter must
     * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
     * mode by setting
     * `testmode` to `true`.
     */
    public UpdateSalesInvoiceRequestBody withTestmode(boolean testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = Optional.ofNullable(testmode);
        return this;
    }


    /**
     * Whether the entity was created in test mode or live mode. This field does not update the mode of the
     * entity.
     * 
     * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
     * parameter must
     * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
     * mode by setting
     * `testmode` to `true`.
     */
    public UpdateSalesInvoiceRequestBody withTestmode(Optional<Boolean> testmode) {
        Utils.checkNotNull(testmode, "testmode");
        this.testmode = testmode;
        return this;
    }

    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
     * sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this
     * to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     * - `paymentDetails` is required if invoice should be set directly to `paid`
     * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
     * to `paid`
     * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    public UpdateSalesInvoiceRequestBody withStatus(SalesInvoiceStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }


    /**
     * The status for the invoice to end up in.
     * 
     * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
     * sends it to
     * the recipient so they may then pay through our payment system. To skip our payment process, set this
     * to `paid` to
     * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
     * 
     * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
     * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
     * 
     * <p>Dependent parameters:
     * - `paymentDetails` is required if invoice should be set directly to `paid`
     * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
     * to `paid`
     * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
     */
    public UpdateSalesInvoiceRequestBody withStatus(Optional<? extends SalesInvoiceStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    public UpdateSalesInvoiceRequestBody withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
     */
    public UpdateSalesInvoiceRequestBody withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    /**
     * The payment term to be set on the invoice.
     */
    public UpdateSalesInvoiceRequestBody withPaymentTerm(SalesInvoicePaymentTerm paymentTerm) {
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        this.paymentTerm = JsonNullable.of(paymentTerm);
        return this;
    }

    /**
     * The payment term to be set on the invoice.
     */
    public UpdateSalesInvoiceRequestBody withPaymentTerm(JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm) {
        Utils.checkNotNull(paymentTerm, "paymentTerm");
        this.paymentTerm = paymentTerm;
        return this;
    }

    public UpdateSalesInvoiceRequestBody withPaymentDetails(SalesInvoicePaymentDetails paymentDetails) {
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        this.paymentDetails = Optional.ofNullable(paymentDetails);
        return this;
    }


    public UpdateSalesInvoiceRequestBody withPaymentDetails(Optional<? extends SalesInvoicePaymentDetails> paymentDetails) {
        Utils.checkNotNull(paymentDetails, "paymentDetails");
        this.paymentDetails = paymentDetails;
        return this;
    }

    public UpdateSalesInvoiceRequestBody withEmailDetails(SalesInvoiceEmailDetails emailDetails) {
        Utils.checkNotNull(emailDetails, "emailDetails");
        this.emailDetails = JsonNullable.of(emailDetails);
        return this;
    }

    public UpdateSalesInvoiceRequestBody withEmailDetails(JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails) {
        Utils.checkNotNull(emailDetails, "emailDetails");
        this.emailDetails = emailDetails;
        return this;
    }

    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system
     * contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that
     * recipient management
     * is not required to send a first invoice to a recipient.
     */
    public UpdateSalesInvoiceRequestBody withRecipientIdentifier(String recipientIdentifier) {
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        this.recipientIdentifier = Optional.ofNullable(recipientIdentifier);
        return this;
    }


    /**
     * An identifier tied to the recipient data. This should be a unique value based on data your system
     * contains,
     * so that both you and us know who we're referring to. It is a value you provide to us so that
     * recipient management
     * is not required to send a first invoice to a recipient.
     */
    public UpdateSalesInvoiceRequestBody withRecipientIdentifier(Optional<String> recipientIdentifier) {
        Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
        this.recipientIdentifier = recipientIdentifier;
        return this;
    }

    public UpdateSalesInvoiceRequestBody withRecipient(SalesInvoiceRecipient recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = JsonNullable.of(recipient);
        return this;
    }

    public UpdateSalesInvoiceRequestBody withRecipient(JsonNullable<? extends SalesInvoiceRecipient> recipient) {
        Utils.checkNotNull(recipient, "recipient");
        this.recipient = recipient;
        return this;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    public UpdateSalesInvoiceRequestBody withLines(List<SalesInvoiceLineItem> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Provide the line items for the invoice. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the invoice.
     */
    public UpdateSalesInvoiceRequestBody withLines(JsonNullable<? extends List<SalesInvoiceLineItem>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    public UpdateSalesInvoiceRequestBody withDiscount(SalesInvoiceDiscount discount) {
        Utils.checkNotNull(discount, "discount");
        this.discount = JsonNullable.of(discount);
        return this;
    }

    public UpdateSalesInvoiceRequestBody withDiscount(JsonNullable<? extends SalesInvoiceDiscount> discount) {
        Utils.checkNotNull(discount, "discount");
        this.discount = discount;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UpdateSalesInvoiceRequestBody other = (UpdateSalesInvoiceRequestBody) o;
        return 
            Utils.enhancedDeepEquals(this.testmode, other.testmode) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.paymentTerm, other.paymentTerm) &&
            Utils.enhancedDeepEquals(this.paymentDetails, other.paymentDetails) &&
            Utils.enhancedDeepEquals(this.emailDetails, other.emailDetails) &&
            Utils.enhancedDeepEquals(this.recipientIdentifier, other.recipientIdentifier) &&
            Utils.enhancedDeepEquals(this.recipient, other.recipient) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.discount, other.discount);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            testmode, status, memo,
            paymentTerm, paymentDetails, emailDetails,
            recipientIdentifier, recipient, lines,
            discount);
    }
    
    @Override
    public String toString() {
        return Utils.toString(UpdateSalesInvoiceRequestBody.class,
                "testmode", testmode,
                "status", status,
                "memo", memo,
                "paymentTerm", paymentTerm,
                "paymentDetails", paymentDetails,
                "emailDetails", emailDetails,
                "recipientIdentifier", recipientIdentifier,
                "recipient", recipient,
                "lines", lines,
                "discount", discount);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<Boolean> testmode = Optional.empty();

        private Optional<? extends SalesInvoiceStatus> status = Optional.empty();

        private JsonNullable<String> memo = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm = JsonNullable.undefined();

        private Optional<? extends SalesInvoicePaymentDetails> paymentDetails = Optional.empty();

        private JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails = JsonNullable.undefined();

        private Optional<String> recipientIdentifier = Optional.empty();

        private JsonNullable<? extends SalesInvoiceRecipient> recipient = JsonNullable.undefined();

        private JsonNullable<? extends List<SalesInvoiceLineItem>> lines = JsonNullable.undefined();

        private JsonNullable<? extends SalesInvoiceDiscount> discount = JsonNullable.undefined();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Whether the entity was created in test mode or live mode. This field does not update the mode of the
         * entity.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
         * parameter must
         * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
         * mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(boolean testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = Optional.ofNullable(testmode);
            return this;
        }

        /**
         * Whether the entity was created in test mode or live mode. This field does not update the mode of the
         * entity.
         * 
         * <p>Most API credentials are specifically created for either live mode or test mode, in which case this
         * parameter must
         * not be sent. For organization-level credentials such as OAuth access tokens, you can enable test
         * mode by setting
         * `testmode` to `true`.
         */
        public Builder testmode(Optional<Boolean> testmode) {
            Utils.checkNotNull(testmode, "testmode");
            this.testmode = testmode;
            return this;
        }


        /**
         * The status for the invoice to end up in.
         * 
         * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
         * sends it to
         * the recipient so they may then pay through our payment system. To skip our payment process, set this
         * to `paid` to
         * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
         * 
         * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
         * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
         * 
         * <p>Dependent parameters:
         * - `paymentDetails` is required if invoice should be set directly to `paid`
         * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
         * to `paid`
         * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
         */
        public Builder status(SalesInvoiceStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The status for the invoice to end up in.
         * 
         * <p>A `draft` invoice is not paid or not sent and can be updated after creation. Setting it to `issued`
         * sends it to
         * the recipient so they may then pay through our payment system. To skip our payment process, set this
         * to `paid` to
         * mark it as paid. It can then subsequently be sent as well, same as with `issued`.
         * 
         * <p>A status value that cannot be set but can be returned is `canceled`, for invoices which were
         * issued, but then canceled. Currently this can only be done for invoices created in the dashboard.
         * 
         * <p>Dependent parameters:
         * - `paymentDetails` is required if invoice should be set directly to `paid`
         * - `customerId` and `mandateId` are required if a recurring payment should be used to set the invoice
         * to `paid`
         * - `emailDetails` optional for `issued` and `paid` to send the invoice by email
         */
        public Builder status(Optional<? extends SalesInvoiceStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * A free-form memo you can set on the invoice, and will be shown on the invoice PDF.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }


        /**
         * The payment term to be set on the invoice.
         */
        public Builder paymentTerm(SalesInvoicePaymentTerm paymentTerm) {
            Utils.checkNotNull(paymentTerm, "paymentTerm");
            this.paymentTerm = JsonNullable.of(paymentTerm);
            return this;
        }

        /**
         * The payment term to be set on the invoice.
         */
        public Builder paymentTerm(JsonNullable<? extends SalesInvoicePaymentTerm> paymentTerm) {
            Utils.checkNotNull(paymentTerm, "paymentTerm");
            this.paymentTerm = paymentTerm;
            return this;
        }


        public Builder paymentDetails(SalesInvoicePaymentDetails paymentDetails) {
            Utils.checkNotNull(paymentDetails, "paymentDetails");
            this.paymentDetails = Optional.ofNullable(paymentDetails);
            return this;
        }

        public Builder paymentDetails(Optional<? extends SalesInvoicePaymentDetails> paymentDetails) {
            Utils.checkNotNull(paymentDetails, "paymentDetails");
            this.paymentDetails = paymentDetails;
            return this;
        }


        public Builder emailDetails(SalesInvoiceEmailDetails emailDetails) {
            Utils.checkNotNull(emailDetails, "emailDetails");
            this.emailDetails = JsonNullable.of(emailDetails);
            return this;
        }

        public Builder emailDetails(JsonNullable<? extends SalesInvoiceEmailDetails> emailDetails) {
            Utils.checkNotNull(emailDetails, "emailDetails");
            this.emailDetails = emailDetails;
            return this;
        }


        /**
         * An identifier tied to the recipient data. This should be a unique value based on data your system
         * contains,
         * so that both you and us know who we're referring to. It is a value you provide to us so that
         * recipient management
         * is not required to send a first invoice to a recipient.
         */
        public Builder recipientIdentifier(String recipientIdentifier) {
            Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
            this.recipientIdentifier = Optional.ofNullable(recipientIdentifier);
            return this;
        }

        /**
         * An identifier tied to the recipient data. This should be a unique value based on data your system
         * contains,
         * so that both you and us know who we're referring to. It is a value you provide to us so that
         * recipient management
         * is not required to send a first invoice to a recipient.
         */
        public Builder recipientIdentifier(Optional<String> recipientIdentifier) {
            Utils.checkNotNull(recipientIdentifier, "recipientIdentifier");
            this.recipientIdentifier = recipientIdentifier;
            return this;
        }


        public Builder recipient(SalesInvoiceRecipient recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = JsonNullable.of(recipient);
            return this;
        }

        public Builder recipient(JsonNullable<? extends SalesInvoiceRecipient> recipient) {
            Utils.checkNotNull(recipient, "recipient");
            this.recipient = recipient;
            return this;
        }


        /**
         * Provide the line items for the invoice. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the invoice.
         */
        public Builder lines(List<SalesInvoiceLineItem> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Provide the line items for the invoice. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the invoice.
         */
        public Builder lines(JsonNullable<? extends List<SalesInvoiceLineItem>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        public Builder discount(SalesInvoiceDiscount discount) {
            Utils.checkNotNull(discount, "discount");
            this.discount = JsonNullable.of(discount);
            return this;
        }

        public Builder discount(JsonNullable<? extends SalesInvoiceDiscount> discount) {
            Utils.checkNotNull(discount, "discount");
            this.discount = discount;
            return this;
        }

        public UpdateSalesInvoiceRequestBody build() {

            return new UpdateSalesInvoiceRequestBody(
                testmode, status, memo,
                paymentTerm, paymentDetails, emailDetails,
                recipientIdentifier, recipient, lines,
                discount);
        }

    }
}
