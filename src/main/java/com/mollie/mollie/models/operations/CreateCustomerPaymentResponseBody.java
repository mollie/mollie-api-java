/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * CreateCustomerPaymentResponseBody
 * 
 * <p>The newly created payment object.
 */
public class CreateCustomerPaymentResponseBody {
    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonProperty("resource")
    private String resource;

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonProperty("id")
    private String id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonProperty("mode")
    private String mode;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonProperty("description")
    private String description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonProperty("amount")
    private CreateCustomerPaymentCustomersResponseAmount amount;

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private Optional<? extends CreateCustomerPaymentAmountRefunded> amountRefunded;

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private Optional<? extends CreateCustomerPaymentAmountRemaining> amountRemaining;

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private Optional<? extends CreateCustomerPaymentAmountCaptured> amountCaptured;

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private Optional<? extends CreateCustomerPaymentAmountChargedBack> amountChargedBack;

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private Optional<? extends CreateCustomerPaymentSettlementAmount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<CreateCustomerPaymentCustomersLines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends CreateCustomerPaymentCustomersBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends CreateCustomerPaymentCustomersShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<String> locale;

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    private JsonNullable<String> countryCode;

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends CreateCustomerPaymentCustomersMetadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<String> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<String> captureDelay;

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureBefore")
    private JsonNullable<String> captureBefore;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends CreateCustomerPaymentCustomersApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<CreateCustomerPaymentCustomersRouting>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("sequenceType")
    private Optional<String> sequenceType;

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private JsonNullable<String> subscriptionId;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonProperty("profileId")
    private String profileId;

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private JsonNullable<String> settlementId;

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private JsonNullable<String> orderId;

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonProperty("status")
    private String status;

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusReason")
    private JsonNullable<? extends CreateCustomerPaymentStatusReason> statusReason;

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    private JsonNullable<? extends Map<String, Object>> details;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonProperty("createdAt")
    private String createdAt;

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("failedAt")
    private JsonNullable<String> failedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonProperty("_links")
    private CreateCustomerPaymentCustomersLinks links;

    @JsonCreator
    public CreateCustomerPaymentResponseBody(
            @JsonProperty("resource") String resource,
            @JsonProperty("id") String id,
            @JsonProperty("mode") String mode,
            @JsonProperty("description") String description,
            @JsonProperty("amount") CreateCustomerPaymentCustomersResponseAmount amount,
            @JsonProperty("amountRefunded") Optional<? extends CreateCustomerPaymentAmountRefunded> amountRefunded,
            @JsonProperty("amountRemaining") Optional<? extends CreateCustomerPaymentAmountRemaining> amountRemaining,
            @JsonProperty("amountCaptured") Optional<? extends CreateCustomerPaymentAmountCaptured> amountCaptured,
            @JsonProperty("amountChargedBack") Optional<? extends CreateCustomerPaymentAmountChargedBack> amountChargedBack,
            @JsonProperty("settlementAmount") Optional<? extends CreateCustomerPaymentSettlementAmount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<CreateCustomerPaymentCustomersLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends CreateCustomerPaymentCustomersBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends CreateCustomerPaymentCustomersShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<String> locale,
            @JsonProperty("countryCode") JsonNullable<String> countryCode,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends CreateCustomerPaymentCustomersMetadata> metadata,
            @JsonProperty("captureMode") JsonNullable<String> captureMode,
            @JsonProperty("captureDelay") JsonNullable<String> captureDelay,
            @JsonProperty("captureBefore") JsonNullable<String> captureBefore,
            @JsonProperty("applicationFee") JsonNullable<? extends CreateCustomerPaymentCustomersApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<CreateCustomerPaymentCustomersRouting>> routing,
            @JsonProperty("sequenceType") Optional<String> sequenceType,
            @JsonProperty("subscriptionId") JsonNullable<String> subscriptionId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") String profileId,
            @JsonProperty("settlementId") JsonNullable<String> settlementId,
            @JsonProperty("orderId") JsonNullable<String> orderId,
            @JsonProperty("status") String status,
            @JsonProperty("statusReason") JsonNullable<? extends CreateCustomerPaymentStatusReason> statusReason,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("details") JsonNullable<? extends Map<String, Object>> details,
            @JsonProperty("createdAt") String createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("failedAt") JsonNullable<String> failedAt,
            @JsonProperty("_links") CreateCustomerPaymentCustomersLinks links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(countryCode, "countryCode");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(captureBefore, "captureBefore");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusReason, "statusReason");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(details, "details");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(failedAt, "failedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.countryCode = countryCode;
        this.method = method;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.captureBefore = captureBefore;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.status = status;
        this.statusReason = statusReason;
        this.isCancelable = isCancelable;
        this.details = details;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.failedAt = failedAt;
        this.links = links;
    }
    
    public CreateCustomerPaymentResponseBody(
            String resource,
            String id,
            String mode,
            String description,
            CreateCustomerPaymentCustomersResponseAmount amount,
            String profileId,
            String status,
            String createdAt,
            CreateCustomerPaymentCustomersLinks links) {
        this(resource, id, mode,
            description, amount, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            profileId, JsonNullable.undefined(), JsonNullable.undefined(),
            status, JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), createdAt, JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), links);
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonIgnore
    public String resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    @JsonIgnore
    public String mode() {
        return mode;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    @JsonIgnore
    public CreateCustomerPaymentCustomersResponseAmount amount() {
        return amount;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentAmountRefunded> amountRefunded() {
        return (Optional<CreateCustomerPaymentAmountRefunded>) amountRefunded;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentAmountRemaining> amountRemaining() {
        return (Optional<CreateCustomerPaymentAmountRemaining>) amountRemaining;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentAmountCaptured> amountCaptured() {
        return (Optional<CreateCustomerPaymentAmountCaptured>) amountCaptured;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentAmountChargedBack> amountChargedBack() {
        return (Optional<CreateCustomerPaymentAmountChargedBack>) amountChargedBack;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentSettlementAmount> settlementAmount() {
        return (Optional<CreateCustomerPaymentSettlementAmount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreateCustomerPaymentCustomersLines>> lines() {
        return (JsonNullable<List<CreateCustomerPaymentCustomersLines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentCustomersBillingAddress> billingAddress() {
        return (Optional<CreateCustomerPaymentCustomersBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreateCustomerPaymentCustomersShippingAddress> shippingAddress() {
        return (Optional<CreateCustomerPaymentCustomersShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonIgnore
    public JsonNullable<String> locale() {
        return locale;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    @JsonIgnore
    public JsonNullable<String> countryCode() {
        return countryCode;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateCustomerPaymentCustomersMetadata> metadata() {
        return (JsonNullable<CreateCustomerPaymentCustomersMetadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    @JsonIgnore
    public JsonNullable<String> captureMode() {
        return captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    @JsonIgnore
    public JsonNullable<String> captureDelay() {
        return captureDelay;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> captureBefore() {
        return captureBefore;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateCustomerPaymentCustomersApplicationFee> applicationFee() {
        return (JsonNullable<CreateCustomerPaymentCustomersApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<CreateCustomerPaymentCustomersRouting>> routing() {
        return (JsonNullable<List<CreateCustomerPaymentCustomersRouting>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    @JsonIgnore
    public Optional<String> sequenceType() {
        return sequenceType;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    @JsonIgnore
    public JsonNullable<String> subscriptionId() {
        return subscriptionId;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public String profileId() {
        return profileId;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonIgnore
    public JsonNullable<String> settlementId() {
        return settlementId;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonIgnore
    public JsonNullable<String> orderId() {
        return orderId;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    @JsonIgnore
    public String status() {
        return status;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CreateCustomerPaymentStatusReason> statusReason() {
        return (JsonNullable<CreateCustomerPaymentStatusReason>) statusReason;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> details() {
        return (JsonNullable<Map<String, Object>>) details;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public String createdAt() {
        return createdAt;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    @JsonIgnore
    public JsonNullable<String> failedAt() {
        return failedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonIgnore
    public CreateCustomerPaymentCustomersLinks links() {
        return links;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    public CreateCustomerPaymentResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    public CreateCustomerPaymentResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * <p>Possible values: `live` `test`
     */
    public CreateCustomerPaymentResponseBody withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public CreateCustomerPaymentResponseBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
     */
    public CreateCustomerPaymentResponseBody withAmount(CreateCustomerPaymentCustomersResponseAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public CreateCustomerPaymentResponseBody withAmountRefunded(CreateCustomerPaymentAmountRefunded amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = Optional.ofNullable(amountRefunded);
        return this;
    }


    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
     */
    public CreateCustomerPaymentResponseBody withAmountRefunded(Optional<? extends CreateCustomerPaymentAmountRefunded> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public CreateCustomerPaymentResponseBody withAmountRemaining(CreateCustomerPaymentAmountRemaining amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = Optional.ofNullable(amountRemaining);
        return this;
    }


    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public CreateCustomerPaymentResponseBody withAmountRemaining(Optional<? extends CreateCustomerPaymentAmountRemaining> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public CreateCustomerPaymentResponseBody withAmountCaptured(CreateCustomerPaymentAmountCaptured amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = Optional.ofNullable(amountCaptured);
        return this;
    }


    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public CreateCustomerPaymentResponseBody withAmountCaptured(Optional<? extends CreateCustomerPaymentAmountCaptured> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public CreateCustomerPaymentResponseBody withAmountChargedBack(CreateCustomerPaymentAmountChargedBack amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = Optional.ofNullable(amountChargedBack);
        return this;
    }


    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
     */
    public CreateCustomerPaymentResponseBody withAmountChargedBack(Optional<? extends CreateCustomerPaymentAmountChargedBack> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public CreateCustomerPaymentResponseBody withSettlementAmount(CreateCustomerPaymentSettlementAmount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = Optional.ofNullable(settlementAmount);
        return this;
    }


    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public CreateCustomerPaymentResponseBody withSettlementAmount(Optional<? extends CreateCustomerPaymentSettlementAmount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateCustomerPaymentResponseBody withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
     */
    public CreateCustomerPaymentResponseBody withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateCustomerPaymentResponseBody withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
     */
    public CreateCustomerPaymentResponseBody withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateCustomerPaymentResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
     */
    public CreateCustomerPaymentResponseBody withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreateCustomerPaymentResponseBody withLines(List<CreateCustomerPaymentCustomersLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public CreateCustomerPaymentResponseBody withLines(JsonNullable<? extends List<CreateCustomerPaymentCustomersLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreateCustomerPaymentResponseBody withBillingAddress(CreateCustomerPaymentCustomersBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public CreateCustomerPaymentResponseBody withBillingAddress(Optional<? extends CreateCustomerPaymentCustomersBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreateCustomerPaymentResponseBody withShippingAddress(CreateCustomerPaymentCustomersShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
     */
    public CreateCustomerPaymentResponseBody withShippingAddress(Optional<? extends CreateCustomerPaymentCustomersShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreateCustomerPaymentResponseBody withLocale(String locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public CreateCustomerPaymentResponseBody withLocale(JsonNullable<String> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public CreateCustomerPaymentResponseBody withCountryCode(String countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = JsonNullable.of(countryCode);
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
     */
    public CreateCustomerPaymentResponseBody withCountryCode(JsonNullable<String> countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = countryCode;
        return this;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
     */
    public CreateCustomerPaymentResponseBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
     */
    public CreateCustomerPaymentResponseBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreateCustomerPaymentResponseBody withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public CreateCustomerPaymentResponseBody withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateCustomerPaymentResponseBody withMetadata(CreateCustomerPaymentCustomersMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public CreateCustomerPaymentResponseBody withMetadata(JsonNullable<? extends CreateCustomerPaymentCustomersMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreateCustomerPaymentResponseBody withCaptureMode(String captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     * 
     * <p>Possible values: `automatic` `manual` (default: `automatic`)
     */
    public CreateCustomerPaymentResponseBody withCaptureMode(JsonNullable<String> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreateCustomerPaymentResponseBody withCaptureDelay(String captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     * 
     * <p>Possible values: `... hours` `... days`
     */
    public CreateCustomerPaymentResponseBody withCaptureDelay(JsonNullable<String> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public CreateCustomerPaymentResponseBody withCaptureBefore(String captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = JsonNullable.of(captureBefore);
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public CreateCustomerPaymentResponseBody withCaptureBefore(JsonNullable<String> captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = captureBefore;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreateCustomerPaymentResponseBody withApplicationFee(CreateCustomerPaymentCustomersApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
     */
    public CreateCustomerPaymentResponseBody withApplicationFee(JsonNullable<? extends CreateCustomerPaymentCustomersApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreateCustomerPaymentResponseBody withRouting(List<CreateCustomerPaymentCustomersRouting> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
     */
    public CreateCustomerPaymentResponseBody withRouting(JsonNullable<? extends List<CreateCustomerPaymentCustomersRouting>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreateCustomerPaymentResponseBody withSequenceType(String sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = Optional.ofNullable(sequenceType);
        return this;
    }


    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
     * 
     * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
     */
    public CreateCustomerPaymentResponseBody withSequenceType(Optional<String> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public CreateCustomerPaymentResponseBody withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = JsonNullable.of(subscriptionId);
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
     */
    public CreateCustomerPaymentResponseBody withSubscriptionId(JsonNullable<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreateCustomerPaymentResponseBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
     */
    public CreateCustomerPaymentResponseBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreateCustomerPaymentResponseBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public CreateCustomerPaymentResponseBody withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public CreateCustomerPaymentResponseBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public CreateCustomerPaymentResponseBody withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = JsonNullable.of(settlementId);
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public CreateCustomerPaymentResponseBody withSettlementId(JsonNullable<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public CreateCustomerPaymentResponseBody withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = JsonNullable.of(orderId);
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public CreateCustomerPaymentResponseBody withOrderId(JsonNullable<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
     * 
     * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
     */
    public CreateCustomerPaymentResponseBody withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public CreateCustomerPaymentResponseBody withStatusReason(CreateCustomerPaymentStatusReason statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = JsonNullable.of(statusReason);
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
     * 
     * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
     */
    public CreateCustomerPaymentResponseBody withStatusReason(JsonNullable<? extends CreateCustomerPaymentStatusReason> statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = statusReason;
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public CreateCustomerPaymentResponseBody withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public CreateCustomerPaymentResponseBody withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public CreateCustomerPaymentResponseBody withDetails(Map<String, Object> details) {
        Utils.checkNotNull(details, "details");
        this.details = JsonNullable.of(details);
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
     */
    public CreateCustomerPaymentResponseBody withDetails(JsonNullable<? extends Map<String, Object>> details) {
        Utils.checkNotNull(details, "details");
        this.details = details;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public CreateCustomerPaymentResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public CreateCustomerPaymentResponseBody withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
     */
    public CreateCustomerPaymentResponseBody withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public CreateCustomerPaymentResponseBody withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
     */
    public CreateCustomerPaymentResponseBody withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public CreateCustomerPaymentResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
     */
    public CreateCustomerPaymentResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public CreateCustomerPaymentResponseBody withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
     */
    public CreateCustomerPaymentResponseBody withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public CreateCustomerPaymentResponseBody withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
     */
    public CreateCustomerPaymentResponseBody withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public CreateCustomerPaymentResponseBody withFailedAt(String failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = JsonNullable.of(failedAt);
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
     */
    public CreateCustomerPaymentResponseBody withFailedAt(JsonNullable<String> failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = failedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public CreateCustomerPaymentResponseBody withLinks(CreateCustomerPaymentCustomersLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreateCustomerPaymentResponseBody other = (CreateCustomerPaymentResponseBody) o;
        return 
            Utils.enhancedDeepEquals(this.resource, other.resource) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.mode, other.mode) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.amountRefunded, other.amountRefunded) &&
            Utils.enhancedDeepEquals(this.amountRemaining, other.amountRemaining) &&
            Utils.enhancedDeepEquals(this.amountCaptured, other.amountCaptured) &&
            Utils.enhancedDeepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Utils.enhancedDeepEquals(this.settlementAmount, other.settlementAmount) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.countryCode, other.countryCode) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.captureMode, other.captureMode) &&
            Utils.enhancedDeepEquals(this.captureDelay, other.captureDelay) &&
            Utils.enhancedDeepEquals(this.captureBefore, other.captureBefore) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.routing, other.routing) &&
            Utils.enhancedDeepEquals(this.sequenceType, other.sequenceType) &&
            Utils.enhancedDeepEquals(this.subscriptionId, other.subscriptionId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.settlementId, other.settlementId) &&
            Utils.enhancedDeepEquals(this.orderId, other.orderId) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.statusReason, other.statusReason) &&
            Utils.enhancedDeepEquals(this.isCancelable, other.isCancelable) &&
            Utils.enhancedDeepEquals(this.details, other.details) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.authorizedAt, other.authorizedAt) &&
            Utils.enhancedDeepEquals(this.paidAt, other.paidAt) &&
            Utils.enhancedDeepEquals(this.canceledAt, other.canceledAt) &&
            Utils.enhancedDeepEquals(this.expiresAt, other.expiresAt) &&
            Utils.enhancedDeepEquals(this.expiredAt, other.expiredAt) &&
            Utils.enhancedDeepEquals(this.failedAt, other.failedAt) &&
            Utils.enhancedDeepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            resource, id, mode,
            description, amount, amountRefunded,
            amountRemaining, amountCaptured, amountChargedBack,
            settlementAmount, redirectUrl, cancelUrl,
            webhookUrl, lines, billingAddress,
            shippingAddress, locale, countryCode,
            method, restrictPaymentMethodsToCountry, metadata,
            captureMode, captureDelay, captureBefore,
            applicationFee, routing, sequenceType,
            subscriptionId, mandateId, customerId,
            profileId, settlementId, orderId,
            status, statusReason, isCancelable,
            details, createdAt, authorizedAt,
            paidAt, canceledAt, expiresAt,
            expiredAt, failedAt, links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreateCustomerPaymentResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "countryCode", countryCode,
                "method", method,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "captureBefore", captureBefore,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "status", status,
                "statusReason", statusReason,
                "isCancelable", isCancelable,
                "details", details,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "failedAt", failedAt,
                "links", links);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String resource;

        private String id;

        private String mode;

        private String description;

        private CreateCustomerPaymentCustomersResponseAmount amount;

        private Optional<? extends CreateCustomerPaymentAmountRefunded> amountRefunded = Optional.empty();

        private Optional<? extends CreateCustomerPaymentAmountRemaining> amountRemaining = Optional.empty();

        private Optional<? extends CreateCustomerPaymentAmountCaptured> amountCaptured = Optional.empty();

        private Optional<? extends CreateCustomerPaymentAmountChargedBack> amountChargedBack = Optional.empty();

        private Optional<? extends CreateCustomerPaymentSettlementAmount> settlementAmount = Optional.empty();

        private JsonNullable<String> redirectUrl = JsonNullable.undefined();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends List<CreateCustomerPaymentCustomersLines>> lines = JsonNullable.undefined();

        private Optional<? extends CreateCustomerPaymentCustomersBillingAddress> billingAddress = Optional.empty();

        private Optional<? extends CreateCustomerPaymentCustomersShippingAddress> shippingAddress = Optional.empty();

        private JsonNullable<String> locale = JsonNullable.undefined();

        private JsonNullable<String> countryCode = JsonNullable.undefined();

        private JsonNullable<String> method = JsonNullable.undefined();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<? extends CreateCustomerPaymentCustomersMetadata> metadata = JsonNullable.undefined();

        private JsonNullable<String> captureMode = JsonNullable.undefined();

        private JsonNullable<String> captureDelay = JsonNullable.undefined();

        private JsonNullable<String> captureBefore = JsonNullable.undefined();

        private JsonNullable<? extends CreateCustomerPaymentCustomersApplicationFee> applicationFee = JsonNullable.undefined();

        private JsonNullable<? extends List<CreateCustomerPaymentCustomersRouting>> routing = JsonNullable.undefined();

        private Optional<String> sequenceType = Optional.empty();

        private JsonNullable<String> subscriptionId = JsonNullable.undefined();

        private JsonNullable<String> mandateId = JsonNullable.undefined();

        private JsonNullable<String> customerId = JsonNullable.undefined();

        private String profileId;

        private JsonNullable<String> settlementId = JsonNullable.undefined();

        private JsonNullable<String> orderId = JsonNullable.undefined();

        private String status;

        private JsonNullable<? extends CreateCustomerPaymentStatusReason> statusReason = JsonNullable.undefined();

        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();

        private JsonNullable<? extends Map<String, Object>> details = JsonNullable.undefined();

        private String createdAt;

        private JsonNullable<String> authorizedAt = JsonNullable.undefined();

        private JsonNullable<String> paidAt = JsonNullable.undefined();

        private JsonNullable<String> canceledAt = JsonNullable.undefined();

        private JsonNullable<String> expiresAt = JsonNullable.undefined();

        private JsonNullable<String> expiredAt = JsonNullable.undefined();

        private JsonNullable<String> failedAt = JsonNullable.undefined();

        private CreateCustomerPaymentCustomersLinks links;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }


        /**
         * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * <p>Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the tip amount.
         */
        public Builder amount(CreateCustomerPaymentCustomersResponseAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(CreateCustomerPaymentAmountRefunded amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = Optional.ofNullable(amountRefunded);
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the costs for a return shipment to the customer.
         */
        public Builder amountRefunded(Optional<? extends CreateCustomerPaymentAmountRefunded> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }


        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(CreateCustomerPaymentAmountRemaining amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = Optional.ofNullable(amountRemaining);
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(Optional<? extends CreateCustomerPaymentAmountRemaining> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }


        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(CreateCustomerPaymentAmountCaptured amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = Optional.ofNullable(amountCaptured);
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(Optional<? extends CreateCustomerPaymentAmountCaptured> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }


        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(CreateCustomerPaymentAmountChargedBack amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = Optional.ofNullable(amountChargedBack);
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not zero.
         */
        public Builder amountChargedBack(Optional<? extends CreateCustomerPaymentAmountChargedBack> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }


        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(CreateCustomerPaymentSettlementAmount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = Optional.ofNullable(settlementAmount);
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(Optional<? extends CreateCustomerPaymentSettlementAmount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<CreateCustomerPaymentCustomersLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<CreateCustomerPaymentCustomersLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(CreateCustomerPaymentCustomersBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends CreateCustomerPaymentCustomersBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(CreateCustomerPaymentCustomersShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and `country`.
         */
        public Builder shippingAddress(Optional<? extends CreateCustomerPaymentCustomersShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(String locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<String> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(String countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = JsonNullable.of(countryCode);
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This field is omitted if the country code was not detected.
         */
        public Builder countryCode(JsonNullable<String> countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = countryCode;
            return this;
        }


        /**
         * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * The payment method used for this transaction. If a specific method was selected during payment initialization, this field reflects that choice.
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(CreateCustomerPaymentCustomersMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends CreateCustomerPaymentCustomersMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(String captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         * 
         * <p>Possible values: `automatic` `manual` (default: `automatic`)
         */
        public Builder captureMode(JsonNullable<String> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }


        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(String captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         * 
         * <p>Possible values: `... hours` `... days`
         */
        public Builder captureDelay(JsonNullable<String> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }


        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(String captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = JsonNullable.of(captureBefore);
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(JsonNullable<String> captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = captureBefore;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(CreateCustomerPaymentCustomersApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends CreateCustomerPaymentCustomersApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(List<CreateCustomerPaymentCustomersRouting> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
         */
        public Builder routing(JsonNullable<? extends List<CreateCustomerPaymentCustomersRouting>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(String sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = Optional.ofNullable(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
         * 
         * <p>Possible values: `oneoff` `first` `recurring` (default: `oneoff`)
         */
        public Builder sequenceType(Optional<String> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }


        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = JsonNullable.of(subscriptionId);
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will be added to the response.
         */
        public Builder subscriptionId(JsonNullable<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = JsonNullable.of(settlementId);
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(JsonNullable<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }


        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = JsonNullable.of(orderId);
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(JsonNullable<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }


        /**
         * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which statuses occur at what point.
         * 
         * <p>Possible values: `open` `pending` `authorized` `paid` `canceled` `expired` `failed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(CreateCustomerPaymentStatusReason statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = JsonNullable.of(statusReason);
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale payments.
         * 
         * <p>You can find more information about the possible values of this object on [this page](status-reasons).**
         */
        public Builder statusReason(JsonNullable<? extends CreateCustomerPaymentStatusReason> statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = statusReason;
            return this;
        }


        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }


        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(Map<String, Object> details) {
            Utils.checkNotNull(details, "details");
            this.details = JsonNullable.of(details);
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the customer's card or bank details and a payment reference. For the full list of details, please refer to the [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(JsonNullable<? extends Map<String, Object>> details) {
            Utils.checkNotNull(details, "details");
            this.details = details;
            return this;
        }


        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }


        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }


        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }


        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no longer expire.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }


        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }


        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(String failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = JsonNullable.of(failedAt);
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail (yet).
         */
        public Builder failedAt(JsonNullable<String> failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = failedAt;
            return this;
        }


        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(CreateCustomerPaymentCustomersLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }

        public CreateCustomerPaymentResponseBody build() {

            return new CreateCustomerPaymentResponseBody(
                resource, id, mode,
                description, amount, amountRefunded,
                amountRemaining, amountCaptured, amountChargedBack,
                settlementAmount, redirectUrl, cancelUrl,
                webhookUrl, lines, billingAddress,
                shippingAddress, locale, countryCode,
                method, restrictPaymentMethodsToCountry, metadata,
                captureMode, captureDelay, captureBefore,
                applicationFee, routing, sequenceType,
                subscriptionId, mandateId, customerId,
                profileId, settlementId, orderId,
                status, statusReason, isCancelable,
                details, createdAt, authorizedAt,
                paidAt, canceledAt, expiresAt,
                expiredAt, failedAt, links);
        }

    }
}
