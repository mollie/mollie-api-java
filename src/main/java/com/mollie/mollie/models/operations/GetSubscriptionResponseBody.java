/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * GetSubscriptionResponseBody
 * 
 * <p>The subscription object.
 */
public class GetSubscriptionResponseBody {
    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
     * endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource")
    private Optional<String> resource;

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mode")
    private Optional<? extends GetSubscriptionMode> mode;

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is
     * enabling the subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends GetSubscriptionStatus> status;

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly
     * subscription of €10, the subscription amount should be set to €10.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends GetSubscriptionAmount> amount;

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("times")
    private JsonNullable<Long> times;

    /**
     * Number of payments left for the subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timesRemaining")
    private Optional<Long> timesRemaining;

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private Optional<? extends GetSubscriptionInterval> interval;

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("startDate")
    private Optional<String> startDate;

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
     * this parameter will not be returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nextPaymentDate")
    private JsonNullable<String> nextPaymentDate;

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends GetSubscriptionMethod> method;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
     * information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private Optional<? extends GetSubscriptionApplicationFee> applicationFee;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
     * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
     * 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends GetSubscriptionMetadata> metadata;

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private Optional<String> webhookUrl;

    /**
     * The customer this subscription belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<String> createdAt;

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
     * subscription is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("_links")
    private Optional<? extends GetSubscriptionLinks> links;

    @JsonCreator
    public GetSubscriptionResponseBody(
            @JsonProperty("resource") Optional<String> resource,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("mode") Optional<? extends GetSubscriptionMode> mode,
            @JsonProperty("status") Optional<? extends GetSubscriptionStatus> status,
            @JsonProperty("amount") Optional<? extends GetSubscriptionAmount> amount,
            @JsonProperty("times") JsonNullable<Long> times,
            @JsonProperty("timesRemaining") Optional<Long> timesRemaining,
            @JsonProperty("interval") Optional<? extends GetSubscriptionInterval> interval,
            @JsonProperty("startDate") Optional<String> startDate,
            @JsonProperty("nextPaymentDate") JsonNullable<String> nextPaymentDate,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("method") JsonNullable<? extends GetSubscriptionMethod> method,
            @JsonProperty("applicationFee") Optional<? extends GetSubscriptionApplicationFee> applicationFee,
            @JsonProperty("metadata") JsonNullable<? extends GetSubscriptionMetadata> metadata,
            @JsonProperty("webhookUrl") Optional<String> webhookUrl,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("createdAt") Optional<String> createdAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("_links") Optional<? extends GetSubscriptionLinks> links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(times, "times");
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.status = status;
        this.amount = amount;
        this.times = times;
        this.timesRemaining = timesRemaining;
        this.interval = interval;
        this.startDate = startDate;
        this.nextPaymentDate = nextPaymentDate;
        this.description = description;
        this.method = method;
        this.applicationFee = applicationFee;
        this.metadata = metadata;
        this.webhookUrl = webhookUrl;
        this.customerId = customerId;
        this.mandateId = mandateId;
        this.createdAt = createdAt;
        this.canceledAt = canceledAt;
        this.links = links;
    }
    
    public GetSubscriptionResponseBody() {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(),
            Optional.empty(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), Optional.empty(),
            JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
     * endpoint.
     */
    @JsonIgnore
    public Optional<String> resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionMode> mode() {
        return (Optional<GetSubscriptionMode>) mode;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is
     * enabling the subscription.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionStatus> status() {
        return (Optional<GetSubscriptionStatus>) status;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly
     * subscription of €10, the subscription amount should be set to €10.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionAmount> amount() {
        return (Optional<GetSubscriptionAmount>) amount;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonIgnore
    public JsonNullable<Long> times() {
        return times;
    }

    /**
     * Number of payments left for the subscription.
     */
    @JsonIgnore
    public Optional<Long> timesRemaining() {
        return timesRemaining;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionInterval> interval() {
        return (Optional<GetSubscriptionInterval>) interval;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonIgnore
    public Optional<String> startDate() {
        return startDate;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
     * this parameter will not be returned.
     */
    @JsonIgnore
    public JsonNullable<String> nextPaymentDate() {
        return nextPaymentDate;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GetSubscriptionMethod> method() {
        return (JsonNullable<GetSubscriptionMethod>) method;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
     * information.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionApplicationFee> applicationFee() {
        return (Optional<GetSubscriptionApplicationFee>) applicationFee;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
     * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
     * 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GetSubscriptionMetadata> metadata() {
        return (JsonNullable<GetSubscriptionMetadata>) metadata;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonIgnore
    public Optional<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer this subscription belongs to.
     */
    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public Optional<String> createdAt() {
        return createdAt;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
     * subscription is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionLinks> links() {
        return (Optional<GetSubscriptionLinks>) links;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
     * endpoint.
     */
    public GetSubscriptionResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = Optional.ofNullable(resource);
        return this;
    }


    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
     * endpoint.
     */
    public GetSubscriptionResponseBody withResource(Optional<String> resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public GetSubscriptionResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public GetSubscriptionResponseBody withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    public GetSubscriptionResponseBody withMode(GetSubscriptionMode mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = Optional.ofNullable(mode);
        return this;
    }


    /**
     * Whether this entity was created in live mode or in test mode.
     */
    public GetSubscriptionResponseBody withMode(Optional<? extends GetSubscriptionMode> mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is
     * enabling the subscription.
     */
    public GetSubscriptionResponseBody withStatus(GetSubscriptionStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }


    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is
     * enabling the subscription.
     */
    public GetSubscriptionResponseBody withStatus(Optional<? extends GetSubscriptionStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly
     * subscription of €10, the subscription amount should be set to €10.
     */
    public GetSubscriptionResponseBody withAmount(GetSubscriptionAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }


    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly
     * subscription of €10, the subscription amount should be set to €10.
     */
    public GetSubscriptionResponseBody withAmount(Optional<? extends GetSubscriptionAmount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public GetSubscriptionResponseBody withTimes(long times) {
        Utils.checkNotNull(times, "times");
        this.times = JsonNullable.of(times);
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
     * considered completed.
     * 
     * <p>Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public GetSubscriptionResponseBody withTimes(JsonNullable<Long> times) {
        Utils.checkNotNull(times, "times");
        this.times = times;
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public GetSubscriptionResponseBody withTimesRemaining(long timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = Optional.ofNullable(timesRemaining);
        return this;
    }


    /**
     * Number of payments left for the subscription.
     */
    public GetSubscriptionResponseBody withTimesRemaining(Optional<Long> timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = timesRemaining;
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     */
    public GetSubscriptionResponseBody withInterval(GetSubscriptionInterval interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = Optional.ofNullable(interval);
        return this;
    }


    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     */
    public GetSubscriptionResponseBody withInterval(Optional<? extends GetSubscriptionInterval> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public GetSubscriptionResponseBody withStartDate(String startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }


    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public GetSubscriptionResponseBody withStartDate(Optional<String> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
     * this parameter will not be returned.
     */
    public GetSubscriptionResponseBody withNextPaymentDate(String nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
     * this parameter will not be returned.
     */
    public GetSubscriptionResponseBody withNextPaymentDate(JsonNullable<String> nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = nextPaymentDate;
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public GetSubscriptionResponseBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }


    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing
     * up on the bank statement of the consumer.
     * 
     * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public GetSubscriptionResponseBody withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     */
    public GetSubscriptionResponseBody withMethod(GetSubscriptionMethod method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     */
    public GetSubscriptionResponseBody withMethod(JsonNullable<? extends GetSubscriptionMethod> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
     * information.
     */
    public GetSubscriptionResponseBody withApplicationFee(GetSubscriptionApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = Optional.ofNullable(applicationFee);
        return this;
    }


    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
     * information.
     */
    public GetSubscriptionResponseBody withApplicationFee(Optional<? extends GetSubscriptionApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
     * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
     * 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public GetSubscriptionResponseBody withMetadata(GetSubscriptionMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
     * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
     * 1kB.
     * 
     * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public GetSubscriptionResponseBody withMetadata(JsonNullable<? extends GetSubscriptionMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    public GetSubscriptionResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = Optional.ofNullable(webhookUrl);
        return this;
    }


    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
     * well. Be sure to verify the payment's subscription ID and its status.
     */
    public GetSubscriptionResponseBody withWebhookUrl(Optional<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public GetSubscriptionResponseBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }


    /**
     * The customer this subscription belongs to.
     */
    public GetSubscriptionResponseBody withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public GetSubscriptionResponseBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public GetSubscriptionResponseBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetSubscriptionResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }


    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetSubscriptionResponseBody withCreatedAt(Optional<String> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
     * subscription is not canceled (yet).
     */
    public GetSubscriptionResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
     * subscription is not canceled (yet).
     */
    public GetSubscriptionResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetSubscriptionResponseBody withLinks(GetSubscriptionLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = Optional.ofNullable(links);
        return this;
    }


    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetSubscriptionResponseBody withLinks(Optional<? extends GetSubscriptionLinks> links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetSubscriptionResponseBody other = (GetSubscriptionResponseBody) o;
        return 
            Utils.enhancedDeepEquals(this.resource, other.resource) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.mode, other.mode) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.times, other.times) &&
            Utils.enhancedDeepEquals(this.timesRemaining, other.timesRemaining) &&
            Utils.enhancedDeepEquals(this.interval, other.interval) &&
            Utils.enhancedDeepEquals(this.startDate, other.startDate) &&
            Utils.enhancedDeepEquals(this.nextPaymentDate, other.nextPaymentDate) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.canceledAt, other.canceledAt) &&
            Utils.enhancedDeepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            resource, id, mode,
            status, amount, times,
            timesRemaining, interval, startDate,
            nextPaymentDate, description, method,
            applicationFee, metadata, webhookUrl,
            customerId, mandateId, createdAt,
            canceledAt, links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetSubscriptionResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "status", status,
                "amount", amount,
                "times", times,
                "timesRemaining", timesRemaining,
                "interval", interval,
                "startDate", startDate,
                "nextPaymentDate", nextPaymentDate,
                "description", description,
                "method", method,
                "applicationFee", applicationFee,
                "metadata", metadata,
                "webhookUrl", webhookUrl,
                "customerId", customerId,
                "mandateId", mandateId,
                "createdAt", createdAt,
                "canceledAt", canceledAt,
                "links", links);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> resource;

        private Optional<String> id = Optional.empty();

        private Optional<? extends GetSubscriptionMode> mode = Optional.empty();

        private Optional<? extends GetSubscriptionStatus> status = Optional.empty();

        private Optional<? extends GetSubscriptionAmount> amount = Optional.empty();

        private JsonNullable<Long> times = JsonNullable.undefined();

        private Optional<Long> timesRemaining = Optional.empty();

        private Optional<? extends GetSubscriptionInterval> interval = Optional.empty();

        private Optional<String> startDate = Optional.empty();

        private JsonNullable<String> nextPaymentDate = JsonNullable.undefined();

        private Optional<String> description = Optional.empty();

        private JsonNullable<? extends GetSubscriptionMethod> method = JsonNullable.undefined();

        private Optional<? extends GetSubscriptionApplicationFee> applicationFee = Optional.empty();

        private JsonNullable<? extends GetSubscriptionMetadata> metadata = JsonNullable.undefined();

        private Optional<String> webhookUrl = Optional.empty();

        private Optional<String> customerId = Optional.empty();

        private JsonNullable<String> mandateId = JsonNullable.undefined();

        private Optional<String> createdAt = Optional.empty();

        private JsonNullable<String> canceledAt = JsonNullable.undefined();

        private Optional<? extends GetSubscriptionLinks> links = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
         * endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = Optional.ofNullable(resource);
            return this;
        }

        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this
         * endpoint.
         */
        public Builder resource(Optional<String> resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }


        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether this entity was created in live mode or in test mode.
         */
        public Builder mode(GetSubscriptionMode mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         */
        public Builder mode(Optional<? extends GetSubscriptionMode> mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }


        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is
         * enabling the subscription.
         */
        public Builder status(GetSubscriptionStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is
         * enabling the subscription.
         */
        public Builder status(Optional<? extends GetSubscriptionStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly
         * subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(GetSubscriptionAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly
         * subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(Optional<? extends GetSubscriptionAmount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
         * considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(long times) {
            Utils.checkNotNull(times, "times");
            this.times = JsonNullable.of(times);
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is
         * considered completed.
         * 
         * <p>Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(JsonNullable<Long> times) {
            Utils.checkNotNull(times, "times");
            this.times = times;
            return this;
        }


        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(long timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = Optional.ofNullable(timesRemaining);
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(Optional<Long> timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = timesRemaining;
            return this;
        }


        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         */
        public Builder interval(GetSubscriptionInterval interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = Optional.ofNullable(interval);
            return this;
        }

        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * <p>The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         */
        public Builder interval(Optional<? extends GetSubscriptionInterval> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }


        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(String startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(Optional<String> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }


        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
         * this parameter will not be returned.
         */
        public Builder nextPaymentDate(String nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled,
         * this parameter will not be returned.
         */
        public Builder nextPaymentDate(JsonNullable<String> nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = nextPaymentDate;
            return this;
        }


        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing
         * up on the bank statement of the consumer.
         * 
         * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing
         * up on the bank statement of the consumer.
         * 
         * <p>**Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         */
        public Builder method(GetSubscriptionMethod method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         */
        public Builder method(JsonNullable<? extends GetSubscriptionMethod> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
         * information.
         */
        public Builder applicationFee(GetSubscriptionApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = Optional.ofNullable(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * <p>Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more
         * information.
         */
        public Builder applicationFee(Optional<? extends GetSubscriptionApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
         * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
         * 1kB.
         * 
         * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(GetSubscriptionMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity.
         * Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately
         * 1kB.
         * 
         * <p>Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(JsonNullable<? extends GetSubscriptionMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
         * well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = Optional.ofNullable(webhookUrl);
            return this;
        }

        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * <p>This webhook will receive **all** events for the subscription's payments. This may include payment failures as
         * well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(Optional<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(Optional<String> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
         * subscription is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the
         * subscription is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }


        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(GetSubscriptionLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = Optional.ofNullable(links);
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(Optional<? extends GetSubscriptionLinks> links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }

        public GetSubscriptionResponseBody build() {
            if (resource == null) {
                resource = _SINGLETON_VALUE_Resource.value();
            }

            return new GetSubscriptionResponseBody(
                resource, id, mode,
                status, amount, times,
                timesRemaining, interval, startDate,
                nextPaymentDate, description, method,
                applicationFee, metadata, webhookUrl,
                customerId, mandateId, createdAt,
                canceledAt, links);
        }


        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Resource =
                new LazySingletonValue<>(
                        "resource",
                        "\"subscription\"",
                        new TypeReference<Optional<String>>() {});
    }
}
