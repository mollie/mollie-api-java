/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.mollie.mollie.models.operations;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;
/**
 * GetSubscriptionResponseBody - The subscription object.
 */

public class GetSubscriptionResponseBody {

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource")
    private Optional<String> resource;

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mode")
    private Optional<String> mode;

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<String> status;

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends GetSubscriptionAmount> amount;

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("times")
    private Optional<Long> times;

    /**
     * Number of payments left for the subscription.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timesRemaining")
    private Optional<Long> timesRemaining;

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * Possible values: `... days` `... weeks` `... months`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private Optional<String> interval;

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("startDate")
    private Optional<String> startDate;

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nextPaymentDate")
    private JsonNullable<String> nextPaymentDate;

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * Possible values: `creditcard` `directdebit` `paypal`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<String> method;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private Optional<? extends GetSubscriptionApplicationFee> applicationFee;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends GetSubscriptionMetadata> metadata;

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private Optional<String> webhookUrl;

    /**
     * The customer this subscription belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private Optional<String> customerId;

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("profileId")
    private JsonNullable<String> profileId;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdAt")
    private Optional<String> createdAt;

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("_links")
    private Optional<? extends GetSubscriptionLinks> links;

    @JsonCreator
    public GetSubscriptionResponseBody(
            @JsonProperty("resource") Optional<String> resource,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("mode") Optional<String> mode,
            @JsonProperty("status") Optional<String> status,
            @JsonProperty("amount") Optional<? extends GetSubscriptionAmount> amount,
            @JsonProperty("times") Optional<Long> times,
            @JsonProperty("timesRemaining") Optional<Long> timesRemaining,
            @JsonProperty("interval") Optional<String> interval,
            @JsonProperty("startDate") Optional<String> startDate,
            @JsonProperty("nextPaymentDate") JsonNullable<String> nextPaymentDate,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("method") JsonNullable<String> method,
            @JsonProperty("applicationFee") Optional<? extends GetSubscriptionApplicationFee> applicationFee,
            @JsonProperty("metadata") JsonNullable<? extends GetSubscriptionMetadata> metadata,
            @JsonProperty("webhookUrl") Optional<String> webhookUrl,
            @JsonProperty("customerId") Optional<String> customerId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("profileId") JsonNullable<String> profileId,
            @JsonProperty("createdAt") Optional<String> createdAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("_links") Optional<? extends GetSubscriptionLinks> links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(times, "times");
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(startDate, "startDate");
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.status = status;
        this.amount = amount;
        this.times = times;
        this.timesRemaining = timesRemaining;
        this.interval = interval;
        this.startDate = startDate;
        this.nextPaymentDate = nextPaymentDate;
        this.description = description;
        this.method = method;
        this.applicationFee = applicationFee;
        this.metadata = metadata;
        this.webhookUrl = webhookUrl;
        this.customerId = customerId;
        this.mandateId = mandateId;
        this.profileId = profileId;
        this.createdAt = createdAt;
        this.canceledAt = canceledAt;
        this.links = links;
    }
    
    public GetSubscriptionResponseBody() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    @JsonIgnore
    public Optional<String> resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    @JsonIgnore
    public Optional<String> mode() {
        return mode;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    @JsonIgnore
    public Optional<String> status() {
        return status;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionAmount> amount() {
        return (Optional<GetSubscriptionAmount>) amount;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * Test mode subscriptions will get canceled automatically after 10 payments.
     */
    @JsonIgnore
    public Optional<Long> times() {
        return times;
    }

    /**
     * Number of payments left for the subscription.
     */
    @JsonIgnore
    public Optional<Long> timesRemaining() {
        return timesRemaining;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * Possible values: `... days` `... weeks` `... months`
     */
    @JsonIgnore
    public Optional<String> interval() {
        return interval;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    @JsonIgnore
    public Optional<String> startDate() {
        return startDate;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    @JsonIgnore
    public JsonNullable<String> nextPaymentDate() {
        return nextPaymentDate;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * Possible values: `creditcard` `directdebit` `paypal`
     */
    @JsonIgnore
    public JsonNullable<String> method() {
        return method;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionApplicationFee> applicationFee() {
        return (Optional<GetSubscriptionApplicationFee>) applicationFee;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<GetSubscriptionMetadata> metadata() {
        return (JsonNullable<GetSubscriptionMetadata>) metadata;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    @JsonIgnore
    public Optional<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * The customer this subscription belongs to.
     */
    @JsonIgnore
    public Optional<String> customerId() {
        return customerId;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    @JsonIgnore
    public JsonNullable<String> profileId() {
        return profileId;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public Optional<String> createdAt() {
        return createdAt;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<GetSubscriptionLinks> links() {
        return (Optional<GetSubscriptionLinks>) links;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    public GetSubscriptionResponseBody withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = Optional.ofNullable(resource);
        return this;
    }

    /**
     * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
     */
    public GetSubscriptionResponseBody withResource(Optional<String> resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public GetSubscriptionResponseBody withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
     */
    public GetSubscriptionResponseBody withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    public GetSubscriptionResponseBody withMode(String mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = Optional.ofNullable(mode);
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     * 
     * Possible values: `live` `test`
     */
    public GetSubscriptionResponseBody withMode(Optional<String> mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    public GetSubscriptionResponseBody withStatus(String status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
     * 
     * Possible values: `pending` `active` `canceled` `suspended` `completed`
     */
    public GetSubscriptionResponseBody withStatus(Optional<String> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    public GetSubscriptionResponseBody withAmount(GetSubscriptionAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }

    /**
     * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
     */
    public GetSubscriptionResponseBody withAmount(Optional<? extends GetSubscriptionAmount> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public GetSubscriptionResponseBody withTimes(long times) {
        Utils.checkNotNull(times, "times");
        this.times = Optional.ofNullable(times);
        return this;
    }

    /**
     * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
     * 
     * Test mode subscriptions will get canceled automatically after 10 payments.
     */
    public GetSubscriptionResponseBody withTimes(Optional<Long> times) {
        Utils.checkNotNull(times, "times");
        this.times = times;
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public GetSubscriptionResponseBody withTimesRemaining(long timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = Optional.ofNullable(timesRemaining);
        return this;
    }

    /**
     * Number of payments left for the subscription.
     */
    public GetSubscriptionResponseBody withTimesRemaining(Optional<Long> timesRemaining) {
        Utils.checkNotNull(timesRemaining, "timesRemaining");
        this.timesRemaining = timesRemaining;
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * Possible values: `... days` `... weeks` `... months`
     */
    public GetSubscriptionResponseBody withInterval(String interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = Optional.ofNullable(interval);
        return this;
    }

    /**
     * Interval to wait between payments, for example `1 month` or `14 days`.
     * 
     * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
     * 
     * Possible values: `... days` `... weeks` `... months`
     */
    public GetSubscriptionResponseBody withInterval(Optional<String> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public GetSubscriptionResponseBody withStartDate(String startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = Optional.ofNullable(startDate);
        return this;
    }

    /**
     * The start date of the subscription in `YYYY-MM-DD` format.
     */
    public GetSubscriptionResponseBody withStartDate(Optional<String> startDate) {
        Utils.checkNotNull(startDate, "startDate");
        this.startDate = startDate;
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    public GetSubscriptionResponseBody withNextPaymentDate(String nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
        return this;
    }

    /**
     * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
     */
    public GetSubscriptionResponseBody withNextPaymentDate(JsonNullable<String> nextPaymentDate) {
        Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
        this.nextPaymentDate = nextPaymentDate;
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public GetSubscriptionResponseBody withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }

    /**
     * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
     * 
     * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
     */
    public GetSubscriptionResponseBody withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * Possible values: `creditcard` `directdebit` `paypal`
     */
    public GetSubscriptionResponseBody withMethod(String method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
     * 
     * Possible values: `creditcard` `directdebit` `paypal`
     */
    public GetSubscriptionResponseBody withMethod(JsonNullable<String> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    public GetSubscriptionResponseBody withApplicationFee(GetSubscriptionApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = Optional.ofNullable(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
     * 
     * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
     * 
     * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
     */
    public GetSubscriptionResponseBody withApplicationFee(Optional<? extends GetSubscriptionApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public GetSubscriptionResponseBody withMetadata(GetSubscriptionMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     * 
     * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
     */
    public GetSubscriptionResponseBody withMetadata(JsonNullable<? extends GetSubscriptionMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    public GetSubscriptionResponseBody withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = Optional.ofNullable(webhookUrl);
        return this;
    }

    /**
     * We will call this URL for any payment status changes of payments resulting from this subscription.
     * 
     * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
     */
    public GetSubscriptionResponseBody withWebhookUrl(Optional<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public GetSubscriptionResponseBody withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = Optional.ofNullable(customerId);
        return this;
    }

    /**
     * The customer this subscription belongs to.
     */
    public GetSubscriptionResponseBody withCustomerId(Optional<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public GetSubscriptionResponseBody withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * The mandate used for this subscription, if any.
     */
    public GetSubscriptionResponseBody withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public GetSubscriptionResponseBody withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = JsonNullable.of(profileId);
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
     */
    public GetSubscriptionResponseBody withProfileId(JsonNullable<String> profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetSubscriptionResponseBody withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public GetSubscriptionResponseBody withCreatedAt(Optional<String> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    public GetSubscriptionResponseBody withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
     */
    public GetSubscriptionResponseBody withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetSubscriptionResponseBody withLinks(GetSubscriptionLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = Optional.ofNullable(links);
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public GetSubscriptionResponseBody withLinks(Optional<? extends GetSubscriptionLinks> links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        GetSubscriptionResponseBody other = (GetSubscriptionResponseBody) o;
        return 
            Objects.deepEquals(this.resource, other.resource) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.mode, other.mode) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.amount, other.amount) &&
            Objects.deepEquals(this.times, other.times) &&
            Objects.deepEquals(this.timesRemaining, other.timesRemaining) &&
            Objects.deepEquals(this.interval, other.interval) &&
            Objects.deepEquals(this.startDate, other.startDate) &&
            Objects.deepEquals(this.nextPaymentDate, other.nextPaymentDate) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.method, other.method) &&
            Objects.deepEquals(this.applicationFee, other.applicationFee) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.webhookUrl, other.webhookUrl) &&
            Objects.deepEquals(this.customerId, other.customerId) &&
            Objects.deepEquals(this.mandateId, other.mandateId) &&
            Objects.deepEquals(this.profileId, other.profileId) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.canceledAt, other.canceledAt) &&
            Objects.deepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            resource,
            id,
            mode,
            status,
            amount,
            times,
            timesRemaining,
            interval,
            startDate,
            nextPaymentDate,
            description,
            method,
            applicationFee,
            metadata,
            webhookUrl,
            customerId,
            mandateId,
            profileId,
            createdAt,
            canceledAt,
            links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(GetSubscriptionResponseBody.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "status", status,
                "amount", amount,
                "times", times,
                "timesRemaining", timesRemaining,
                "interval", interval,
                "startDate", startDate,
                "nextPaymentDate", nextPaymentDate,
                "description", description,
                "method", method,
                "applicationFee", applicationFee,
                "metadata", metadata,
                "webhookUrl", webhookUrl,
                "customerId", customerId,
                "mandateId", mandateId,
                "profileId", profileId,
                "createdAt", createdAt,
                "canceledAt", canceledAt,
                "links", links);
    }
    
    public final static class Builder {
 
        private Optional<String> resource;
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> mode = Optional.empty();
 
        private Optional<String> status = Optional.empty();
 
        private Optional<? extends GetSubscriptionAmount> amount = Optional.empty();
 
        private Optional<Long> times = Optional.empty();
 
        private Optional<Long> timesRemaining = Optional.empty();
 
        private Optional<String> interval = Optional.empty();
 
        private Optional<String> startDate = Optional.empty();
 
        private JsonNullable<String> nextPaymentDate = JsonNullable.undefined();
 
        private Optional<String> description = Optional.empty();
 
        private JsonNullable<String> method = JsonNullable.undefined();
 
        private Optional<? extends GetSubscriptionApplicationFee> applicationFee = Optional.empty();
 
        private JsonNullable<? extends GetSubscriptionMetadata> metadata = JsonNullable.undefined();
 
        private Optional<String> webhookUrl = Optional.empty();
 
        private Optional<String> customerId = Optional.empty();
 
        private JsonNullable<String> mandateId = JsonNullable.undefined();
 
        private JsonNullable<String> profileId = JsonNullable.undefined();
 
        private Optional<String> createdAt = Optional.empty();
 
        private JsonNullable<String> canceledAt = JsonNullable.undefined();
 
        private Optional<? extends GetSubscriptionLinks> links = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = Optional.ofNullable(resource);
            return this;
        }

        /**
         * Indicates the response contains a subscription object. Will always contain the string `subscription` for this endpoint.
         */
        public Builder resource(Optional<String> resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }

        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The identifier uniquely referring to this subscription. Example: `sub_rVKGtNd6s3`.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * Possible values: `live` `test`
         */
        public Builder mode(String mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = Optional.ofNullable(mode);
            return this;
        }

        /**
         * Whether this entity was created in live mode or in test mode.
         * 
         * Possible values: `live` `test`
         */
        public Builder mode(Optional<String> mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }

        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
         * 
         * Possible values: `pending` `active` `canceled` `suspended` `completed`
         */
        public Builder status(String status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * The subscription's current status is directly related to the status of the underlying customer or mandate that is enabling the subscription.
         * 
         * Possible values: `pending` `active` `canceled` `suspended` `completed`
         */
        public Builder status(Optional<String> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(GetSubscriptionAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        /**
         * The amount for each individual payment that is charged with this subscription. For example, for a monthly subscription of €10, the subscription amount should be set to €10.
         */
        public Builder amount(Optional<? extends GetSubscriptionAmount> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
         * 
         * Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(long times) {
            Utils.checkNotNull(times, "times");
            this.times = Optional.ofNullable(times);
            return this;
        }

        /**
         * Total number of payments for the subscription. Once this number of payments is reached, the subscription is considered completed.
         * 
         * Test mode subscriptions will get canceled automatically after 10 payments.
         */
        public Builder times(Optional<Long> times) {
            Utils.checkNotNull(times, "times");
            this.times = times;
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(long timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = Optional.ofNullable(timesRemaining);
            return this;
        }

        /**
         * Number of payments left for the subscription.
         */
        public Builder timesRemaining(Optional<Long> timesRemaining) {
            Utils.checkNotNull(timesRemaining, "timesRemaining");
            this.timesRemaining = timesRemaining;
            return this;
        }

        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         * 
         * Possible values: `... days` `... weeks` `... months`
         */
        public Builder interval(String interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = Optional.ofNullable(interval);
            return this;
        }

        /**
         * Interval to wait between payments, for example `1 month` or `14 days`.
         * 
         * The maximum interval is one year (`12 months`, `52 weeks`, or `365 days`).
         * 
         * Possible values: `... days` `... weeks` `... months`
         */
        public Builder interval(Optional<String> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }

        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(String startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = Optional.ofNullable(startDate);
            return this;
        }

        /**
         * The start date of the subscription in `YYYY-MM-DD` format.
         */
        public Builder startDate(Optional<String> startDate) {
            Utils.checkNotNull(startDate, "startDate");
            this.startDate = startDate;
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
         */
        public Builder nextPaymentDate(String nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = JsonNullable.of(nextPaymentDate);
            return this;
        }

        /**
         * The date of the next scheduled payment in `YYYY-MM-DD` format. If the subscription has been completed or canceled, this parameter will not be returned.
         */
        public Builder nextPaymentDate(JsonNullable<String> nextPaymentDate) {
            Utils.checkNotNull(nextPaymentDate, "nextPaymentDate");
            this.nextPaymentDate = nextPaymentDate;
            return this;
        }

        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
         * 
         * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        /**
         * The subscription's description will be used as the description of the resulting individual payments and so showing up on the bank statement of the consumer.
         * 
         * **Please note:** the description needs to be unique for the Customer in case it has multiple active subscriptions.
         */
        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         * 
         * Possible values: `creditcard` `directdebit` `paypal`
         */
        public Builder method(String method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * The payment method used for this subscription. If omitted, any of the customer's valid mandates may be used.
         * 
         * Possible values: `creditcard` `directdebit` `paypal`
         */
        public Builder method(JsonNullable<String> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
         */
        public Builder applicationFee(GetSubscriptionApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = Optional.ofNullable(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
         * 
         * Setting an application fee on the subscription will ensure this fee is charged on each individual payment.
         * 
         * Refer to the `applicationFee` parameter on the [Get payment endpoint](get-payment) documentation for more information.
         */
        public Builder applicationFee(Optional<? extends GetSubscriptionApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         * 
         * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(GetSubscriptionMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         * 
         * Any metadata added to the subscription will be automatically forwarded to the payments generated for it.
         */
        public Builder metadata(JsonNullable<? extends GetSubscriptionMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = Optional.ofNullable(webhookUrl);
            return this;
        }

        /**
         * We will call this URL for any payment status changes of payments resulting from this subscription.
         * 
         * This webhook will receive **all** events for the subscription's payments. This may include payment failures as well. Be sure to verify the payment's subscription ID and its status.
         */
        public Builder webhookUrl(Optional<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }

        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = Optional.ofNullable(customerId);
            return this;
        }

        /**
         * The customer this subscription belongs to.
         */
        public Builder customerId(Optional<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }

        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * The mandate used for this subscription, if any.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = JsonNullable.of(profileId);
            return this;
        }

        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
         */
        public Builder profileId(JsonNullable<String> profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(Optional<String> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The subscription's date and time of cancellation, in ISO 8601 format. This parameter is omitted if the subscription is not canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(GetSubscriptionLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = Optional.ofNullable(links);
            return this;
        }

        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(Optional<? extends GetSubscriptionLinks> links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }
        
        public GetSubscriptionResponseBody build() {
            if (resource == null) {
                resource = _SINGLETON_VALUE_Resource.value();
            }            return new GetSubscriptionResponseBody(
                resource,
                id,
                mode,
                status,
                amount,
                times,
                timesRemaining,
                interval,
                startDate,
                nextPaymentDate,
                description,
                method,
                applicationFee,
                metadata,
                webhookUrl,
                customerId,
                mandateId,
                profileId,
                createdAt,
                canceledAt,
                links);
        }

        private static final LazySingletonValue<Optional<String>> _SINGLETON_VALUE_Resource =
                new LazySingletonValue<>(
                        "resource",
                        "\"subscription\"",
                        new TypeReference<Optional<String>>() {});
    }
}

