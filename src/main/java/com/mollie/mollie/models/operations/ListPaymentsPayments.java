/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.mollie.mollie.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.utils.LazySingletonValue;
import com.mollie.mollie.utils.Utils;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class ListPaymentsPayments {
    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonProperty("resource")
    private String resource;

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
     * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonProperty("id")
    private String id;

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonProperty("mode")
    private ListPaymentsMode mode;

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonProperty("description")
    private String description;

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    @JsonProperty("amount")
    private ListPaymentsAmount amount;

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some
     * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
     * costs for a return shipment to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRefunded")
    private Optional<? extends ListPaymentsAmountRefunded> amountRefunded;

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountRemaining")
    private Optional<? extends ListPaymentsAmountRemaining> amountRemaining;

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountCaptured")
    private Optional<? extends ListPaymentsAmountCaptured> amountCaptured;

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not
     * zero.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amountChargedBack")
    private Optional<? extends ListPaymentsAmountChargedBack> amountChargedBack;

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the
     * currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
     * settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
     * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementAmount")
    private Optional<? extends ListPaymentsSettlementAmount> settlementAmount;

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("redirectUrl")
    private JsonNullable<String> redirectUrl;

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cancelUrl")
    private JsonNullable<String> cancelUrl;

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhookUrl")
    private JsonNullable<String> webhookUrl;

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lines")
    private JsonNullable<? extends List<ListPaymentsLines>> lines;

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billingAddress")
    private Optional<? extends ListPaymentsBillingAddress> billingAddress;

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingAddress")
    private Optional<? extends ListPaymentsShippingAddress> shippingAddress;

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    private JsonNullable<? extends ListPaymentsLocale> locale;

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
     * field is omitted if the country code was not detected.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    private JsonNullable<String> countryCode;

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization,
     * this field reflects that choice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("method")
    private JsonNullable<? extends ListPaymentsMethod> method;

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restrictPaymentMethodsToCountry")
    private JsonNullable<String> restrictPaymentMethodsToCountry;

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends ListPaymentsMetadata> metadata;

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureMode")
    private JsonNullable<? extends ListPaymentsCaptureMode> captureMode;

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureDelay")
    private JsonNullable<? extends ListPaymentsCaptureDelay> captureDelay;

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("captureBefore")
    private JsonNullable<String> captureBefore;

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("applicationFee")
    private JsonNullable<? extends ListPaymentsApplicationFee> applicationFee;

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("routing")
    private JsonNullable<? extends List<ListPaymentsRouting>> routing;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sequenceType")
    private JsonNullable<? extends ListPaymentsSequenceType> sequenceType;

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
     * be added to the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptionId")
    private JsonNullable<String> subscriptionId;

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mandateId")
    private JsonNullable<String> mandateId;

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerId")
    private JsonNullable<String> customerId;

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonProperty("profileId")
    private String profileId;

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settlementId")
    private JsonNullable<String> settlementId;

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderId")
    private JsonNullable<String> orderId;

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    @JsonProperty("status")
    private ListPaymentsStatus status;

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("statusReason")
    private JsonNullable<? extends ListPaymentsStatusReason> statusReason;

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isCancelable")
    private JsonNullable<Boolean> isCancelable;

    /**
     * An object containing payment details collected during the payment process. For example, details may include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    private JsonNullable<? extends Map<String, Object>> details;

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonProperty("createdAt")
    private String createdAt;

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
     * not authorized (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorizedAt")
    private JsonNullable<String> authorizedAt;

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
     * completed (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidAt")
    private JsonNullable<String> paidAt;

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
     * canceled (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("canceledAt")
    private JsonNullable<String> canceledAt;

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
     * longer expire.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiresAt")
    private JsonNullable<String> expiresAt;

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
     * expire (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expiredAt")
    private JsonNullable<String> expiredAt;

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
     * (yet).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("failedAt")
    private JsonNullable<String> failedAt;

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonProperty("_links")
    private ListPaymentsPaymentsLinks links;

    @JsonCreator
    public ListPaymentsPayments(
            @JsonProperty("resource") String resource,
            @JsonProperty("id") String id,
            @JsonProperty("mode") ListPaymentsMode mode,
            @JsonProperty("description") String description,
            @JsonProperty("amount") ListPaymentsAmount amount,
            @JsonProperty("amountRefunded") Optional<? extends ListPaymentsAmountRefunded> amountRefunded,
            @JsonProperty("amountRemaining") Optional<? extends ListPaymentsAmountRemaining> amountRemaining,
            @JsonProperty("amountCaptured") Optional<? extends ListPaymentsAmountCaptured> amountCaptured,
            @JsonProperty("amountChargedBack") Optional<? extends ListPaymentsAmountChargedBack> amountChargedBack,
            @JsonProperty("settlementAmount") Optional<? extends ListPaymentsSettlementAmount> settlementAmount,
            @JsonProperty("redirectUrl") JsonNullable<String> redirectUrl,
            @JsonProperty("cancelUrl") JsonNullable<String> cancelUrl,
            @JsonProperty("webhookUrl") JsonNullable<String> webhookUrl,
            @JsonProperty("lines") JsonNullable<? extends List<ListPaymentsLines>> lines,
            @JsonProperty("billingAddress") Optional<? extends ListPaymentsBillingAddress> billingAddress,
            @JsonProperty("shippingAddress") Optional<? extends ListPaymentsShippingAddress> shippingAddress,
            @JsonProperty("locale") JsonNullable<? extends ListPaymentsLocale> locale,
            @JsonProperty("countryCode") JsonNullable<String> countryCode,
            @JsonProperty("method") JsonNullable<? extends ListPaymentsMethod> method,
            @JsonProperty("restrictPaymentMethodsToCountry") JsonNullable<String> restrictPaymentMethodsToCountry,
            @JsonProperty("metadata") JsonNullable<? extends ListPaymentsMetadata> metadata,
            @JsonProperty("captureMode") JsonNullable<? extends ListPaymentsCaptureMode> captureMode,
            @JsonProperty("captureDelay") JsonNullable<? extends ListPaymentsCaptureDelay> captureDelay,
            @JsonProperty("captureBefore") JsonNullable<String> captureBefore,
            @JsonProperty("applicationFee") JsonNullable<? extends ListPaymentsApplicationFee> applicationFee,
            @JsonProperty("routing") JsonNullable<? extends List<ListPaymentsRouting>> routing,
            @JsonProperty("sequenceType") JsonNullable<? extends ListPaymentsSequenceType> sequenceType,
            @JsonProperty("subscriptionId") JsonNullable<String> subscriptionId,
            @JsonProperty("mandateId") JsonNullable<String> mandateId,
            @JsonProperty("customerId") JsonNullable<String> customerId,
            @JsonProperty("profileId") String profileId,
            @JsonProperty("settlementId") JsonNullable<String> settlementId,
            @JsonProperty("orderId") JsonNullable<String> orderId,
            @JsonProperty("status") ListPaymentsStatus status,
            @JsonProperty("statusReason") JsonNullable<? extends ListPaymentsStatusReason> statusReason,
            @JsonProperty("isCancelable") JsonNullable<Boolean> isCancelable,
            @JsonProperty("details") JsonNullable<? extends Map<String, Object>> details,
            @JsonProperty("createdAt") String createdAt,
            @JsonProperty("authorizedAt") JsonNullable<String> authorizedAt,
            @JsonProperty("paidAt") JsonNullable<String> paidAt,
            @JsonProperty("canceledAt") JsonNullable<String> canceledAt,
            @JsonProperty("expiresAt") JsonNullable<String> expiresAt,
            @JsonProperty("expiredAt") JsonNullable<String> expiredAt,
            @JsonProperty("failedAt") JsonNullable<String> failedAt,
            @JsonProperty("_links") ListPaymentsPaymentsLinks links) {
        Utils.checkNotNull(resource, "resource");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(mode, "mode");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(lines, "lines");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(locale, "locale");
        Utils.checkNotNull(countryCode, "countryCode");
        Utils.checkNotNull(method, "method");
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(captureMode, "captureMode");
        Utils.checkNotNull(captureDelay, "captureDelay");
        Utils.checkNotNull(captureBefore, "captureBefore");
        Utils.checkNotNull(applicationFee, "applicationFee");
        Utils.checkNotNull(routing, "routing");
        Utils.checkNotNull(sequenceType, "sequenceType");
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        Utils.checkNotNull(mandateId, "mandateId");
        Utils.checkNotNull(customerId, "customerId");
        Utils.checkNotNull(profileId, "profileId");
        Utils.checkNotNull(settlementId, "settlementId");
        Utils.checkNotNull(orderId, "orderId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(statusReason, "statusReason");
        Utils.checkNotNull(isCancelable, "isCancelable");
        Utils.checkNotNull(details, "details");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        Utils.checkNotNull(paidAt, "paidAt");
        Utils.checkNotNull(canceledAt, "canceledAt");
        Utils.checkNotNull(expiresAt, "expiresAt");
        Utils.checkNotNull(expiredAt, "expiredAt");
        Utils.checkNotNull(failedAt, "failedAt");
        Utils.checkNotNull(links, "links");
        this.resource = resource;
        this.id = id;
        this.mode = mode;
        this.description = description;
        this.amount = amount;
        this.amountRefunded = amountRefunded;
        this.amountRemaining = amountRemaining;
        this.amountCaptured = amountCaptured;
        this.amountChargedBack = amountChargedBack;
        this.settlementAmount = settlementAmount;
        this.redirectUrl = redirectUrl;
        this.cancelUrl = cancelUrl;
        this.webhookUrl = webhookUrl;
        this.lines = lines;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.locale = locale;
        this.countryCode = countryCode;
        this.method = method;
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        this.metadata = metadata;
        this.captureMode = captureMode;
        this.captureDelay = captureDelay;
        this.captureBefore = captureBefore;
        this.applicationFee = applicationFee;
        this.routing = routing;
        this.sequenceType = sequenceType;
        this.subscriptionId = subscriptionId;
        this.mandateId = mandateId;
        this.customerId = customerId;
        this.profileId = profileId;
        this.settlementId = settlementId;
        this.orderId = orderId;
        this.status = status;
        this.statusReason = statusReason;
        this.isCancelable = isCancelable;
        this.details = details;
        this.createdAt = createdAt;
        this.authorizedAt = authorizedAt;
        this.paidAt = paidAt;
        this.canceledAt = canceledAt;
        this.expiresAt = expiresAt;
        this.expiredAt = expiredAt;
        this.failedAt = failedAt;
        this.links = links;
    }
    
    public ListPaymentsPayments(
            String resource,
            String id,
            ListPaymentsMode mode,
            String description,
            ListPaymentsAmount amount,
            String profileId,
            ListPaymentsStatus status,
            String createdAt,
            ListPaymentsPaymentsLinks links) {
        this(resource, id, mode,
            description, amount, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            profileId, JsonNullable.undefined(), JsonNullable.undefined(),
            status, JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), createdAt, JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), links);
    }

    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    @JsonIgnore
    public String resource() {
        return resource;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
     * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    @JsonIgnore
    public ListPaymentsMode mode() {
        return mode;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    @JsonIgnore
    public String description() {
        return description;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    @JsonIgnore
    public ListPaymentsAmount amount() {
        return amount;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some
     * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
     * costs for a return shipment to the customer.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsAmountRefunded> amountRefunded() {
        return (Optional<ListPaymentsAmountRefunded>) amountRefunded;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsAmountRemaining> amountRemaining() {
        return (Optional<ListPaymentsAmountRemaining>) amountRemaining;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsAmountCaptured> amountCaptured() {
        return (Optional<ListPaymentsAmountCaptured>) amountCaptured;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not
     * zero.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsAmountChargedBack> amountChargedBack() {
        return (Optional<ListPaymentsAmountChargedBack>) amountChargedBack;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the
     * currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
     * settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
     * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsSettlementAmount> settlementAmount() {
        return (Optional<ListPaymentsSettlementAmount>) settlementAmount;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    @JsonIgnore
    public JsonNullable<String> redirectUrl() {
        return redirectUrl;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    @JsonIgnore
    public JsonNullable<String> cancelUrl() {
        return cancelUrl;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    @JsonIgnore
    public JsonNullable<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<ListPaymentsLines>> lines() {
        return (JsonNullable<List<ListPaymentsLines>>) lines;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsBillingAddress> billingAddress() {
        return (Optional<ListPaymentsBillingAddress>) billingAddress;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ListPaymentsShippingAddress> shippingAddress() {
        return (Optional<ListPaymentsShippingAddress>) shippingAddress;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsLocale> locale() {
        return (JsonNullable<ListPaymentsLocale>) locale;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
     * field is omitted if the country code was not detected.
     */
    @JsonIgnore
    public JsonNullable<String> countryCode() {
        return countryCode;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization,
     * this field reflects that choice.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsMethod> method() {
        return (JsonNullable<ListPaymentsMethod>) method;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    @JsonIgnore
    public JsonNullable<String> restrictPaymentMethodsToCountry() {
        return restrictPaymentMethodsToCountry;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsMetadata> metadata() {
        return (JsonNullable<ListPaymentsMetadata>) metadata;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsCaptureMode> captureMode() {
        return (JsonNullable<ListPaymentsCaptureMode>) captureMode;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsCaptureDelay> captureDelay() {
        return (JsonNullable<ListPaymentsCaptureDelay>) captureDelay;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> captureBefore() {
        return captureBefore;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsApplicationFee> applicationFee() {
        return (JsonNullable<ListPaymentsApplicationFee>) applicationFee;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<ListPaymentsRouting>> routing() {
        return (JsonNullable<List<ListPaymentsRouting>>) routing;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsSequenceType> sequenceType() {
        return (JsonNullable<ListPaymentsSequenceType>) sequenceType;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
     * be added to the response.
     */
    @JsonIgnore
    public JsonNullable<String> subscriptionId() {
        return subscriptionId;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    @JsonIgnore
    public JsonNullable<String> mandateId() {
        return mandateId;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    @JsonIgnore
    public JsonNullable<String> customerId() {
        return customerId;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    @JsonIgnore
    public String profileId() {
        return profileId;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    @JsonIgnore
    public JsonNullable<String> settlementId() {
        return settlementId;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    @JsonIgnore
    public JsonNullable<String> orderId() {
        return orderId;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    @JsonIgnore
    public ListPaymentsStatus status() {
        return status;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ListPaymentsStatusReason> statusReason() {
        return (JsonNullable<ListPaymentsStatusReason>) statusReason;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    @JsonIgnore
    public JsonNullable<Boolean> isCancelable() {
        return isCancelable;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> details() {
        return (JsonNullable<Map<String, Object>>) details;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    @JsonIgnore
    public String createdAt() {
        return createdAt;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
     * not authorized (yet).
     */
    @JsonIgnore
    public JsonNullable<String> authorizedAt() {
        return authorizedAt;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
     * completed (yet).
     */
    @JsonIgnore
    public JsonNullable<String> paidAt() {
        return paidAt;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
     * canceled (yet).
     */
    @JsonIgnore
    public JsonNullable<String> canceledAt() {
        return canceledAt;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
     * longer expire.
     */
    @JsonIgnore
    public JsonNullable<String> expiresAt() {
        return expiresAt;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
     * expire (yet).
     */
    @JsonIgnore
    public JsonNullable<String> expiredAt() {
        return expiredAt;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
     * (yet).
     */
    @JsonIgnore
    public JsonNullable<String> failedAt() {
        return failedAt;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    @JsonIgnore
    public ListPaymentsPaymentsLinks links() {
        return links;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
     */
    public ListPaymentsPayments withResource(String resource) {
        Utils.checkNotNull(resource, "resource");
        this.resource = resource;
        return this;
    }

    /**
     * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
     * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
     */
    public ListPaymentsPayments withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Whether this entity was created in live mode or in test mode.
     */
    public ListPaymentsPayments withMode(ListPaymentsMode mode) {
        Utils.checkNotNull(mode, "mode");
        this.mode = mode;
        return this;
    }

    /**
     * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
     * We truncate the description automatically according to the limits of the used payment method. The description is
     * also visible in any exports you generate.
     * 
     * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
     * This is particularly useful for bookkeeping.
     * 
     * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
     * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
     */
    public ListPaymentsPayments withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
     * 
     * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
     * retrieved using the Get method endpoint.
     * 
     * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
     * tip amount.
     */
    public ListPaymentsPayments withAmount(ListPaymentsAmount amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some
     * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
     * costs for a return shipment to the customer.
     */
    public ListPaymentsPayments withAmountRefunded(ListPaymentsAmountRefunded amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = Optional.ofNullable(amountRefunded);
        return this;
    }


    /**
     * The total amount that is already refunded. Only available when refunds are available for this payment. For some
     * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
     * costs for a return shipment to the customer.
     */
    public ListPaymentsPayments withAmountRefunded(Optional<? extends ListPaymentsAmountRefunded> amountRefunded) {
        Utils.checkNotNull(amountRefunded, "amountRefunded");
        this.amountRefunded = amountRefunded;
        return this;
    }

    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public ListPaymentsPayments withAmountRemaining(ListPaymentsAmountRemaining amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = Optional.ofNullable(amountRemaining);
        return this;
    }


    /**
     * The remaining amount that can be refunded. Only available when refunds are available for this payment.
     */
    public ListPaymentsPayments withAmountRemaining(Optional<? extends ListPaymentsAmountRemaining> amountRemaining) {
        Utils.checkNotNull(amountRemaining, "amountRemaining");
        this.amountRemaining = amountRemaining;
        return this;
    }

    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public ListPaymentsPayments withAmountCaptured(ListPaymentsAmountCaptured amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = Optional.ofNullable(amountCaptured);
        return this;
    }


    /**
     * The total amount that is already captured for this payment. Only available when this payment supports captures.
     */
    public ListPaymentsPayments withAmountCaptured(Optional<? extends ListPaymentsAmountCaptured> amountCaptured) {
        Utils.checkNotNull(amountCaptured, "amountCaptured");
        this.amountCaptured = amountCaptured;
        return this;
    }

    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not
     * zero.
     */
    public ListPaymentsPayments withAmountChargedBack(ListPaymentsAmountChargedBack amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = Optional.ofNullable(amountChargedBack);
        return this;
    }


    /**
     * The total amount that was charged back for this payment. Only available when the total charged back amount is not
     * zero.
     */
    public ListPaymentsPayments withAmountChargedBack(Optional<? extends ListPaymentsAmountChargedBack> amountChargedBack) {
        Utils.checkNotNull(amountChargedBack, "amountChargedBack");
        this.amountChargedBack = amountChargedBack;
        return this;
    }

    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the
     * currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
     * settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
     * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public ListPaymentsPayments withSettlementAmount(ListPaymentsSettlementAmount settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = Optional.ofNullable(settlementAmount);
        return this;
    }


    /**
     * This optional field will contain the approximate amount that will be settled to your account, converted to the
     * currency your account is settled in.
     * 
     * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
     * settled by Mollie the `settlementAmount` is omitted from the response.
     * 
     * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
     * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
     */
    public ListPaymentsPayments withSettlementAmount(Optional<? extends ListPaymentsSettlementAmount> settlementAmount) {
        Utils.checkNotNull(settlementAmount, "settlementAmount");
        this.settlementAmount = settlementAmount;
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public ListPaymentsPayments withRedirectUrl(String redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = JsonNullable.of(redirectUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to after the payment process.
     * 
     * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
     * right page referencing the order when your customer returns.
     * 
     * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
     * Apple Pay payments with an `applePayPaymentToken`.
     */
    public ListPaymentsPayments withRedirectUrl(JsonNullable<String> redirectUrl) {
        Utils.checkNotNull(redirectUrl, "redirectUrl");
        this.redirectUrl = redirectUrl;
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public ListPaymentsPayments withCancelUrl(String cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = JsonNullable.of(cancelUrl);
        return this;
    }

    /**
     * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
     * provided, the customer will be redirected to the `redirectUrl` instead — see above.
     * 
     * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
     * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
     * payment cancellations.
     */
    public ListPaymentsPayments withCancelUrl(JsonNullable<String> cancelUrl) {
        Utils.checkNotNull(cancelUrl, "cancelUrl");
        this.cancelUrl = cancelUrl;
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public ListPaymentsPayments withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = JsonNullable.of(webhookUrl);
        return this;
    }

    /**
     * The webhook URL where we will send payment status updates to.
     * 
     * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
     * 
     * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
     * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
     * local machine.
     */
    public ListPaymentsPayments withWebhookUrl(JsonNullable<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public ListPaymentsPayments withLines(List<ListPaymentsLines> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = JsonNullable.of(lines);
        return this;
    }

    /**
     * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
     * ordered and its price.
     * 
     * <p>All lines must have the same currency as the payment.
     * 
     * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
     */
    public ListPaymentsPayments withLines(JsonNullable<? extends List<ListPaymentsLines>> lines) {
        Utils.checkNotNull(lines, "lines");
        this.lines = lines;
        return this;
    }

    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public ListPaymentsPayments withBillingAddress(ListPaymentsBillingAddress billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }


    /**
     * The customer's billing address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     * 
     * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
     */
    public ListPaymentsPayments withBillingAddress(Optional<? extends ListPaymentsBillingAddress> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    public ListPaymentsPayments withShippingAddress(ListPaymentsShippingAddress shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    /**
     * The customer's shipping address details. We advise to provide these details to improve fraud protection and
     * conversion.
     * 
     * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
     * `country`.
     */
    public ListPaymentsPayments withShippingAddress(Optional<? extends ListPaymentsShippingAddress> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public ListPaymentsPayments withLocale(ListPaymentsLocale locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = JsonNullable.of(locale);
        return this;
    }

    /**
     * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
     * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
     * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
     * locale, but our hosted payment pages currently only support the specified languages.
     * 
     * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
     * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
     * customer use a local bank account greatly increases the conversion and speed of payment.
     */
    public ListPaymentsPayments withLocale(JsonNullable<? extends ListPaymentsLocale> locale) {
        Utils.checkNotNull(locale, "locale");
        this.locale = locale;
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
     * field is omitted if the country code was not detected.
     */
    public ListPaymentsPayments withCountryCode(String countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = JsonNullable.of(countryCode);
        return this;
    }

    /**
     * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
     * field is omitted if the country code was not detected.
     */
    public ListPaymentsPayments withCountryCode(JsonNullable<String> countryCode) {
        Utils.checkNotNull(countryCode, "countryCode");
        this.countryCode = countryCode;
        return this;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization,
     * this field reflects that choice.
     */
    public ListPaymentsPayments withMethod(ListPaymentsMethod method) {
        Utils.checkNotNull(method, "method");
        this.method = JsonNullable.of(method);
        return this;
    }

    /**
     * The payment method used for this transaction. If a specific method was selected during payment initialization,
     * this field reflects that choice.
     */
    public ListPaymentsPayments withMethod(JsonNullable<? extends ListPaymentsMethod> method) {
        Utils.checkNotNull(method, "method");
        this.method = method;
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public ListPaymentsPayments withRestrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
        return this;
    }

    /**
     * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
     * rates you have used for the order to ensure your customer's country matches the VAT country.
     * 
     * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
     * 
     * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
     * 
     * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
     */
    public ListPaymentsPayments withRestrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
        Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
        this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public ListPaymentsPayments withMetadata(ListPaymentsMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
     * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
     */
    public ListPaymentsPayments withMetadata(JsonNullable<? extends ListPaymentsMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public ListPaymentsPayments withCaptureMode(ListPaymentsCaptureMode captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = JsonNullable.of(captureMode);
        return this;
    }

    /**
     * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
     * and capture at a later time.
     * 
     * <p>This field needs to be set to `manual` for method `riverty`.
     */
    public ListPaymentsPayments withCaptureMode(JsonNullable<? extends ListPaymentsCaptureMode> captureMode) {
        Utils.checkNotNull(captureMode, "captureMode");
        this.captureMode = captureMode;
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     */
    public ListPaymentsPayments withCaptureDelay(ListPaymentsCaptureDelay captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = JsonNullable.of(captureDelay);
        return this;
    }

    /**
     * **Only relevant if you wish to manage authorization and capturing separately.**
     * 
     * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
     * later point either be 'captured' or canceled.
     * 
     * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
     * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
     * example `8 hours` or `2 days`.
     * 
     * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
     * 
     * <p>The maximum delay is 7 days (168 hours).
     */
    public ListPaymentsPayments withCaptureDelay(JsonNullable<? extends ListPaymentsCaptureDelay> captureDelay) {
        Utils.checkNotNull(captureDelay, "captureDelay");
        this.captureDelay = captureDelay;
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public ListPaymentsPayments withCaptureBefore(String captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = JsonNullable.of(captureBefore);
        return this;
    }

    /**
     * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
     * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
     */
    public ListPaymentsPayments withCaptureBefore(JsonNullable<String> captureBefore) {
        Utils.checkNotNull(captureBefore, "captureBefore");
        this.captureBefore = captureBefore;
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public ListPaymentsPayments withApplicationFee(ListPaymentsApplicationFee applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = JsonNullable.of(applicationFee);
        return this;
    }

    /**
     * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
     * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
     * to your own account balance.
     * 
     * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
     * `routing` parameter.
     */
    public ListPaymentsPayments withApplicationFee(JsonNullable<? extends ListPaymentsApplicationFee> applicationFee) {
        Utils.checkNotNull(applicationFee, "applicationFee");
        this.applicationFee = applicationFee;
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public ListPaymentsPayments withRouting(List<ListPaymentsRouting> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = JsonNullable.of(routing);
        return this;
    }

    /**
     * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
     * 
     * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
     * merchants.
     * 
     * <p>If you create payments on your own account that you want to split between yourself and one or more connected
     * merchants, you can use this `routing` parameter to route the payment accordingly.
     * 
     * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
     * specific portion of the payment.
     * 
     * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
     * payment amount have been routed, the amount left will be routed to the current organization automatically.
     * 
     * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
     * parameter.
     */
    public ListPaymentsPayments withRouting(JsonNullable<? extends List<ListPaymentsRouting>> routing) {
        Utils.checkNotNull(routing, "routing");
        this.routing = routing;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    public ListPaymentsPayments withSequenceType(ListPaymentsSequenceType sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = JsonNullable.of(sequenceType);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>Indicate which part of a recurring sequence this payment is for.
     * 
     * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
     * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
     * on their account in the future.
     * 
     * <p>If set to `recurring`, the customer's card is charged automatically.
     * 
     * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
     * 
     * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
     * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
     * are set up correctly for recurring payments.
     */
    public ListPaymentsPayments withSequenceType(JsonNullable<? extends ListPaymentsSequenceType> sequenceType) {
        Utils.checkNotNull(sequenceType, "sequenceType");
        this.sequenceType = sequenceType;
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
     * be added to the response.
     */
    public ListPaymentsPayments withSubscriptionId(String subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = JsonNullable.of(subscriptionId);
        return this;
    }

    /**
     * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
     * be added to the response.
     */
    public ListPaymentsPayments withSubscriptionId(JsonNullable<String> subscriptionId) {
        Utils.checkNotNull(subscriptionId, "subscriptionId");
        this.subscriptionId = subscriptionId;
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    public ListPaymentsPayments withMandateId(String mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = JsonNullable.of(mandateId);
        return this;
    }

    /**
     * **Only relevant for recurring payments.**
     * 
     * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
     * the customer's accounts should be credited.
     */
    public ListPaymentsPayments withMandateId(JsonNullable<String> mandateId) {
        Utils.checkNotNull(mandateId, "mandateId");
        this.mandateId = mandateId;
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public ListPaymentsPayments withCustomerId(String customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = JsonNullable.of(customerId);
        return this;
    }

    /**
     * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
     * payments, but can also be used on regular payments to enable single-click payments.
     * 
     * <p>If `sequenceType` is set to `recurring`, this field is required.
     */
    public ListPaymentsPayments withCustomerId(JsonNullable<String> customerId) {
        Utils.checkNotNull(customerId, "customerId");
        this.customerId = customerId;
        return this;
    }

    /**
     * The identifier referring to the [profile](get-profile) this entity belongs to.
     * 
     * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
     * Organization tokens, the `profileId` is required.
     * 
     * <p>For more information, see [Authentication](authentication).
     */
    public ListPaymentsPayments withProfileId(String profileId) {
        Utils.checkNotNull(profileId, "profileId");
        this.profileId = profileId;
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public ListPaymentsPayments withSettlementId(String settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = JsonNullable.of(settlementId);
        return this;
    }

    /**
     * The identifier referring to the [settlement](get-settlement) this payment was settled with.
     */
    public ListPaymentsPayments withSettlementId(JsonNullable<String> settlementId) {
        Utils.checkNotNull(settlementId, "settlementId");
        this.settlementId = settlementId;
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public ListPaymentsPayments withOrderId(String orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = JsonNullable.of(orderId);
        return this;
    }

    /**
     * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
     */
    public ListPaymentsPayments withOrderId(JsonNullable<String> orderId) {
        Utils.checkNotNull(orderId, "orderId");
        this.orderId = orderId;
        return this;
    }

    /**
     * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
     * statuses occur at what point.
     */
    public ListPaymentsPayments withStatus(ListPaymentsStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    public ListPaymentsPayments withStatusReason(ListPaymentsStatusReason statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = JsonNullable.of(statusReason);
        return this;
    }

    /**
     * This object offers details about the status of a payment. Currently it is only available for point-of-sale
     * payments.
     * 
     * <p>You can find more information about the possible values of this object on
     * [this page](status-reasons).**
     */
    public ListPaymentsPayments withStatusReason(JsonNullable<? extends ListPaymentsStatusReason> statusReason) {
        Utils.checkNotNull(statusReason, "statusReason");
        this.statusReason = statusReason;
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public ListPaymentsPayments withIsCancelable(boolean isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = JsonNullable.of(isCancelable);
        return this;
    }

    /**
     * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
     */
    public ListPaymentsPayments withIsCancelable(JsonNullable<Boolean> isCancelable) {
        Utils.checkNotNull(isCancelable, "isCancelable");
        this.isCancelable = isCancelable;
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    public ListPaymentsPayments withDetails(Map<String, Object> details) {
        Utils.checkNotNull(details, "details");
        this.details = JsonNullable.of(details);
        return this;
    }

    /**
     * An object containing payment details collected during the payment process. For example, details may include the
     * customer's card or bank details and a payment reference. For the full list of details, please refer to the
     * [method-specific parameters](extra-payment-parameters) guide.
     */
    public ListPaymentsPayments withDetails(JsonNullable<? extends Map<String, Object>> details) {
        Utils.checkNotNull(details, "details");
        this.details = details;
        return this;
    }

    /**
     * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    public ListPaymentsPayments withCreatedAt(String createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
     * not authorized (yet).
     */
    public ListPaymentsPayments withAuthorizedAt(String authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = JsonNullable.of(authorizedAt);
        return this;
    }

    /**
     * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
     * not authorized (yet).
     */
    public ListPaymentsPayments withAuthorizedAt(JsonNullable<String> authorizedAt) {
        Utils.checkNotNull(authorizedAt, "authorizedAt");
        this.authorizedAt = authorizedAt;
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
     * completed (yet).
     */
    public ListPaymentsPayments withPaidAt(String paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = JsonNullable.of(paidAt);
        return this;
    }

    /**
     * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
     * completed (yet).
     */
    public ListPaymentsPayments withPaidAt(JsonNullable<String> paidAt) {
        Utils.checkNotNull(paidAt, "paidAt");
        this.paidAt = paidAt;
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
     * canceled (yet).
     */
    public ListPaymentsPayments withCanceledAt(String canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = JsonNullable.of(canceledAt);
        return this;
    }

    /**
     * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
     * canceled (yet).
     */
    public ListPaymentsPayments withCanceledAt(JsonNullable<String> canceledAt) {
        Utils.checkNotNull(canceledAt, "canceledAt");
        this.canceledAt = canceledAt;
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
     * longer expire.
     */
    public ListPaymentsPayments withExpiresAt(String expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = JsonNullable.of(expiresAt);
        return this;
    }

    /**
     * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
     * longer expire.
     */
    public ListPaymentsPayments withExpiresAt(JsonNullable<String> expiresAt) {
        Utils.checkNotNull(expiresAt, "expiresAt");
        this.expiresAt = expiresAt;
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
     * expire (yet).
     */
    public ListPaymentsPayments withExpiredAt(String expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = JsonNullable.of(expiredAt);
        return this;
    }

    /**
     * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
     * expire (yet).
     */
    public ListPaymentsPayments withExpiredAt(JsonNullable<String> expiredAt) {
        Utils.checkNotNull(expiredAt, "expiredAt");
        this.expiredAt = expiredAt;
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
     * (yet).
     */
    public ListPaymentsPayments withFailedAt(String failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = JsonNullable.of(failedAt);
        return this;
    }

    /**
     * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
     * (yet).
     */
    public ListPaymentsPayments withFailedAt(JsonNullable<String> failedAt) {
        Utils.checkNotNull(failedAt, "failedAt");
        this.failedAt = failedAt;
        return this;
    }

    /**
     * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
     */
    public ListPaymentsPayments withLinks(ListPaymentsPaymentsLinks links) {
        Utils.checkNotNull(links, "links");
        this.links = links;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ListPaymentsPayments other = (ListPaymentsPayments) o;
        return 
            Utils.enhancedDeepEquals(this.resource, other.resource) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.mode, other.mode) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.amount, other.amount) &&
            Utils.enhancedDeepEquals(this.amountRefunded, other.amountRefunded) &&
            Utils.enhancedDeepEquals(this.amountRemaining, other.amountRemaining) &&
            Utils.enhancedDeepEquals(this.amountCaptured, other.amountCaptured) &&
            Utils.enhancedDeepEquals(this.amountChargedBack, other.amountChargedBack) &&
            Utils.enhancedDeepEquals(this.settlementAmount, other.settlementAmount) &&
            Utils.enhancedDeepEquals(this.redirectUrl, other.redirectUrl) &&
            Utils.enhancedDeepEquals(this.cancelUrl, other.cancelUrl) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.lines, other.lines) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.locale, other.locale) &&
            Utils.enhancedDeepEquals(this.countryCode, other.countryCode) &&
            Utils.enhancedDeepEquals(this.method, other.method) &&
            Utils.enhancedDeepEquals(this.restrictPaymentMethodsToCountry, other.restrictPaymentMethodsToCountry) &&
            Utils.enhancedDeepEquals(this.metadata, other.metadata) &&
            Utils.enhancedDeepEquals(this.captureMode, other.captureMode) &&
            Utils.enhancedDeepEquals(this.captureDelay, other.captureDelay) &&
            Utils.enhancedDeepEquals(this.captureBefore, other.captureBefore) &&
            Utils.enhancedDeepEquals(this.applicationFee, other.applicationFee) &&
            Utils.enhancedDeepEquals(this.routing, other.routing) &&
            Utils.enhancedDeepEquals(this.sequenceType, other.sequenceType) &&
            Utils.enhancedDeepEquals(this.subscriptionId, other.subscriptionId) &&
            Utils.enhancedDeepEquals(this.mandateId, other.mandateId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.profileId, other.profileId) &&
            Utils.enhancedDeepEquals(this.settlementId, other.settlementId) &&
            Utils.enhancedDeepEquals(this.orderId, other.orderId) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.statusReason, other.statusReason) &&
            Utils.enhancedDeepEquals(this.isCancelable, other.isCancelable) &&
            Utils.enhancedDeepEquals(this.details, other.details) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.authorizedAt, other.authorizedAt) &&
            Utils.enhancedDeepEquals(this.paidAt, other.paidAt) &&
            Utils.enhancedDeepEquals(this.canceledAt, other.canceledAt) &&
            Utils.enhancedDeepEquals(this.expiresAt, other.expiresAt) &&
            Utils.enhancedDeepEquals(this.expiredAt, other.expiredAt) &&
            Utils.enhancedDeepEquals(this.failedAt, other.failedAt) &&
            Utils.enhancedDeepEquals(this.links, other.links);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            resource, id, mode,
            description, amount, amountRefunded,
            amountRemaining, amountCaptured, amountChargedBack,
            settlementAmount, redirectUrl, cancelUrl,
            webhookUrl, lines, billingAddress,
            shippingAddress, locale, countryCode,
            method, restrictPaymentMethodsToCountry, metadata,
            captureMode, captureDelay, captureBefore,
            applicationFee, routing, sequenceType,
            subscriptionId, mandateId, customerId,
            profileId, settlementId, orderId,
            status, statusReason, isCancelable,
            details, createdAt, authorizedAt,
            paidAt, canceledAt, expiresAt,
            expiredAt, failedAt, links);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ListPaymentsPayments.class,
                "resource", resource,
                "id", id,
                "mode", mode,
                "description", description,
                "amount", amount,
                "amountRefunded", amountRefunded,
                "amountRemaining", amountRemaining,
                "amountCaptured", amountCaptured,
                "amountChargedBack", amountChargedBack,
                "settlementAmount", settlementAmount,
                "redirectUrl", redirectUrl,
                "cancelUrl", cancelUrl,
                "webhookUrl", webhookUrl,
                "lines", lines,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "locale", locale,
                "countryCode", countryCode,
                "method", method,
                "restrictPaymentMethodsToCountry", restrictPaymentMethodsToCountry,
                "metadata", metadata,
                "captureMode", captureMode,
                "captureDelay", captureDelay,
                "captureBefore", captureBefore,
                "applicationFee", applicationFee,
                "routing", routing,
                "sequenceType", sequenceType,
                "subscriptionId", subscriptionId,
                "mandateId", mandateId,
                "customerId", customerId,
                "profileId", profileId,
                "settlementId", settlementId,
                "orderId", orderId,
                "status", status,
                "statusReason", statusReason,
                "isCancelable", isCancelable,
                "details", details,
                "createdAt", createdAt,
                "authorizedAt", authorizedAt,
                "paidAt", paidAt,
                "canceledAt", canceledAt,
                "expiresAt", expiresAt,
                "expiredAt", expiredAt,
                "failedAt", failedAt,
                "links", links);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String resource;

        private String id;

        private ListPaymentsMode mode;

        private String description;

        private ListPaymentsAmount amount;

        private Optional<? extends ListPaymentsAmountRefunded> amountRefunded = Optional.empty();

        private Optional<? extends ListPaymentsAmountRemaining> amountRemaining = Optional.empty();

        private Optional<? extends ListPaymentsAmountCaptured> amountCaptured = Optional.empty();

        private Optional<? extends ListPaymentsAmountChargedBack> amountChargedBack = Optional.empty();

        private Optional<? extends ListPaymentsSettlementAmount> settlementAmount = Optional.empty();

        private JsonNullable<String> redirectUrl = JsonNullable.undefined();

        private JsonNullable<String> cancelUrl = JsonNullable.undefined();

        private JsonNullable<String> webhookUrl = JsonNullable.undefined();

        private JsonNullable<? extends List<ListPaymentsLines>> lines = JsonNullable.undefined();

        private Optional<? extends ListPaymentsBillingAddress> billingAddress = Optional.empty();

        private Optional<? extends ListPaymentsShippingAddress> shippingAddress = Optional.empty();

        private JsonNullable<? extends ListPaymentsLocale> locale = JsonNullable.undefined();

        private JsonNullable<String> countryCode = JsonNullable.undefined();

        private JsonNullable<? extends ListPaymentsMethod> method = JsonNullable.undefined();

        private JsonNullable<String> restrictPaymentMethodsToCountry = JsonNullable.undefined();

        private JsonNullable<? extends ListPaymentsMetadata> metadata = JsonNullable.undefined();

        private JsonNullable<? extends ListPaymentsCaptureMode> captureMode;

        private JsonNullable<? extends ListPaymentsCaptureDelay> captureDelay = JsonNullable.undefined();

        private JsonNullable<String> captureBefore = JsonNullable.undefined();

        private JsonNullable<? extends ListPaymentsApplicationFee> applicationFee = JsonNullable.undefined();

        private JsonNullable<? extends List<ListPaymentsRouting>> routing = JsonNullable.undefined();

        private JsonNullable<? extends ListPaymentsSequenceType> sequenceType;

        private JsonNullable<String> subscriptionId = JsonNullable.undefined();

        private JsonNullable<String> mandateId = JsonNullable.undefined();

        private JsonNullable<String> customerId = JsonNullable.undefined();

        private String profileId;

        private JsonNullable<String> settlementId = JsonNullable.undefined();

        private JsonNullable<String> orderId = JsonNullable.undefined();

        private ListPaymentsStatus status;

        private JsonNullable<? extends ListPaymentsStatusReason> statusReason = JsonNullable.undefined();

        private JsonNullable<Boolean> isCancelable = JsonNullable.undefined();

        private JsonNullable<? extends Map<String, Object>> details = JsonNullable.undefined();

        private String createdAt;

        private JsonNullable<String> authorizedAt = JsonNullable.undefined();

        private JsonNullable<String> paidAt = JsonNullable.undefined();

        private JsonNullable<String> canceledAt = JsonNullable.undefined();

        private JsonNullable<String> expiresAt = JsonNullable.undefined();

        private JsonNullable<String> expiredAt = JsonNullable.undefined();

        private JsonNullable<String> failedAt = JsonNullable.undefined();

        private ListPaymentsPaymentsLinks links;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * Indicates the response contains a payment object. Will always contain the string `payment` for this endpoint.
         */
        public Builder resource(String resource) {
            Utils.checkNotNull(resource, "resource");
            this.resource = resource;
            return this;
        }


        /**
         * The identifier uniquely referring to this payment. Mollie assigns this identifier at payment creation time. Mollie
         * will always refer to the payment by this ID. Example: `tr_5B8cwPMGnU6qLbRvo7qEZo`.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Whether this entity was created in live mode or in test mode.
         */
        public Builder mode(ListPaymentsMode mode) {
            Utils.checkNotNull(mode, "mode");
            this.mode = mode;
            return this;
        }


        /**
         * The description of the payment. This will be shown to your customer on their card or bank statement when possible.
         * We truncate the description automatically according to the limits of the used payment method. The description is
         * also visible in any exports you generate.
         * 
         * <p>We recommend you use a unique identifier so that you can always link the payment to the order in your back office.
         * This is particularly useful for bookkeeping.
         * 
         * <p>The maximum length of the description field differs per payment method, with the absolute maximum being 255
         * characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        /**
         * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
         * 
         * <p>You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be
         * retrieved using the Get method endpoint.
         * 
         * <p>If a tip was added for a Point-of-Sale payment, the amount will be updated to reflect the initial amount plus the
         * tip amount.
         */
        public Builder amount(ListPaymentsAmount amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }


        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some
         * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
         * costs for a return shipment to the customer.
         */
        public Builder amountRefunded(ListPaymentsAmountRefunded amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = Optional.ofNullable(amountRefunded);
            return this;
        }

        /**
         * The total amount that is already refunded. Only available when refunds are available for this payment. For some
         * payment methods, this amount may be higher than the payment amount, for example to allow reimbursement of the
         * costs for a return shipment to the customer.
         */
        public Builder amountRefunded(Optional<? extends ListPaymentsAmountRefunded> amountRefunded) {
            Utils.checkNotNull(amountRefunded, "amountRefunded");
            this.amountRefunded = amountRefunded;
            return this;
        }


        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(ListPaymentsAmountRemaining amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = Optional.ofNullable(amountRemaining);
            return this;
        }

        /**
         * The remaining amount that can be refunded. Only available when refunds are available for this payment.
         */
        public Builder amountRemaining(Optional<? extends ListPaymentsAmountRemaining> amountRemaining) {
            Utils.checkNotNull(amountRemaining, "amountRemaining");
            this.amountRemaining = amountRemaining;
            return this;
        }


        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(ListPaymentsAmountCaptured amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = Optional.ofNullable(amountCaptured);
            return this;
        }

        /**
         * The total amount that is already captured for this payment. Only available when this payment supports captures.
         */
        public Builder amountCaptured(Optional<? extends ListPaymentsAmountCaptured> amountCaptured) {
            Utils.checkNotNull(amountCaptured, "amountCaptured");
            this.amountCaptured = amountCaptured;
            return this;
        }


        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not
         * zero.
         */
        public Builder amountChargedBack(ListPaymentsAmountChargedBack amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = Optional.ofNullable(amountChargedBack);
            return this;
        }

        /**
         * The total amount that was charged back for this payment. Only available when the total charged back amount is not
         * zero.
         */
        public Builder amountChargedBack(Optional<? extends ListPaymentsAmountChargedBack> amountChargedBack) {
            Utils.checkNotNull(amountChargedBack, "amountChargedBack");
            this.amountChargedBack = amountChargedBack;
            return this;
        }


        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the
         * currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
         * settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
         * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(ListPaymentsSettlementAmount settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = Optional.ofNullable(settlementAmount);
            return this;
        }

        /**
         * This optional field will contain the approximate amount that will be settled to your account, converted to the
         * currency your account is settled in.
         * 
         * <p>Any amounts not settled by Mollie will not be reflected in this amount, e.g. PayPal or gift cards. If no amount is
         * settled by Mollie the `settlementAmount` is omitted from the response.
         * 
         * <p>Please note that this amount might be recalculated and changed when the status of the payment changes. We suggest
         * using the List balance transactions endpoint instead to get more accurate settlement amounts for your payments.
         */
        public Builder settlementAmount(Optional<? extends ListPaymentsSettlementAmount> settlementAmount) {
            Utils.checkNotNull(settlementAmount, "settlementAmount");
            this.settlementAmount = settlementAmount;
            return this;
        }


        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(String redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = JsonNullable.of(redirectUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to after the payment process.
         * 
         * <p>It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the
         * right page referencing the order when your customer returns.
         * 
         * <p>The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for
         * Apple Pay payments with an `applePayPaymentToken`.
         */
        public Builder redirectUrl(JsonNullable<String> redirectUrl) {
            Utils.checkNotNull(redirectUrl, "redirectUrl");
            this.redirectUrl = redirectUrl;
            return this;
        }


        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(String cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = JsonNullable.of(cancelUrl);
            return this;
        }

        /**
         * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not
         * provided, the customer will be redirected to the `redirectUrl` instead — see above.
         * 
         * <p>Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is
         * therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle
         * payment cancellations.
         */
        public Builder cancelUrl(JsonNullable<String> cancelUrl) {
            Utils.checkNotNull(cancelUrl, "cancelUrl");
            this.cancelUrl = cancelUrl;
            return this;
        }


        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = JsonNullable.of(webhookUrl);
            return this;
        }

        /**
         * The webhook URL where we will send payment status updates to.
         * 
         * <p>The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
         * 
         * <p>The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use
         * webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your
         * local machine.
         */
        public Builder webhookUrl(JsonNullable<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(List<ListPaymentsLines> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = JsonNullable.of(lines);
            return this;
        }

        /**
         * Optionally provide the order lines for the payment. Each line contains details such as a description of the item
         * ordered and its price.
         * 
         * <p>All lines must have the same currency as the payment.
         * 
         * <p>Required for payment methods `billie`, `in3`, `klarna`, `riverty` and `voucher`.
         */
        public Builder lines(JsonNullable<? extends List<ListPaymentsLines>> lines) {
            Utils.checkNotNull(lines, "lines");
            this.lines = lines;
            return this;
        }


        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(ListPaymentsBillingAddress billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        /**
         * The customer's billing address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         * 
         * <p>Required for payment method `in3`, `klarna`, `billie` and `riverty`.
         */
        public Builder billingAddress(Optional<? extends ListPaymentsBillingAddress> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }


        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         */
        public Builder shippingAddress(ListPaymentsShippingAddress shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        /**
         * The customer's shipping address details. We advise to provide these details to improve fraud protection and
         * conversion.
         * 
         * <p>Should include `email` or a valid postal address consisting of `streetAndNumber`, `postalCode`, `city` and
         * `country`.
         */
        public Builder shippingAddress(Optional<? extends ListPaymentsShippingAddress> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
         * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
         * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
         * locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
         * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
         * customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(ListPaymentsLocale locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = JsonNullable.of(locale);
            return this;
        }

        /**
         * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale
         * is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser
         * language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897
         * locale, but our hosted payment pages currently only support the specified languages.
         * 
         * <p>For bank transfer payments specifically, the locale will determine the target bank account the customer has to
         * transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the
         * customer use a local bank account greatly increases the conversion and speed of payment.
         */
        public Builder locale(JsonNullable<? extends ListPaymentsLocale> locale) {
            Utils.checkNotNull(locale, "locale");
            this.locale = locale;
            return this;
        }


        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
         * field is omitted if the country code was not detected.
         */
        public Builder countryCode(String countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = JsonNullable.of(countryCode);
            return this;
        }

        /**
         * This optional field contains your customer's ISO 3166-1 alpha-2 country code, detected by us during checkout. This
         * field is omitted if the country code was not detected.
         */
        public Builder countryCode(JsonNullable<String> countryCode) {
            Utils.checkNotNull(countryCode, "countryCode");
            this.countryCode = countryCode;
            return this;
        }


        /**
         * The payment method used for this transaction. If a specific method was selected during payment initialization,
         * this field reflects that choice.
         */
        public Builder method(ListPaymentsMethod method) {
            Utils.checkNotNull(method, "method");
            this.method = JsonNullable.of(method);
            return this;
        }

        /**
         * The payment method used for this transaction. If a specific method was selected during payment initialization,
         * this field reflects that choice.
         */
        public Builder method(JsonNullable<? extends ListPaymentsMethod> method) {
            Utils.checkNotNull(method, "method");
            this.method = method;
            return this;
        }


        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(String restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = JsonNullable.of(restrictPaymentMethodsToCountry);
            return this;
        }

        /**
         * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT
         * rates you have used for the order to ensure your customer's country matches the VAT country.
         * 
         * <p>Use this parameter to restrict the payment methods available to your customer to those from a single country.
         * 
         * <p>If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
         * 
         * <p>The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
         */
        public Builder restrictPaymentMethodsToCountry(JsonNullable<String> restrictPaymentMethodsToCountry) {
            Utils.checkNotNull(restrictPaymentMethodsToCountry, "restrictPaymentMethodsToCountry");
            this.restrictPaymentMethodsToCountry = restrictPaymentMethodsToCountry;
            return this;
        }


        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(ListPaymentsMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever
         * you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
         */
        public Builder metadata(JsonNullable<? extends ListPaymentsMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }


        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(ListPaymentsCaptureMode captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = JsonNullable.of(captureMode);
            return this;
        }

        /**
         * Indicate if the funds should be captured immediately or if you want to [place a hold](https://docs.mollie.com/docs/place-a-hold-for-a-payment#/) 
         * and capture at a later time.
         * 
         * <p>This field needs to be set to `manual` for method `riverty`.
         */
        public Builder captureMode(JsonNullable<? extends ListPaymentsCaptureMode> captureMode) {
            Utils.checkNotNull(captureMode, "captureMode");
            this.captureMode = captureMode;
            return this;
        }


        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         */
        public Builder captureDelay(ListPaymentsCaptureDelay captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = JsonNullable.of(captureDelay);
            return this;
        }

        /**
         * **Only relevant if you wish to manage authorization and capturing separately.**
         * 
         * <p>Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a
         * later point either be 'captured' or canceled.
         * 
         * <p>By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a
         * capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For
         * example `8 hours` or `2 days`.
         * 
         * <p>To schedule an automatic capture, the `captureMode` must be set to `automatic`.
         * 
         * <p>The maximum delay is 7 days (168 hours).
         */
        public Builder captureDelay(JsonNullable<? extends ListPaymentsCaptureDelay> captureDelay) {
            Utils.checkNotNull(captureDelay, "captureDelay");
            this.captureDelay = captureDelay;
            return this;
        }


        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
         * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(String captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = JsonNullable.of(captureBefore);
            return this;
        }

        /**
         * Indicates the date before which the payment needs to be captured, in ISO 8601 format. From this date onwards we
         * can no longer guarantee a successful capture. The parameter is omitted if the payment is not authorized (yet).
         */
        public Builder captureBefore(JsonNullable<String> captureBefore) {
            Utils.checkNotNull(captureBefore, "captureBefore");
            this.captureBefore = captureBefore;
            return this;
        }


        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(ListPaymentsApplicationFee applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = JsonNullable.of(applicationFee);
            return this;
        }

        /**
         * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this
         * `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent
         * to your own account balance.
         * 
         * <p>If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the
         * `routing` parameter.
         */
        public Builder applicationFee(JsonNullable<? extends ListPaymentsApplicationFee> applicationFee) {
            Utils.checkNotNull(applicationFee, "applicationFee");
            this.applicationFee = applicationFee;
            return this;
        }


        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(List<ListPaymentsRouting> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = JsonNullable.of(routing);
            return this;
        }

        /**
         * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
         * 
         * <p>With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie
         * merchants.
         * 
         * <p>If you create payments on your own account that you want to split between yourself and one or more connected
         * merchants, you can use this `routing` parameter to route the payment accordingly.
         * 
         * <p>The `routing` parameter should contain an array of objects, with each object describing the destination for a
         * specific portion of the payment.
         * 
         * <p>It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total
         * payment amount have been routed, the amount left will be routed to the current organization automatically.
         * 
         * <p>If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee`
         * parameter.
         */
        public Builder routing(JsonNullable<? extends List<ListPaymentsRouting>> routing) {
            Utils.checkNotNull(routing, "routing");
            this.routing = routing;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
         * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
         * on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
         * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
         * are set up correctly for recurring payments.
         */
        public Builder sequenceType(ListPaymentsSequenceType sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = JsonNullable.of(sequenceType);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>Indicate which part of a recurring sequence this payment is for.
         * 
         * <p>Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is
         * through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place
         * on their account in the future.
         * 
         * <p>If set to `recurring`, the customer's card is charged automatically.
         * 
         * <p>Defaults to `oneoff`, which is a regular non-recurring payment.
         * 
         * <p>For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our
         * [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account
         * are set up correctly for recurring payments.
         */
        public Builder sequenceType(JsonNullable<? extends ListPaymentsSequenceType> sequenceType) {
            Utils.checkNotNull(sequenceType, "sequenceType");
            this.sequenceType = sequenceType;
            return this;
        }


        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
         * be added to the response.
         */
        public Builder subscriptionId(String subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = JsonNullable.of(subscriptionId);
            return this;
        }

        /**
         * If the payment was automatically created via a subscription, the ID of the [subscription](get-subscription) will
         * be added to the response.
         */
        public Builder subscriptionId(JsonNullable<String> subscriptionId) {
            Utils.checkNotNull(subscriptionId, "subscriptionId");
            this.subscriptionId = subscriptionId;
            return this;
        }


        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
         * the customer's accounts should be credited.
         */
        public Builder mandateId(String mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = JsonNullable.of(mandateId);
            return this;
        }

        /**
         * **Only relevant for recurring payments.**
         * 
         * <p>When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of
         * the customer's accounts should be credited.
         */
        public Builder mandateId(JsonNullable<String> mandateId) {
            Utils.checkNotNull(mandateId, "mandateId");
            this.mandateId = mandateId;
            return this;
        }


        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
         * payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(String customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = JsonNullable.of(customerId);
            return this;
        }

        /**
         * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring
         * payments, but can also be used on regular payments to enable single-click payments.
         * 
         * <p>If `sequenceType` is set to `recurring`, this field is required.
         */
        public Builder customerId(JsonNullable<String> customerId) {
            Utils.checkNotNull(customerId, "customerId");
            this.customerId = customerId;
            return this;
        }


        /**
         * The identifier referring to the [profile](get-profile) this entity belongs to.
         * 
         * <p>When using an API Key, the `profileId` can be omitted since it is linked to the key. However, for OAuth and
         * Organization tokens, the `profileId` is required.
         * 
         * <p>For more information, see [Authentication](authentication).
         */
        public Builder profileId(String profileId) {
            Utils.checkNotNull(profileId, "profileId");
            this.profileId = profileId;
            return this;
        }


        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(String settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = JsonNullable.of(settlementId);
            return this;
        }

        /**
         * The identifier referring to the [settlement](get-settlement) this payment was settled with.
         */
        public Builder settlementId(JsonNullable<String> settlementId) {
            Utils.checkNotNull(settlementId, "settlementId");
            this.settlementId = settlementId;
            return this;
        }


        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(String orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = JsonNullable.of(orderId);
            return this;
        }

        /**
         * If the payment was created for an [order](get-order), the ID of that order will be part of the response.
         */
        public Builder orderId(JsonNullable<String> orderId) {
            Utils.checkNotNull(orderId, "orderId");
            this.orderId = orderId;
            return this;
        }


        /**
         * The payment's status. Refer to the [documentation regarding statuses](https://docs.mollie.com/docs/status-change#/) for more info about which
         * statuses occur at what point.
         */
        public Builder status(ListPaymentsStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale
         * payments.
         * 
         * <p>You can find more information about the possible values of this object on
         * [this page](status-reasons).**
         */
        public Builder statusReason(ListPaymentsStatusReason statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = JsonNullable.of(statusReason);
            return this;
        }

        /**
         * This object offers details about the status of a payment. Currently it is only available for point-of-sale
         * payments.
         * 
         * <p>You can find more information about the possible values of this object on
         * [this page](status-reasons).**
         */
        public Builder statusReason(JsonNullable<? extends ListPaymentsStatusReason> statusReason) {
            Utils.checkNotNull(statusReason, "statusReason");
            this.statusReason = statusReason;
            return this;
        }


        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(boolean isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = JsonNullable.of(isCancelable);
            return this;
        }

        /**
         * Whether the payment can be canceled. This parameter is omitted if the payment reaches a final state.
         */
        public Builder isCancelable(JsonNullable<Boolean> isCancelable) {
            Utils.checkNotNull(isCancelable, "isCancelable");
            this.isCancelable = isCancelable;
            return this;
        }


        /**
         * An object containing payment details collected during the payment process. For example, details may include the
         * customer's card or bank details and a payment reference. For the full list of details, please refer to the
         * [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(Map<String, Object> details) {
            Utils.checkNotNull(details, "details");
            this.details = JsonNullable.of(details);
            return this;
        }

        /**
         * An object containing payment details collected during the payment process. For example, details may include the
         * customer's card or bank details and a payment reference. For the full list of details, please refer to the
         * [method-specific parameters](extra-payment-parameters) guide.
         */
        public Builder details(JsonNullable<? extends Map<String, Object>> details) {
            Utils.checkNotNull(details, "details");
            this.details = details;
            return this;
        }


        /**
         * The entity's date and time of creation, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        public Builder createdAt(String createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
         * not authorized (yet).
         */
        public Builder authorizedAt(String authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = JsonNullable.of(authorizedAt);
            return this;
        }

        /**
         * The date and time the payment became authorized, in ISO 8601 format. This parameter is omitted if the payment is
         * not authorized (yet).
         */
        public Builder authorizedAt(JsonNullable<String> authorizedAt) {
            Utils.checkNotNull(authorizedAt, "authorizedAt");
            this.authorizedAt = authorizedAt;
            return this;
        }


        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
         * completed (yet).
         */
        public Builder paidAt(String paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = JsonNullable.of(paidAt);
            return this;
        }

        /**
         * The date and time the payment became paid, in ISO 8601 format. This parameter is omitted if the payment is not
         * completed (yet).
         */
        public Builder paidAt(JsonNullable<String> paidAt) {
            Utils.checkNotNull(paidAt, "paidAt");
            this.paidAt = paidAt;
            return this;
        }


        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
         * canceled (yet).
         */
        public Builder canceledAt(String canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = JsonNullable.of(canceledAt);
            return this;
        }

        /**
         * The date and time the payment was canceled, in ISO 8601 format. This parameter is omitted if the payment is not
         * canceled (yet).
         */
        public Builder canceledAt(JsonNullable<String> canceledAt) {
            Utils.checkNotNull(canceledAt, "canceledAt");
            this.canceledAt = canceledAt;
            return this;
        }


        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
         * longer expire.
         */
        public Builder expiresAt(String expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = JsonNullable.of(expiresAt);
            return this;
        }

        /**
         * The date and time the payment will expire, in ISO 8601 format. This parameter is omitted if the payment can no
         * longer expire.
         */
        public Builder expiresAt(JsonNullable<String> expiresAt) {
            Utils.checkNotNull(expiresAt, "expiresAt");
            this.expiresAt = expiresAt;
            return this;
        }


        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
         * expire (yet).
         */
        public Builder expiredAt(String expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = JsonNullable.of(expiredAt);
            return this;
        }

        /**
         * The date and time the payment was expired, in ISO 8601 format. This parameter is omitted if the payment did not
         * expire (yet).
         */
        public Builder expiredAt(JsonNullable<String> expiredAt) {
            Utils.checkNotNull(expiredAt, "expiredAt");
            this.expiredAt = expiredAt;
            return this;
        }


        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
         * (yet).
         */
        public Builder failedAt(String failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = JsonNullable.of(failedAt);
            return this;
        }

        /**
         * The date and time the payment failed, in ISO 8601 format. This parameter is omitted if the payment did not fail
         * (yet).
         */
        public Builder failedAt(JsonNullable<String> failedAt) {
            Utils.checkNotNull(failedAt, "failedAt");
            this.failedAt = failedAt;
            return this;
        }


        /**
         * An object with several relevant URLs. Every URL object will contain an `href` and a `type` field.
         */
        public Builder links(ListPaymentsPaymentsLinks links) {
            Utils.checkNotNull(links, "links");
            this.links = links;
            return this;
        }

        public ListPaymentsPayments build() {
            if (captureMode == null) {
                captureMode = _SINGLETON_VALUE_CaptureMode.value();
            }
            if (sequenceType == null) {
                sequenceType = _SINGLETON_VALUE_SequenceType.value();
            }

            return new ListPaymentsPayments(
                resource, id, mode,
                description, amount, amountRefunded,
                amountRemaining, amountCaptured, amountChargedBack,
                settlementAmount, redirectUrl, cancelUrl,
                webhookUrl, lines, billingAddress,
                shippingAddress, locale, countryCode,
                method, restrictPaymentMethodsToCountry, metadata,
                captureMode, captureDelay, captureBefore,
                applicationFee, routing, sequenceType,
                subscriptionId, mandateId, customerId,
                profileId, settlementId, orderId,
                status, statusReason, isCancelable,
                details, createdAt, authorizedAt,
                paidAt, canceledAt, expiresAt,
                expiredAt, failedAt, links);
        }


        private static final LazySingletonValue<JsonNullable<? extends ListPaymentsCaptureMode>> _SINGLETON_VALUE_CaptureMode =
                new LazySingletonValue<>(
                        "captureMode",
                        "\"automatic\"",
                        new TypeReference<JsonNullable<? extends ListPaymentsCaptureMode>>() {});

        private static final LazySingletonValue<JsonNullable<? extends ListPaymentsSequenceType>> _SINGLETON_VALUE_SequenceType =
                new LazySingletonValue<>(
                        "sequenceType",
                        "\"oneoff\"",
                        new TypeReference<JsonNullable<? extends ListPaymentsSequenceType>>() {});
    }
}
