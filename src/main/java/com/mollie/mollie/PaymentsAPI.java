/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.mollie.mollie;

import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.models.errors.APIException;
import com.mollie.mollie.models.errors.CancelPaymentPaymentsAPIResponseBody;
import com.mollie.mollie.models.errors.CancelPaymentResponseBody;
import com.mollie.mollie.models.errors.CreatePaymentPaymentsAPIResponseBody;
import com.mollie.mollie.models.errors.CreatePaymentResponseBody;
import com.mollie.mollie.models.errors.ReleaseAuthorizationPaymentsAPIResponseBody;
import com.mollie.mollie.models.errors.ReleaseAuthorizationResponseBody;
import com.mollie.mollie.models.errors.UpdatePaymentPaymentsAPIResponseBody;
import com.mollie.mollie.models.errors.UpdatePaymentResponseBody;
import com.mollie.mollie.models.operations.CancelPaymentRequest;
import com.mollie.mollie.models.operations.CancelPaymentRequestBuilder;
import com.mollie.mollie.models.operations.CancelPaymentResponse;
import com.mollie.mollie.models.operations.CreatePaymentRequest;
import com.mollie.mollie.models.operations.CreatePaymentRequestBody;
import com.mollie.mollie.models.operations.CreatePaymentRequestBuilder;
import com.mollie.mollie.models.operations.CreatePaymentResponse;
import com.mollie.mollie.models.operations.GetPaymentRequest;
import com.mollie.mollie.models.operations.GetPaymentRequestBuilder;
import com.mollie.mollie.models.operations.GetPaymentResponse;
import com.mollie.mollie.models.operations.GetPaymentResponseBody;
import com.mollie.mollie.models.operations.ListPaymentsRequest;
import com.mollie.mollie.models.operations.ListPaymentsRequestBuilder;
import com.mollie.mollie.models.operations.ListPaymentsResponse;
import com.mollie.mollie.models.operations.ListPaymentsResponseBody;
import com.mollie.mollie.models.operations.ReleaseAuthorizationRequest;
import com.mollie.mollie.models.operations.ReleaseAuthorizationRequestBuilder;
import com.mollie.mollie.models.operations.ReleaseAuthorizationResponse;
import com.mollie.mollie.models.operations.SDKMethodInterfaces.*;
import com.mollie.mollie.models.operations.UpdatePaymentRequest;
import com.mollie.mollie.models.operations.UpdatePaymentRequestBody;
import com.mollie.mollie.models.operations.UpdatePaymentRequestBuilder;
import com.mollie.mollie.models.operations.UpdatePaymentResponse;
import com.mollie.mollie.utils.HTTPClient;
import com.mollie.mollie.utils.HTTPRequest;
import com.mollie.mollie.utils.Hook.AfterErrorContextImpl;
import com.mollie.mollie.utils.Hook.AfterSuccessContextImpl;
import com.mollie.mollie.utils.Hook.BeforeRequestContextImpl;
import com.mollie.mollie.utils.SerializedBody;
import com.mollie.mollie.utils.Utils.JsonShape;
import com.mollie.mollie.utils.Utils;
import java.io.InputStream;
import java.lang.Boolean;
import java.lang.Exception;
import java.lang.Long;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable; 

public class PaymentsAPI implements
            MethodCallCreatePayment,
            MethodCallListPayments,
            MethodCallGetPayment,
            MethodCallUpdatePayment,
            MethodCallCancelPayment,
            MethodCallReleaseAuthorization {

    private final SDKConfiguration sdkConfiguration;

    PaymentsAPI(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }


    /**
     * Create payment
     * Payment creation is elemental to the Mollie API: this is where most payment implementations start off.
     * 
     * Once you have created a payment, you should redirect your customer to the URL in the `_links.checkout` property from the response.
     * 
     * To wrap your head around the payment process, an explanation and flow charts can be found in the 'Accepting payments' guide.
     * 
     * If you specify the `method` parameter when creating a payment, optional additional parameters may be available for the payment method that are not listed below. Please refer to the guide on [method-specific parameters](extra-payment-parameters).
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The call builder
     */
    public CreatePaymentRequestBuilder createPayment() {
        return new CreatePaymentRequestBuilder(this);
    }

    /**
     * Create payment
     * Payment creation is elemental to the Mollie API: this is where most payment implementations start off.
     * 
     * Once you have created a payment, you should redirect your customer to the URL in the `_links.checkout` property from the response.
     * 
     * To wrap your head around the payment process, an explanation and flow charts can be found in the 'Accepting payments' guide.
     * 
     * If you specify the `method` parameter when creating a payment, optional additional parameters may be available for the payment method that are not listed below. Please refer to the guide on [method-specific parameters](extra-payment-parameters).
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreatePaymentResponse createPaymentDirect() throws Exception {
        return createPayment(JsonNullable.undefined(), Optional.empty());
    }
    
    /**
     * Create payment
     * Payment creation is elemental to the Mollie API: this is where most payment implementations start off.
     * 
     * Once you have created a payment, you should redirect your customer to the URL in the `_links.checkout` property from the response.
     * 
     * To wrap your head around the payment process, an explanation and flow charts can be found in the 'Accepting payments' guide.
     * 
     * If you specify the `method` parameter when creating a payment, optional additional parameters may be available for the payment method that are not listed below. Please refer to the guide on [method-specific parameters](extra-payment-parameters).
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param include This endpoint allows you to include additional information via the `include` query string parameter.

    * `details.qrCode`: Include a QR code object. Only available for iDEAL, Bancontact and bank transfer payments.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreatePaymentResponse createPayment(
            JsonNullable<String> include,
            Optional<? extends CreatePaymentRequestBody> requestBody) throws Exception {
        CreatePaymentRequest request =
            CreatePaymentRequest
                .builder()
                .include(include)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/payments");
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CreatePaymentRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "422", "4XX", "503", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreatePaymentResponse.Builder _resBuilder = 
            CreatePaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreatePaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreatePaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreatePaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "503")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreatePaymentPaymentsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreatePaymentPaymentsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List payments
     * Retrieve all payments created with the current website profile.
     * 
     * The results are paginated.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @return The call builder
     */
    public ListPaymentsRequestBuilder listPayments() {
        return new ListPaymentsRequestBuilder(this);
    }

    /**
     * List payments
     * Retrieve all payments created with the current website profile.
     * 
     * The results are paginated.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListPaymentsResponse listPaymentsDirect() throws Exception {
        return listPayments(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * List payments
     * Retrieve all payments created with the current website profile.
     * 
     * The results are paginated.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @param from Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the result set.
     * @param limit The maximum number of items to return. Defaults to 50 items.
     * @param sort Used for setting the direction of the result set. Defaults to descending order, meaning the results are ordered from newest to oldest.

    Possible values: `asc` `desc` (default: `desc`)
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListPaymentsResponse listPayments(
            Optional<String> from,
            JsonNullable<Long> limit,
            JsonNullable<String> sort,
            JsonNullable<Boolean> testmode) throws Exception {
        ListPaymentsRequest request =
            ListPaymentsRequest
                .builder()
                .from(from)
                .limit(limit)
                .sort(sort)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/payments");
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListPaymentsRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-payments", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-payments",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-payments",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-payments",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListPaymentsResponse.Builder _resBuilder = 
            ListPaymentsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListPaymentsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListPaymentsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListPaymentsResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListPaymentsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListPaymentsResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Get payment
     * Retrieve a single payment object by its payment ID.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @return The call builder
     */
    public GetPaymentRequestBuilder getPayment() {
        return new GetPaymentRequestBuilder(this);
    }

    /**
     * Get payment
     * Retrieve a single payment object by its payment ID.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetPaymentResponse getPayment(
            String paymentId) throws Exception {
        return getPayment(paymentId, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * Get payment
     * Retrieve a single payment object by its payment ID.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.read**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @param include This endpoint allows you to include additional information via the `include` query string parameter.

    * `details.qrCode`: Include a QR code object. Only available for iDEAL, Bancontact and bank transfer payments.
    * `details.remainderDetails`: For payments where gift cards or vouchers were applied and the remaining amount was paid with another payment method, this include will add another `details` object specifically for the remainder payment.
     * @param embed This endpoint allows embedding related API items by appending the following values via the `embed` query string parameter.

    * `captures`: Embed all captures created for this payment.
    * `refunds`: Embed all refunds created for this payment.
    * `chargebacks`: Embed all chargebacks created for this payment.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetPaymentResponse getPayment(
            String paymentId,
            JsonNullable<String> include,
            JsonNullable<String> embed,
            JsonNullable<Boolean> testmode) throws Exception {
        GetPaymentRequest request =
            GetPaymentRequest
                .builder()
                .paymentId(paymentId)
                .include(include)
                .embed(embed)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetPaymentRequest.class,
                _baseUrl,
                "/payments/{paymentId}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                GetPaymentRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "get-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "get-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetPaymentResponse.Builder _resBuilder = 
            GetPaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetPaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                GetPaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GetPaymentResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.GetPaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.GetPaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update payment
     * Certain details of an existing payment can be updated. For an in-depth explanation of each parameter, see [Create payment](create-payment).
     * 
     * Updating the payment details will not result in a webhook call.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The call builder
     */
    public UpdatePaymentRequestBuilder updatePayment() {
        return new UpdatePaymentRequestBuilder(this);
    }

    /**
     * Update payment
     * Certain details of an existing payment can be updated. For an in-depth explanation of each parameter, see [Create payment](create-payment).
     * 
     * Updating the payment details will not result in a webhook call.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdatePaymentResponse updatePayment(
            String paymentId) throws Exception {
        return updatePayment(paymentId, Optional.empty());
    }
    
    /**
     * Update payment
     * Certain details of an existing payment can be updated. For an in-depth explanation of each parameter, see [Create payment](create-payment).
     * 
     * Updating the payment details will not result in a webhook call.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdatePaymentResponse updatePayment(
            String paymentId,
            Optional<? extends UpdatePaymentRequestBody> requestBody) throws Exception {
        UpdatePaymentRequest request =
            UpdatePaymentRequest
                .builder()
                .paymentId(paymentId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdatePaymentRequest.class,
                _baseUrl,
                "/payments/{paymentId}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdatePaymentResponse.Builder _resBuilder = 
            UpdatePaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdatePaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdatePaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdatePaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdatePaymentPaymentsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdatePaymentPaymentsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel payment
     * Depending on the payment method, you may be able to cancel a payment for a certain amount of time â€” usually until the next business day or as long as the payment status is open.
     * 
     * Payments may also be canceled manually from the Mollie Dashboard.
     * 
     * The `isCancelable` property on the [Payment object](get-payment) will indicate if the payment can be canceled.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The call builder
     */
    public CancelPaymentRequestBuilder cancelPayment() {
        return new CancelPaymentRequestBuilder(this);
    }

    /**
     * Cancel payment
     * Depending on the payment method, you may be able to cancel a payment for a certain amount of time â€” usually until the next business day or as long as the payment status is open.
     * 
     * Payments may also be canceled manually from the Mollie Dashboard.
     * 
     * The `isCancelable` property on the [Payment object](get-payment) will indicate if the payment can be canceled.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelPaymentResponse cancelPayment(
            String paymentId) throws Exception {
        return cancelPayment(paymentId, JsonNullable.undefined());
    }
    
    /**
     * Cancel payment
     * Depending on the payment method, you may be able to cancel a payment for a certain amount of time â€” usually until the next business day or as long as the payment status is open.
     * 
     * Payments may also be canceled manually from the Mollie Dashboard.
     * 
     * The `isCancelable` property on the [Payment object](get-payment) will indicate if the payment can be canceled.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelPaymentResponse cancelPayment(
            String paymentId,
            JsonNullable<Boolean> testmode) throws Exception {
        CancelPaymentRequest request =
            CancelPaymentRequest
                .builder()
                .paymentId(paymentId)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelPaymentRequest.class,
                _baseUrl,
                "/payments/{paymentId}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CancelPaymentRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-payment", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-payment",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-payment",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelPaymentResponse.Builder _resBuilder = 
            CancelPaymentResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelPaymentResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelPaymentResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelPaymentResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelPaymentPaymentsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelPaymentPaymentsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Release payment authorization
     * Releases the full remaining authorized amount. Call this endpoint when you will not be making any additional captures. Payment authorizations may also be released manually from the Mollie Dashboard.
     * 
     * Mollie will do its best to process release requests, but it is not guaranteed that it will succeed. It is up to the issuing bank if and when the hold will be released.
     * 
     * If the request does succeed, the payment status will change to `canceled` for payments without captures. If there is a successful capture, the payment will transition to `paid`.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @return The call builder
     */
    public ReleaseAuthorizationRequestBuilder releaseAuthorization() {
        return new ReleaseAuthorizationRequestBuilder(this);
    }

    /**
     * Release payment authorization
     * Releases the full remaining authorized amount. Call this endpoint when you will not be making any additional captures. Payment authorizations may also be released manually from the Mollie Dashboard.
     * 
     * Mollie will do its best to process release requests, but it is not guaranteed that it will succeed. It is up to the issuing bank if and when the hold will be released.
     * 
     * If the request does succeed, the payment status will change to `canceled` for payments without captures. If there is a successful capture, the payment will transition to `paid`.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ReleaseAuthorizationResponse releaseAuthorization(
            String paymentId) throws Exception {
        return releaseAuthorization(paymentId, JsonNullable.undefined());
    }
    
    /**
     * Release payment authorization
     * Releases the full remaining authorized amount. Call this endpoint when you will not be making any additional captures. Payment authorizations may also be released manually from the Mollie Dashboard.
     * 
     * Mollie will do its best to process release requests, but it is not guaranteed that it will succeed. It is up to the issuing bank if and when the hold will be released.
     * 
     * If the request does succeed, the payment status will change to `canceled` for payments without captures. If there is a successful capture, the payment will transition to `paid`.
     * 
     * &gt; ðŸ”‘ Access with
     * &gt;
     * &gt; [API key](/reference/authentication)
     * &gt;
     * &gt; [Access token with **payments.write**](/reference/authentication)
     * @param paymentId Provide the ID of the related payment.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ReleaseAuthorizationResponse releaseAuthorization(
            String paymentId,
            JsonNullable<Boolean> testmode) throws Exception {
        ReleaseAuthorizationRequest request =
            ReleaseAuthorizationRequest
                .builder()
                .paymentId(paymentId)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ReleaseAuthorizationRequest.class,
                _baseUrl,
                "/payments/{paymentId}/release-authorization",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ReleaseAuthorizationRequest.class,
                request, 
                null));
        
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req,  
                this.sdkConfiguration.securitySource.getSecurity());
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "release-authorization", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "422", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "release-authorization",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "release-authorization",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "release-authorization",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ReleaseAuthorizationResponse.Builder _resBuilder = 
            ReleaseAuthorizationResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ReleaseAuthorizationResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "202")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ReleaseAuthorizationResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ReleaseAuthorizationResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ReleaseAuthorizationPaymentsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ReleaseAuthorizationPaymentsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
