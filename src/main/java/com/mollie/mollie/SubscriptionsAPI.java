/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.mollie.mollie;

import com.fasterxml.jackson.core.type.TypeReference;
import com.mollie.mollie.models.errors.APIException;
import com.mollie.mollie.models.errors.CancelSubscriptionResponseBody;
import com.mollie.mollie.models.errors.CreateSubscriptionResponseBody;
import com.mollie.mollie.models.errors.ListAllSubscriptionsSubscriptionsAPIResponseBody;
import com.mollie.mollie.models.errors.ListSubscriptionsSubscriptionsAPIResponseBody;
import com.mollie.mollie.models.errors.UpdateSubscriptionResponseBody;
import com.mollie.mollie.models.operations.CancelSubscriptionRequest;
import com.mollie.mollie.models.operations.CancelSubscriptionRequestBuilder;
import com.mollie.mollie.models.operations.CancelSubscriptionResponse;
import com.mollie.mollie.models.operations.CancelSubscriptionSecurity;
import com.mollie.mollie.models.operations.CreateSubscriptionRequest;
import com.mollie.mollie.models.operations.CreateSubscriptionRequestBody;
import com.mollie.mollie.models.operations.CreateSubscriptionRequestBuilder;
import com.mollie.mollie.models.operations.CreateSubscriptionResponse;
import com.mollie.mollie.models.operations.CreateSubscriptionSecurity;
import com.mollie.mollie.models.operations.GetSubscriptionRequest;
import com.mollie.mollie.models.operations.GetSubscriptionRequestBuilder;
import com.mollie.mollie.models.operations.GetSubscriptionResponse;
import com.mollie.mollie.models.operations.GetSubscriptionResponseBody;
import com.mollie.mollie.models.operations.GetSubscriptionSecurity;
import com.mollie.mollie.models.operations.ListAllSubscriptionsRequest;
import com.mollie.mollie.models.operations.ListAllSubscriptionsRequestBuilder;
import com.mollie.mollie.models.operations.ListAllSubscriptionsResponse;
import com.mollie.mollie.models.operations.ListAllSubscriptionsResponseBody;
import com.mollie.mollie.models.operations.ListAllSubscriptionsSecurity;
import com.mollie.mollie.models.operations.ListSubscriptionPaymentsRequest;
import com.mollie.mollie.models.operations.ListSubscriptionPaymentsRequestBuilder;
import com.mollie.mollie.models.operations.ListSubscriptionPaymentsResponse;
import com.mollie.mollie.models.operations.ListSubscriptionPaymentsResponseBody;
import com.mollie.mollie.models.operations.ListSubscriptionPaymentsSecurity;
import com.mollie.mollie.models.operations.ListSubscriptionsRequest;
import com.mollie.mollie.models.operations.ListSubscriptionsRequestBuilder;
import com.mollie.mollie.models.operations.ListSubscriptionsResponse;
import com.mollie.mollie.models.operations.ListSubscriptionsResponseBody;
import com.mollie.mollie.models.operations.ListSubscriptionsSecurity;
import com.mollie.mollie.models.operations.SDKMethodInterfaces.*;
import com.mollie.mollie.models.operations.UpdateSubscriptionRequest;
import com.mollie.mollie.models.operations.UpdateSubscriptionRequestBody;
import com.mollie.mollie.models.operations.UpdateSubscriptionRequestBuilder;
import com.mollie.mollie.models.operations.UpdateSubscriptionResponse;
import com.mollie.mollie.models.operations.UpdateSubscriptionSecurity;
import com.mollie.mollie.utils.HTTPClient;
import com.mollie.mollie.utils.HTTPRequest;
import com.mollie.mollie.utils.Hook.AfterErrorContextImpl;
import com.mollie.mollie.utils.Hook.AfterSuccessContextImpl;
import com.mollie.mollie.utils.Hook.BeforeRequestContextImpl;
import com.mollie.mollie.utils.SerializedBody;
import com.mollie.mollie.utils.Utils.JsonShape;
import com.mollie.mollie.utils.Utils;
import java.io.InputStream;
import java.lang.Boolean;
import java.lang.Exception;
import java.lang.Long;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable; 

public class SubscriptionsAPI implements
            MethodCallCreateSubscription,
            MethodCallListSubscriptions,
            MethodCallGetSubscription,
            MethodCallUpdateSubscription,
            MethodCallCancelSubscription,
            MethodCallListAllSubscriptions,
            MethodCallListSubscriptionPayments {

    private final SDKConfiguration sdkConfiguration;

    SubscriptionsAPI(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }


    /**
     * Create subscription
     * With subscriptions, you can schedule recurring payments to take place at regular intervals.
     * 
     * For example, by simply specifying an `amount` and an `interval`, you can create an endless subscription to charge a
     * monthly fee, until you cancel the subscription.
     * 
     * Or, you could use the times parameter to only charge a limited number of times, for example to split a big
     * transaction in multiple parts.
     * 
     * A few example usages:
     * 
     * `amount[currency]="EUR"` `amount[value]="5.00"` `interval="2 weeks"`
     * Your customer will be charged €5 once every two weeks.
     * 
     * `amount[currency]="EUR"` `amount[value]="20.00"` `interval="1 day" times=5`
     * Your customer will be charged €20 every day, for five consecutive days.
     * 
     * `amount[currency]="EUR"` `amount[value]="10.00"` `interval="1 month"`
     * `startDate="2018-04-30"`
     * Your customer will be charged €10 on the last day of each month, starting in April 2018.
     * @return The call builder
     */
    public CreateSubscriptionRequestBuilder create() {
        return new CreateSubscriptionRequestBuilder(this);
    }

    /**
     * Create subscription
     * With subscriptions, you can schedule recurring payments to take place at regular intervals.
     * 
     * For example, by simply specifying an `amount` and an `interval`, you can create an endless subscription to charge a
     * monthly fee, until you cancel the subscription.
     * 
     * Or, you could use the times parameter to only charge a limited number of times, for example to split a big
     * transaction in multiple parts.
     * 
     * A few example usages:
     * 
     * `amount[currency]="EUR"` `amount[value]="5.00"` `interval="2 weeks"`
     * Your customer will be charged €5 once every two weeks.
     * 
     * `amount[currency]="EUR"` `amount[value]="20.00"` `interval="1 day" times=5`
     * Your customer will be charged €20 every day, for five consecutive days.
     * 
     * `amount[currency]="EUR"` `amount[value]="10.00"` `interval="1 month"`
     * `startDate="2018-04-30"`
     * Your customer will be charged €10 on the last day of each month, starting in April 2018.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateSubscriptionResponse create(
            CreateSubscriptionSecurity security,
            String customerId) throws Exception {
        return create(security, customerId, Optional.empty());
    }
    
    /**
     * Create subscription
     * With subscriptions, you can schedule recurring payments to take place at regular intervals.
     * 
     * For example, by simply specifying an `amount` and an `interval`, you can create an endless subscription to charge a
     * monthly fee, until you cancel the subscription.
     * 
     * Or, you could use the times parameter to only charge a limited number of times, for example to split a big
     * transaction in multiple parts.
     * 
     * A few example usages:
     * 
     * `amount[currency]="EUR"` `amount[value]="5.00"` `interval="2 weeks"`
     * Your customer will be charged €5 once every two weeks.
     * 
     * `amount[currency]="EUR"` `amount[value]="20.00"` `interval="1 day" times=5`
     * Your customer will be charged €20 every day, for five consecutive days.
     * 
     * `amount[currency]="EUR"` `amount[value]="10.00"` `interval="1 month"`
     * `startDate="2018-04-30"`
     * Your customer will be charged €10 on the last day of each month, starting in April 2018.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CreateSubscriptionResponse create(
            CreateSubscriptionSecurity security,
            String customerId,
            Optional<? extends CreateSubscriptionRequestBody> requestBody) throws Exception {
        CreateSubscriptionRequest request =
            CreateSubscriptionRequest
                .builder()
                .customerId(customerId)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CreateSubscriptionRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "create-subscription", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "create-subscription",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "create-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CreateSubscriptionResponse.Builder _resBuilder = 
            CreateSubscriptionResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CreateSubscriptionResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "201")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CreateSubscriptionResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CreateSubscriptionResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List customer subscriptions
     * Retrieve all subscriptions of a customer.
     * 
     * The results are paginated.
     * @return The call builder
     */
    public ListSubscriptionsRequestBuilder list() {
        return new ListSubscriptionsRequestBuilder(this);
    }

    /**
     * List customer subscriptions
     * Retrieve all subscriptions of a customer.
     * 
     * The results are paginated.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListSubscriptionsResponse list(
            ListSubscriptionsSecurity security,
            String customerId) throws Exception {
        return list(security, customerId, Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * List customer subscriptions
     * Retrieve all subscriptions of a customer.
     * 
     * The results are paginated.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param from Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
    result set.
     * @param limit The maximum number of items to return. Defaults to 50 items.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListSubscriptionsResponse list(
            ListSubscriptionsSecurity security,
            String customerId,
            Optional<String> from,
            JsonNullable<Long> limit,
            JsonNullable<Boolean> testmode) throws Exception {
        ListSubscriptionsRequest request =
            ListSubscriptionsRequest
                .builder()
                .customerId(customerId)
                .from(from)
                .limit(limit)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ListSubscriptionsRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListSubscriptionsRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-subscriptions", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-subscriptions",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-subscriptions",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-subscriptions",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListSubscriptionsResponse.Builder _resBuilder = 
            ListSubscriptionsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListSubscriptionsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListSubscriptionsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListSubscriptionsResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListSubscriptionsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListSubscriptionsResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListSubscriptionsSubscriptionsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListSubscriptionsSubscriptionsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Get subscription
     * Retrieve a single subscription by its ID and the ID of its parent customer.
     * @return The call builder
     */
    public GetSubscriptionRequestBuilder get() {
        return new GetSubscriptionRequestBuilder(this);
    }

    /**
     * Get subscription
     * Retrieve a single subscription by its ID and the ID of its parent customer.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetSubscriptionResponse get(
            GetSubscriptionSecurity security,
            String customerId,
            String id) throws Exception {
        return get(security, customerId, id, JsonNullable.undefined());
    }
    
    /**
     * Get subscription
     * Retrieve a single subscription by its ID and the ID of its parent customer.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetSubscriptionResponse get(
            GetSubscriptionSecurity security,
            String customerId,
            String id,
            JsonNullable<Boolean> testmode) throws Exception {
        GetSubscriptionRequest request =
            GetSubscriptionRequest
                .builder()
                .customerId(customerId)
                .id(id)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetSubscriptionRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                GetSubscriptionRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "get-subscription", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "get-subscription",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "get-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetSubscriptionResponse.Builder _resBuilder = 
            GetSubscriptionResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetSubscriptionResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                GetSubscriptionResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GetSubscriptionResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.GetSubscriptionResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.GetSubscriptionResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Update subscription
     * Update an existing subscription.
     * 
     * Canceled subscriptions cannot be updated.
     * 
     * For an in-depth explanation of each parameter, refer to the [Create subscription](create-subscription) endpoint.
     * @return The call builder
     */
    public UpdateSubscriptionRequestBuilder update() {
        return new UpdateSubscriptionRequestBuilder(this);
    }

    /**
     * Update subscription
     * Update an existing subscription.
     * 
     * Canceled subscriptions cannot be updated.
     * 
     * For an in-depth explanation of each parameter, refer to the [Create subscription](create-subscription) endpoint.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateSubscriptionResponse update(
            UpdateSubscriptionSecurity security,
            String customerId,
            String id) throws Exception {
        return update(security, customerId, id, JsonNullable.undefined(), Optional.empty());
    }
    
    /**
     * Update subscription
     * Update an existing subscription.
     * 
     * Canceled subscriptions cannot be updated.
     * 
     * For an in-depth explanation of each parameter, refer to the [Create subscription](create-subscription) endpoint.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @param requestBody
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public UpdateSubscriptionResponse update(
            UpdateSubscriptionSecurity security,
            String customerId,
            String id,
            JsonNullable<Boolean> testmode,
            Optional<? extends UpdateSubscriptionRequestBody> requestBody) throws Exception {
        UpdateSubscriptionRequest request =
            UpdateSubscriptionRequest
                .builder()
                .customerId(customerId)
                .id(id)
                .testmode(testmode)
                .requestBody(requestBody)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                UpdateSubscriptionRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PATCH");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "requestBody",
                "json",
                false);
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                UpdateSubscriptionRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "update-subscription", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "update-subscription",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "update-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        UpdateSubscriptionResponse.Builder _resBuilder = 
            UpdateSubscriptionResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        UpdateSubscriptionResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                UpdateSubscriptionResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<UpdateSubscriptionResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Cancel subscription
     * Cancel an existing subscription. Canceling a subscription has no effect on the mandates of the customer.
     * @return The call builder
     */
    public CancelSubscriptionRequestBuilder cancel() {
        return new CancelSubscriptionRequestBuilder(this);
    }

    /**
     * Cancel subscription
     * Cancel an existing subscription. Canceling a subscription has no effect on the mandates of the customer.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelSubscriptionResponse cancel(
            CancelSubscriptionSecurity security,
            String customerId,
            String id) throws Exception {
        return cancel(security, customerId, id, JsonNullable.undefined());
    }
    
    /**
     * Cancel subscription
     * Cancel an existing subscription. Canceling a subscription has no effect on the mandates of the customer.
     * @param security The security details to use for authentication.
     * @param customerId Provide the ID of the related customer.
     * @param id Provide the ID of the item you want to perform this operation on.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CancelSubscriptionResponse cancel(
            CancelSubscriptionSecurity security,
            String customerId,
            String id,
            JsonNullable<Boolean> testmode) throws Exception {
        CancelSubscriptionRequest request =
            CancelSubscriptionRequest
                .builder()
                .customerId(customerId)
                .id(id)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CancelSubscriptionRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions/{id}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                CancelSubscriptionRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "cancel-subscription", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "cancel-subscription",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "cancel-subscription",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CancelSubscriptionResponse.Builder _resBuilder = 
            CancelSubscriptionResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CancelSubscriptionResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                Object _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<Object>() {});
                _res.withAny(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                CancelSubscriptionResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CancelSubscriptionResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List all subscriptions
     * Retrieve all subscriptions initiated across all your customers.
     * 
     * The results are paginated.
     * @return The call builder
     */
    public ListAllSubscriptionsRequestBuilder listAll() {
        return new ListAllSubscriptionsRequestBuilder(this);
    }

    /**
     * List all subscriptions
     * Retrieve all subscriptions initiated across all your customers.
     * 
     * The results are paginated.
     * @param security The security details to use for authentication.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListAllSubscriptionsResponse listAll(
            ListAllSubscriptionsSecurity security) throws Exception {
        return listAll(security, Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined());
    }
    
    /**
     * List all subscriptions
     * Retrieve all subscriptions initiated across all your customers.
     * 
     * The results are paginated.
     * @param security The security details to use for authentication.
     * @param from Provide an ID to start the result set from the item with the given ID and onwards. This allows you to paginate the
    result set.
     * @param limit The maximum number of items to return. Defaults to 50 items.
     * @param profileId The identifier referring to the [profile](get-profile) you wish to retrieve subscriptions for.

    Most API credentials are linked to a single profile. In these cases the `profileId` is already implied.

    To retrieve all subscriptions across the organization, use an organization-level API credential and omit the
    `profileId` parameter.
     * @param testmode Most API credentials are specifically created for either live mode or test mode. In those cases the `testmode` query
    parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by
    setting the `testmode` query parameter to `true`.

    Test entities cannot be retrieved when the endpoint is set to live mode, and vice versa.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListAllSubscriptionsResponse listAll(
            ListAllSubscriptionsSecurity security,
            Optional<String> from,
            JsonNullable<Long> limit,
            JsonNullable<String> profileId,
            JsonNullable<Boolean> testmode) throws Exception {
        ListAllSubscriptionsRequest request =
            ListAllSubscriptionsRequest
                .builder()
                .from(from)
                .limit(limit)
                .profileId(profileId)
                .testmode(testmode)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                _baseUrl,
                "/subscriptions");
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListAllSubscriptionsRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-all-subscriptions", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "404", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-all-subscriptions",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-all-subscriptions",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-all-subscriptions",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListAllSubscriptionsResponse.Builder _resBuilder = 
            ListAllSubscriptionsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListAllSubscriptionsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListAllSubscriptionsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListAllSubscriptionsResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListAllSubscriptionsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListAllSubscriptionsResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "404")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListAllSubscriptionsSubscriptionsAPIResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListAllSubscriptionsSubscriptionsAPIResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List subscription payments
     * Retrieve all payments of a specific subscription.
     * 
     * The results are paginated.
     * @return The call builder
     */
    public ListSubscriptionPaymentsRequestBuilder listPayments() {
        return new ListSubscriptionPaymentsRequestBuilder(this);
    }

    /**
     * List subscription payments
     * Retrieve all payments of a specific subscription.
     * 
     * The results are paginated.
     * @param request The request object containing all of the parameters for the API call.
     * @param security The security details to use for authentication.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListSubscriptionPaymentsResponse listPayments(
            ListSubscriptionPaymentsRequest request,
            ListSubscriptionPaymentsSecurity security) throws Exception {
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ListSubscriptionPaymentsRequest.class,
                _baseUrl,
                "/customers/{customerId}/subscriptions/{subscriptionId}/payments",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/hal+json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);

        _req.addQueryParams(Utils.getQueryParams(
                ListSubscriptionPaymentsRequest.class,
                request, 
                null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "list-subscription-payments", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "4XX", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-subscription-payments",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "list-subscription-payments",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "list-subscription-payments",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListSubscriptionPaymentsResponse.Builder _resBuilder = 
            ListSubscriptionPaymentsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListSubscriptionPaymentsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                ListSubscriptionPaymentsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<ListSubscriptionPaymentsResponseBody>() {});
                _res.withObject(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400")) {
            if (Utils.contentTypeMatches(_contentType, "application/hal+json")) {
                com.mollie.mollie.models.errors.ListSubscriptionPaymentsResponseBody _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<com.mollie.mollie.models.errors.ListSubscriptionPaymentsResponseBody>() {});
                    _out.withRawResponse(Optional.ofNullable(_httpRes));
                
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
